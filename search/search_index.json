{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 Taipy is an innovative low-code package to create complete applications in Python . It is composed of two main independent components: Taipy GUI and Taipy Core . The Graphical User Interface of Taipy allows anyone with basic knowledge of Python to create a beautiful and interactive interface. It is a simple and intuitive way to create a GUI. No need to know how to design web pages with CSS or HTML. Taipy uses an augmented syntax of Markdown to create your desired Web page. The Scenario Management component of Taipy is a powerful tool to manage business problems and pipelines. Using Taipy Core is straightforward. Among other features, you are able to: Keep track of your KPI, data, scenarios, pipelines, etc. Have smart scheduling Simplify industrialization for Data Visualization, Machine-Learning, Optimization, etc. You can use the GUI component without the Scenario Management and vice-versa. However, as you will see, they are incredibly efficient when combined. Other packages offer additional functionality, such as a REST API that allows for deploying Taipy application on Web architectures. The documentation for Taipy is divided in three main sections: 'Getting Started' provides a step-by-step opening to Taipy. Taipy features are leveraged as the application becomes more and more complex. 'User Manual' describes what the product concepts are, and how you can use them. 'Reference Manual' gathers all the Python APIs that Taipy exposes.","title":"Home"},{"location":"#home","text":"Taipy is an innovative low-code package to create complete applications in Python . It is composed of two main independent components: Taipy GUI and Taipy Core . The Graphical User Interface of Taipy allows anyone with basic knowledge of Python to create a beautiful and interactive interface. It is a simple and intuitive way to create a GUI. No need to know how to design web pages with CSS or HTML. Taipy uses an augmented syntax of Markdown to create your desired Web page. The Scenario Management component of Taipy is a powerful tool to manage business problems and pipelines. Using Taipy Core is straightforward. Among other features, you are able to: Keep track of your KPI, data, scenarios, pipelines, etc. Have smart scheduling Simplify industrialization for Data Visualization, Machine-Learning, Optimization, etc. You can use the GUI component without the Scenario Management and vice-versa. However, as you will see, they are incredibly efficient when combined. Other packages offer additional functionality, such as a REST API that allows for deploying Taipy application on Web architectures. The documentation for Taipy is divided in three main sections: 'Getting Started' provides a step-by-step opening to Taipy. Taipy features are leveraged as the application becomes more and more complex. 'User Manual' describes what the product concepts are, and how you can use them. 'Reference Manual' gathers all the Python APIs that Taipy exposes.","title":"Home"},{"location":"authors/","text":"Development lead \u00b6 Taipy is developed and maintained by Avaiga. Visit our website Contact us by email Contributors \u00b6 None yet. Why not be the first? Check out the contributing section !","title":"Development lead"},{"location":"authors/#development-lead","text":"Taipy is developed and maintained by Avaiga. Visit our website Contact us by email","title":"Development lead"},{"location":"authors/#contributors","text":"None yet. Why not be the first? Check out the contributing section !","title":"Contributors"},{"location":"history/","text":"History \u00b6 0.1.0 (2021-08-30) \u00b6 First release on PyPI.","title":"History"},{"location":"history/#history","text":"","title":"History"},{"location":"history/#010-2021-08-30","text":"First release on PyPI.","title":"0.1.0 (2021-08-30)"},{"location":"contributing/code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00b6 Our Pledge \u00b6 We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community. Our Standards \u00b6 Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people. Being respectful of differing opinions, viewpoints, and experiences. Giving and gracefully accepting constructive feedback. Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience. Focusing on what is best not just for us as individuals, but for the overall community. Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind. Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment. Publishing others' private information, such as a physical or email address, without their explicit permission. Other conduct which could reasonably be considered inappropriate in a professional setting. Enforcement Responsibilities \u00b6 Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate. Scope \u00b6 This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at rnd@avaiga.com. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident. Enforcement Guidelines \u00b6 Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct: 1. Correction \u00b6 Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested. 2. Warning \u00b6 Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban. 3. Temporary Ban \u00b6 Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban. 4. Permanent Ban \u00b6 Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","title":"Code of conduct"},{"location":"contributing/code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"contributing/code_of_conduct/#our-pledge","text":"We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.","title":"Our Pledge"},{"location":"contributing/code_of_conduct/#our-standards","text":"Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people. Being respectful of differing opinions, viewpoints, and experiences. Giving and gracefully accepting constructive feedback. Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience. Focusing on what is best not just for us as individuals, but for the overall community. Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind. Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment. Publishing others' private information, such as a physical or email address, without their explicit permission. Other conduct which could reasonably be considered inappropriate in a professional setting.","title":"Our Standards"},{"location":"contributing/code_of_conduct/#enforcement-responsibilities","text":"Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.","title":"Enforcement Responsibilities"},{"location":"contributing/code_of_conduct/#scope","text":"This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.","title":"Scope"},{"location":"contributing/code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at rnd@avaiga.com. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident.","title":"Enforcement"},{"location":"contributing/code_of_conduct/#enforcement-guidelines","text":"Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:","title":"Enforcement Guidelines"},{"location":"contributing/code_of_conduct/#1-correction","text":"Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.","title":"1. Correction"},{"location":"contributing/code_of_conduct/#2-warning","text":"Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.","title":"2. Warning"},{"location":"contributing/code_of_conduct/#3-temporary-ban","text":"Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.","title":"3. Temporary Ban"},{"location":"contributing/code_of_conduct/#4-permanent-ban","text":"Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community.","title":"4. Permanent Ban"},{"location":"contributing/code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","title":"Attribution"},{"location":"contributing/contributing/","text":"Contributions \u00b6 Thanks for your interest in helping improve Taipy! Contributions are welcome, and they are greatly appreciated! Every little help and credit will always be given. There are multiple ways to contribute to Taipy, code, but also reporting bugs, creating feature requests, helping other users in our forums, Stack Overflow, etc. Today the only way to communicate with the Taipy team is by GitHub issues. Before to contribute to Taipy, please read our Code of conduct . Never contributed on an open source project before ? \u00b6 Have a look on this GitHub documentation . Report bugs \u00b6 Reporting bugs is through GitHub issues . Please report relevant information and preferably code that exhibits the problem. We provide templates to help you to present the issue in a comprehensive way. The Taipy team will analyse and try to reproduce the bug to provide feedback. If confirmed, we will add a priority to the issue and add it in our backlog. Feel free to propose a pull request to fix it. Issue reporting, feedback, proposal, design or any other comment \u00b6 Any feedback or proposal is greatly appreciated! Do not hesitate to create an issue with the appropriate template on GitHub . The Taipy team will analyse your issue and return to you as soon as possible. Improve Documentation \u00b6 Do not hesitate to create an issue or pull request directly on the taipy-doc repository . Implement Features \u00b6 The Taipy team manages its backlog in private. Each issue that will be done during our current sprint is attached to the current sprint . Please, do not work on it, the Taipy team is on it. Code organisation \u00b6 Taipy is organised in four main repositories: taipy-core . taipy-gui . taipy-rest . taipy brings previous packages in a single one. Coding style and best practices \u00b6 Python \u00b6 Taipy's repositories follow the PEP 8 and PEP 484 coding convention. Javascript \u00b6 Taipy's repositories follow the W3Schools and Google coding convention. Git branches \u00b6 All new development happens in the develop branch. All pull requests should target that branch. We are following a strict branch naming convention based on the pattern: <type>/#<issueId>[<IssueSummary>] . Where: <type> would be one of: feature: new feature implementation, or improvement of a feature. fix: bug fix. review: change provoked by review comment not immediately taken care of. refactor: refactor of a piece of code. doc: doc changes (complement or typo fixes\u2026). build: in relation with the build process. <issueId> is the processed issue identifier. The advantage of explicitly indicating the issue number is that in GitHub, a pull request page shows a direct link to the issue description. [<IssueSummary>] is a short summary of the issue topic, not including spaces, using Camel case or lower-case, dash-separated words. This summary, with its dash (\u2018-\u2019) symbol prefix, is optional. Contribution workflow \u00b6 Find an issue without the label current sprint and add a comment on it to inform the community that you are working on it. Make your own fork of the repository target by the issue. Clone it on our local machine, then go inside the directory. We are working with Pipenv for our virtualenv. Create a local env and install development package by running pipenv install --dev , then run tests with pipenv run pytest to verify your setup. For convention help, we provide a pre-commit file. This tool will run before each commit and will automatically reformat code or raise warnings and errors based on the code format or Python typing. You can install and setup it up by doing: pipenv install pre-commit --skip-lock pipenv run python -m pre-commit install Make the change and create a pull request from your fork . Keep your pull request in draft until your work is finished. Do not hesitate to add a comment for help or questions. Before you submit a pull request read to review from your forked repo, check that it meets these guidelines: Include tests. Code is rebase . License is present. pre-commit works - without mypy error. GitHub's actions are passing. The taipy team will have a look at your Pull Request and will give feedback. If every requirement is valid, your work will be added in the next release, congratulation! Dependency management \u00b6 Taipy comes with multiple optional packages. You can find the list directly in the product or Taipy's packages. The back-end Pipfile does not install by default optional packages due to pyodbc requiring a driver's manual installation. This is not the behaviour for the front-end that installs all optional packages through its Pipfile. If you are a contributor on Taipy, be careful with dependencies, do not forget to install or uninstall depending on your issue. If you need to add to Taipy a new dependency, do not forget to add it in the Pipfile and the setup.py . Keep in mind that dependency is a vector of attack. The Taipy team limits the usage of external dependencies at the minimum.","title":"Contributing to Taipy"},{"location":"contributing/contributing/#contributions","text":"Thanks for your interest in helping improve Taipy! Contributions are welcome, and they are greatly appreciated! Every little help and credit will always be given. There are multiple ways to contribute to Taipy, code, but also reporting bugs, creating feature requests, helping other users in our forums, Stack Overflow, etc. Today the only way to communicate with the Taipy team is by GitHub issues. Before to contribute to Taipy, please read our Code of conduct .","title":"Contributions"},{"location":"contributing/contributing/#never-contributed-on-an-open-source-project-before-","text":"Have a look on this GitHub documentation .","title":"Never contributed on an open source project before ?"},{"location":"contributing/contributing/#report-bugs","text":"Reporting bugs is through GitHub issues . Please report relevant information and preferably code that exhibits the problem. We provide templates to help you to present the issue in a comprehensive way. The Taipy team will analyse and try to reproduce the bug to provide feedback. If confirmed, we will add a priority to the issue and add it in our backlog. Feel free to propose a pull request to fix it.","title":"Report bugs"},{"location":"contributing/contributing/#issue-reporting-feedback-proposal-design-or-any-other-comment","text":"Any feedback or proposal is greatly appreciated! Do not hesitate to create an issue with the appropriate template on GitHub . The Taipy team will analyse your issue and return to you as soon as possible.","title":"Issue reporting, feedback, proposal, design or any other comment"},{"location":"contributing/contributing/#improve-documentation","text":"Do not hesitate to create an issue or pull request directly on the taipy-doc repository .","title":"Improve Documentation"},{"location":"contributing/contributing/#implement-features","text":"The Taipy team manages its backlog in private. Each issue that will be done during our current sprint is attached to the current sprint . Please, do not work on it, the Taipy team is on it.","title":"Implement Features"},{"location":"contributing/contributing/#code-organisation","text":"Taipy is organised in four main repositories: taipy-core . taipy-gui . taipy-rest . taipy brings previous packages in a single one.","title":"Code organisation"},{"location":"contributing/contributing/#coding-style-and-best-practices","text":"","title":"Coding style and best practices"},{"location":"contributing/contributing/#python","text":"Taipy's repositories follow the PEP 8 and PEP 484 coding convention.","title":"Python"},{"location":"contributing/contributing/#javascript","text":"Taipy's repositories follow the W3Schools and Google coding convention.","title":"Javascript"},{"location":"contributing/contributing/#git-branches","text":"All new development happens in the develop branch. All pull requests should target that branch. We are following a strict branch naming convention based on the pattern: <type>/#<issueId>[<IssueSummary>] . Where: <type> would be one of: feature: new feature implementation, or improvement of a feature. fix: bug fix. review: change provoked by review comment not immediately taken care of. refactor: refactor of a piece of code. doc: doc changes (complement or typo fixes\u2026). build: in relation with the build process. <issueId> is the processed issue identifier. The advantage of explicitly indicating the issue number is that in GitHub, a pull request page shows a direct link to the issue description. [<IssueSummary>] is a short summary of the issue topic, not including spaces, using Camel case or lower-case, dash-separated words. This summary, with its dash (\u2018-\u2019) symbol prefix, is optional.","title":"Git branches"},{"location":"contributing/contributing/#contribution-workflow","text":"Find an issue without the label current sprint and add a comment on it to inform the community that you are working on it. Make your own fork of the repository target by the issue. Clone it on our local machine, then go inside the directory. We are working with Pipenv for our virtualenv. Create a local env and install development package by running pipenv install --dev , then run tests with pipenv run pytest to verify your setup. For convention help, we provide a pre-commit file. This tool will run before each commit and will automatically reformat code or raise warnings and errors based on the code format or Python typing. You can install and setup it up by doing: pipenv install pre-commit --skip-lock pipenv run python -m pre-commit install Make the change and create a pull request from your fork . Keep your pull request in draft until your work is finished. Do not hesitate to add a comment for help or questions. Before you submit a pull request read to review from your forked repo, check that it meets these guidelines: Include tests. Code is rebase . License is present. pre-commit works - without mypy error. GitHub's actions are passing. The taipy team will have a look at your Pull Request and will give feedback. If every requirement is valid, your work will be added in the next release, congratulation!","title":"Contribution workflow"},{"location":"contributing/contributing/#dependency-management","text":"Taipy comes with multiple optional packages. You can find the list directly in the product or Taipy's packages. The back-end Pipfile does not install by default optional packages due to pyodbc requiring a driver's manual installation. This is not the behaviour for the front-end that installs all optional packages through its Pipfile. If you are a contributor on Taipy, be careful with dependencies, do not forget to install or uninstall depending on your issue. If you need to add to Taipy a new dependency, do not forget to add it in the Pipfile and the setup.py . Keep in mind that dependency is a vector of attack. The Taipy team limits the usage of external dependencies at the minimum.","title":"Dependency management"},{"location":"credits/contributors/","text":"Contributors \u00b6 None yet. Why not be the first? Check out the contributing section !","title":"Contributors"},{"location":"credits/contributors/#contributors","text":"None yet. Why not be the first? Check out the contributing section !","title":"Contributors"},{"location":"credits/development_lead/","text":"Development lead \u00b6 Taipy is developped and maintained by Avaiga. Visit our website Contact us by email","title":"Development lead"},{"location":"credits/development_lead/#development-lead","text":"Taipy is developped and maintained by Avaiga. Visit our website Contact us by email","title":"Development lead"},{"location":"examples/","text":"taipy \u00b6","title":"taipy"},{"location":"examples/#taipy","text":"","title":"taipy"},{"location":"getting_started/","text":"Getting Started with Taipy \u00b6 Welcome to the Getting Started guide for Taipy. This tour shows you how to create an entire application using the two components of Taipy: Graphical User Interface builder (Taipy GUI): allows any Python developer to create a complex and interactive GUI. Scenario Management (Taipy Core): implements a modern backend for any data-driven application based on your business case. You can use Taipy GUI without Taipy Core and vice-versa. However, as you will see, they are incredibly efficient when combined. Each step of the \"Getting Started\" will focus on basic concepts of Taipy . Note that every step is dependent on the code of the previous one. After completing the last step, you will have the skills to develop your own Taipy application. Before we begin \u00b6 Three packages have to be installed: Taipy package, it requires a 3.8 Python version or above; scikit-learn : A Machine-Learning package that will be used in the Getting Started user code; statsmodels : Another package for statistics also used in the user code. $ pip install taipy $ pip install scikit-learn $ pip install statsmodels Info pip install taipy is the preferred method to install the latest stable version of Taipy. If you don't have pip installed, this Python installation guide can guide you through the process. Using Notebooks \u00b6 This Getting Started is for Python scripts ( .py ) only. If you want to use Jupyter Notebooks , download this notebook that deals with the specific functions for Notebooks. So, without further delay, let's begin to code! Steps \u00b6 First web page Visual elements Interactive GUI Introducing Taipy Core Pipeline Management GUI & Pipeline Creation of Scenarios GUI & Scenarios Modify Data Nodes content Manage Scenarios Embellish your APP Introducing Cycles Compare Scenarios","title":"Getting Started with Taipy"},{"location":"getting_started/#getting-started-with-taipy","text":"Welcome to the Getting Started guide for Taipy. This tour shows you how to create an entire application using the two components of Taipy: Graphical User Interface builder (Taipy GUI): allows any Python developer to create a complex and interactive GUI. Scenario Management (Taipy Core): implements a modern backend for any data-driven application based on your business case. You can use Taipy GUI without Taipy Core and vice-versa. However, as you will see, they are incredibly efficient when combined. Each step of the \"Getting Started\" will focus on basic concepts of Taipy . Note that every step is dependent on the code of the previous one. After completing the last step, you will have the skills to develop your own Taipy application.","title":"Getting Started with Taipy"},{"location":"getting_started/#before-we-begin","text":"Three packages have to be installed: Taipy package, it requires a 3.8 Python version or above; scikit-learn : A Machine-Learning package that will be used in the Getting Started user code; statsmodels : Another package for statistics also used in the user code. $ pip install taipy $ pip install scikit-learn $ pip install statsmodels Info pip install taipy is the preferred method to install the latest stable version of Taipy. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Before we begin"},{"location":"getting_started/#using-notebooks","text":"This Getting Started is for Python scripts ( .py ) only. If you want to use Jupyter Notebooks , download this notebook that deals with the specific functions for Notebooks. So, without further delay, let's begin to code!","title":"Using Notebooks"},{"location":"getting_started/#steps","text":"First web page Visual elements Interactive GUI Introducing Taipy Core Pipeline Management GUI & Pipeline Creation of Scenarios GUI & Scenarios Modify Data Nodes content Manage Scenarios Embellish your APP Introducing Cycles Compare Scenarios","title":"Steps"},{"location":"getting_started/installation/","text":"Installation \u00b6 Stable release \u00b6 To install Taipy, run this command in your terminal: $ pip install taipy This is the preferred method to install Taipy, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for Taipy can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/avaiga/taipy Or download the tarball : $ curl -OJL https://github.com/avaiga/taipy/tarball/main Once you have a copy of the source, you can install it with: $ pip install .","title":"Installation"},{"location":"getting_started/installation/#installation","text":"","title":"Installation"},{"location":"getting_started/installation/#stable-release","text":"To install Taipy, run this command in your terminal: $ pip install taipy This is the preferred method to install Taipy, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"getting_started/installation/#from-source","text":"The source for Taipy can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/avaiga/taipy Or download the tarball : $ curl -OJL https://github.com/avaiga/taipy/tarball/main Once you have a copy of the source, you can install it with: $ pip install .","title":"From source"},{"location":"getting_started/step_00/ReadMe/","text":"You can download the code for this step here or all the steps here . For Notebooks The \"Getting Started\" Notebook is available here . The code of the steps doesn't deal with the specific GUI functions for Notebooks. Step 0: First web page \u00b6 To create your first Taipy web page, you only need one line of code. Create a Gui object with a String and run it. A client link will be displayed in the console. Enter it in a web browser to open your first Taipy web client! from taipy import Gui # A dark mode is available in Taipy # However, we will use the light mode for the Getting Started Gui ( page = \"# Getting started with *Taipy*\" ) . run ( dark_mode = False ) If you want to run multiple servers at the same time, you can change the server port number (5000 by default) in the .run() method. For example, Gui(...).run(port=xxxx) . Note that you can style the text. Taipy uses the Markdown syntax to style your text and more. Therefore, # creates a title, ## makes a subtitle. Put your text in * for italics or in ** to have it in bold .","title":"Step 0: First web page"},{"location":"getting_started/step_00/ReadMe/#step-0-first-web-page","text":"To create your first Taipy web page, you only need one line of code. Create a Gui object with a String and run it. A client link will be displayed in the console. Enter it in a web browser to open your first Taipy web client! from taipy import Gui # A dark mode is available in Taipy # However, we will use the light mode for the Getting Started Gui ( page = \"# Getting started with *Taipy*\" ) . run ( dark_mode = False ) If you want to run multiple servers at the same time, you can change the server port number (5000 by default) in the .run() method. For example, Gui(...).run(port=xxxx) . Note that you can style the text. Taipy uses the Markdown syntax to style your text and more. Therefore, # creates a title, ## makes a subtitle. Put your text in * for italics or in ** to have it in bold .","title":"Step 0: First web page"},{"location":"getting_started/step_01/ReadMe/","text":"You can download the code of this step here or all the steps here . For Notebooks The \"Getting Started\" Notebook is available here . The code of the steps doesn't deal with the specific GUI functions for Notebooks. Step 1: Visual elements \u00b6 Many visual elements can be added to the basic code viewed in Step 0. This Step shows how to use visual elements like charts, sliders and tables and implement them in the GUI. Importing the Dataset \u00b6 Suppose that you have a dataset.csv file, using the Pandas library, you can retrieve this dataset with the following codes: import pandas as pd def get_data ( path_to_csv : str ): # pandas.read_csv() returns a pd.DataFrame dataset = pd . read_csv ( path_to_csv ) dataset [ \"Date\" ] = pd . to_datetime ( dataset [ \"Date\" ]) return dataset # Read the dataframe path_to_csv = \"dataset.csv\" dataset = get_data ( path_to_csv ) ... dataset is a pd.DataFrame , a basic Pandas main object representing, in this case, a realistic time series. It represents the historical number of articles sold for a given store on a 15-minute basis (we have the historical sales data for the year 2021). Being a real dataset, there will sometimes be missing information for specific days. The columns are: Index: a unique identifier for each data point. Date: the date of the data point. Each date are separated by 15 minutes. Value: the number of articles sold per 15-minute timeframe. After creating your first web client with just one line of code and reading our dataset data with the code above, let's add some visual elements to our initial page. Visual elements \u00b6 Taipy GUI can be considered as an augmented Markdown; it adds the concept of Visual elements on top of all the Markdown syntax. A visual element is a Taipy graphical object displayed on the client. It can be a slider , a chart , a table , an input , a menu , etc. Check the list here . Every visual element follows a similar syntax: <|{variable}|visual_element_name|param_1=param_1|param_2=param_2| ... |> . For example, a slider is written this way : <|{variable}|slider|min=min_value|max=max_value|> . For each visual element you wish to add to your web page, you must include the syntax above inside your markdown string (representing your page). For example, at the beginning of the page, let's display: a Python variable n_week ; a slider that will \"visually\" modify the value of n_week . Here is the overall syntax: *<|{n_week}|>* <|{n_week}|slider|min=1|max=52|> We will then create a chart and a table: <|{dataset}|chart|type=bar|x=Date|y=Value|height=100%|> <|{dataset}|table|height=400px|width=95%|> Here is the combined code: ... from taipy import Gui dataset = get_data ( path_to_csv ) # Initial value n_week = 10 # Definition of the page page = \"\"\" # Getting started with Taipy Week number: *<| {n_week} |>* Interact with this slider to change the week number: <| {n_week} |slider|min=1|max=52|> ## Dataset: Display the last three months of data: <| {dataset[9000:]} |chart|type=bar|x=Date|y=Value|height=100%|> <| {dataset} |table|height=400px|width=95%|> \"\"\" # Create a Gui object with our page content Gui ( page = page ) . run ( dark_mode = False )","title":"Step 1: Visual elements"},{"location":"getting_started/step_01/ReadMe/#step-1-visual-elements","text":"Many visual elements can be added to the basic code viewed in Step 0. This Step shows how to use visual elements like charts, sliders and tables and implement them in the GUI.","title":"Step 1: Visual elements"},{"location":"getting_started/step_01/ReadMe/#importing-the-dataset","text":"Suppose that you have a dataset.csv file, using the Pandas library, you can retrieve this dataset with the following codes: import pandas as pd def get_data ( path_to_csv : str ): # pandas.read_csv() returns a pd.DataFrame dataset = pd . read_csv ( path_to_csv ) dataset [ \"Date\" ] = pd . to_datetime ( dataset [ \"Date\" ]) return dataset # Read the dataframe path_to_csv = \"dataset.csv\" dataset = get_data ( path_to_csv ) ... dataset is a pd.DataFrame , a basic Pandas main object representing, in this case, a realistic time series. It represents the historical number of articles sold for a given store on a 15-minute basis (we have the historical sales data for the year 2021). Being a real dataset, there will sometimes be missing information for specific days. The columns are: Index: a unique identifier for each data point. Date: the date of the data point. Each date are separated by 15 minutes. Value: the number of articles sold per 15-minute timeframe. After creating your first web client with just one line of code and reading our dataset data with the code above, let's add some visual elements to our initial page.","title":"Importing the Dataset"},{"location":"getting_started/step_01/ReadMe/#visual-elements","text":"Taipy GUI can be considered as an augmented Markdown; it adds the concept of Visual elements on top of all the Markdown syntax. A visual element is a Taipy graphical object displayed on the client. It can be a slider , a chart , a table , an input , a menu , etc. Check the list here . Every visual element follows a similar syntax: <|{variable}|visual_element_name|param_1=param_1|param_2=param_2| ... |> . For example, a slider is written this way : <|{variable}|slider|min=min_value|max=max_value|> . For each visual element you wish to add to your web page, you must include the syntax above inside your markdown string (representing your page). For example, at the beginning of the page, let's display: a Python variable n_week ; a slider that will \"visually\" modify the value of n_week . Here is the overall syntax: *<|{n_week}|>* <|{n_week}|slider|min=1|max=52|> We will then create a chart and a table: <|{dataset}|chart|type=bar|x=Date|y=Value|height=100%|> <|{dataset}|table|height=400px|width=95%|> Here is the combined code: ... from taipy import Gui dataset = get_data ( path_to_csv ) # Initial value n_week = 10 # Definition of the page page = \"\"\" # Getting started with Taipy Week number: *<| {n_week} |>* Interact with this slider to change the week number: <| {n_week} |slider|min=1|max=52|> ## Dataset: Display the last three months of data: <| {dataset[9000:]} |chart|type=bar|x=Date|y=Value|height=100%|> <| {dataset} |table|height=400px|width=95%|> \"\"\" # Create a Gui object with our page content Gui ( page = page ) . run ( dark_mode = False )","title":"Visual elements"},{"location":"getting_started/step_02/ReadMe/","text":"You can download the code of this step here or all the steps here . For Notebooks The \"Getting Started\" Notebook is available here . The code of the steps doesn't deal with the specific GUI functions for Notebooks. Step 2: Interactive GUI \u00b6 Now, the page has several visual elements: A slider that is connected to the Python variable n_week ; A chart and a table controls that represent the DataFrame content. Taipy GUI manages everything. To go further into Taipy GUI, let's consider the concept of state . Multi-client - state \u00b6 Try to open a few clients with the same URL. You will see that every client is independent from each other; you can change n_week on a client, and n_week will not change in other clients. This is due to the concept of state . The state holds the value of all the variables that are used in the user interface, for one specific connection. For example, at the beginning, state.n_week = 10 . When n_week is modified by the slider (through a given graphical client), this is, in fact, state.n_week that is modified, not n_week (the global Python variable). Therefore, if you open 2 different clients, n_week will have 2 state values ( state.n_week ), one for each client. In the code below, this concept will be used to connect a variable ( n_week ) to other variables: We will create a chart that will only display one week of data corresponding to the selected week of the slider. A connection has to be made between the slider's value ( state.n_week ) and the chart data ( state.dataset_week ). How to connect two variables - the on_change function \u00b6 In Taipy , the on_change() function is a \"special\" function. Taipy will check if you created a function with this name and will use it. Whenever the state of a variable is modified, the callback function is called with three parameters: state (the state object containing all the variables) The name of the modified variable Its value. Here, on_change() will be called whenever the slider's value ( state.n_week ) changes. Each time this happens, state.dataset_week will be updated according to the new value of the selected week. Then, Taipy will propagate this change automatically to the associated chart. # Select the week based on the the slider value dataset_week = dataset [ dataset [ \"Date\" ] . dt . isocalendar () . week == n_week ] page = \"\"\" # Getting started with Taipy Select week: *<| {n_week} |>* <| {n_week} |slider|min=1|max=52|> <| {dataset_week} |chart|type=bar|x=Date|y=Value|height=100%|width=100%|> \"\"\" # on_change is the function that is called when any variable is changed def on_change ( state , var_name : str , var_value ): if var_name == \"n_week\" : # Update the dataset when the slider is moved state . dataset_week = dataset [ dataset [ \"Date\" ] . dt . isocalendar () . week == var_value ] Gui ( page = page ) . run ( dark_mode = False )","title":"Step 2: Interactive GUI"},{"location":"getting_started/step_02/ReadMe/#step-2-interactive-gui","text":"Now, the page has several visual elements: A slider that is connected to the Python variable n_week ; A chart and a table controls that represent the DataFrame content. Taipy GUI manages everything. To go further into Taipy GUI, let's consider the concept of state .","title":"Step 2: Interactive GUI"},{"location":"getting_started/step_02/ReadMe/#multi-client---state","text":"Try to open a few clients with the same URL. You will see that every client is independent from each other; you can change n_week on a client, and n_week will not change in other clients. This is due to the concept of state . The state holds the value of all the variables that are used in the user interface, for one specific connection. For example, at the beginning, state.n_week = 10 . When n_week is modified by the slider (through a given graphical client), this is, in fact, state.n_week that is modified, not n_week (the global Python variable). Therefore, if you open 2 different clients, n_week will have 2 state values ( state.n_week ), one for each client. In the code below, this concept will be used to connect a variable ( n_week ) to other variables: We will create a chart that will only display one week of data corresponding to the selected week of the slider. A connection has to be made between the slider's value ( state.n_week ) and the chart data ( state.dataset_week ).","title":"Multi-client - state"},{"location":"getting_started/step_02/ReadMe/#how-to-connect-two-variables---the-on_change-function","text":"In Taipy , the on_change() function is a \"special\" function. Taipy will check if you created a function with this name and will use it. Whenever the state of a variable is modified, the callback function is called with three parameters: state (the state object containing all the variables) The name of the modified variable Its value. Here, on_change() will be called whenever the slider's value ( state.n_week ) changes. Each time this happens, state.dataset_week will be updated according to the new value of the selected week. Then, Taipy will propagate this change automatically to the associated chart. # Select the week based on the the slider value dataset_week = dataset [ dataset [ \"Date\" ] . dt . isocalendar () . week == n_week ] page = \"\"\" # Getting started with Taipy Select week: *<| {n_week} |>* <| {n_week} |slider|min=1|max=52|> <| {dataset_week} |chart|type=bar|x=Date|y=Value|height=100%|width=100%|> \"\"\" # on_change is the function that is called when any variable is changed def on_change ( state , var_name : str , var_value ): if var_name == \"n_week\" : # Update the dataset when the slider is moved state . dataset_week = dataset [ dataset [ \"Date\" ] . dt . isocalendar () . week == var_value ] Gui ( page = page ) . run ( dark_mode = False )","title":"How to connect two variables - the on_change function"},{"location":"getting_started/step_03/ReadMe/","text":"You can download the code of this step here or all the steps here . For Notebooks The \"Getting Started\" Notebook is available here . The code of the steps doesn't deal with the specific GUI functions for Notebooks. Step 3: Introducing Taipy Core \u00b6 From Step 2, you now know the basics of Taipy GUI. Let's go for a moment over the Scenario Management aspect of Taipy. Even if Taipy GUI can be used without Taipy Core (and vice-versa), there are a lot of reasons for using Taipy Core: Taipy Core efficiently manages the execution of your functions/pipelines. Taipy Core manages data sources and monitors KPIs. Taipy Core provides an easy management of multiple pipelines and end-user scenarios which comes in handy in the context of Machine Learning or Mathematical optimization. To apprehend the Scenario Management aspect of Taipy, you need to understand four essential concepts. Four fundamental concepts in Taipy Core: \u00b6 Data Nodes : are the translation of variables in Taipy. Data Nodes don't contain the data itself but know how to retrieve it. They can refer to any kind of data: any Python object ( string , int , list , dict , model , dataframe , etc), a Pickle file, a CSV file, an SQL database, etc. They know how to read and write data. You can even write your own custom Data Node if needed to access a particular data format. Tasks : are the translation of functions in Taipy. Pipelines : are a list of tasks executed with intelligent scheduling created automatically by Taipy. They usually represent a sequence of Tasks/functions corresponding to different algorithms like a simple baseline Algorithm or a more sophisticated Machine-Learning pipeline. Scenarios : End-Users very often require modifying various parameters to reflect different business situations. Taipy Scenarios will provide the framework to \"play\"/\"execute\" pipelines under different conditions/variations (i.e. data/parameters modified by the end-user) Let's create a Machine Learning (ML) example to clarify these concepts. In a ML context, it is common to have numerous training and testing pipelines for different algorithms. For simplification, we will only configure a single baseline pipeline that will predict on a given day the values for the following days. In Taipy, you will describe (i.e. configure) your pipeline with three tasks: Retrieval of the initial dataset, Data Cleaning, Predictions (for number of predictions ) from day onwards. In our example, predictions represents the number of items sold in a given store on a 15-min basis. This graph is created by configuring Data Nodes (variables) and tasks (functions). This configuration doesn't execute anything; it is just a configuration that enables Taipy to map the Tasks and Data Nodes as a Directed Acyclic Graph (DAG). Data Nodes configuration \u00b6 Data Nodes can point to: any kind of Python variables by default: int , string , dict , list , np.array , pd.DataFrame , models , etc. a CSV file, Pickle file or SQL database. During the configuration of the Data Nodes, the developer specifies the type or format of each Data Node. A Python variable is stored by default by a Pickle file. Some parameters for Data Node configuration: Storage type : This is where the storage type is selected: CSV file, SQL database, Pickle file, etc. Here, the initial dataset is a CSV file so storage_type=\"csv\" for this Data Node. Taipy knows how to access it, thanks to the path. By default, the storage type is pickle . Scope : You can find below three types of Scope in the code: the Pipeline, the Scenario (by default) and the Global scope. Global scope : all Data Nodes are shared between every pipelines, scenarios and cycles. For example, the initial dataset is shared between every pipelines and scenarios. Scenario scope : they are shared between all the pipelines of the scenario. Pipeline scope : Data Nodes don't have access to other Data Nodes from other pipelines. A 'predictions' Data Node is created for each pipeline in the current example. So, adding pipelines/algorithms will store predictions in different \"predictions\" Data Nodes. Cacheable : This is a parameter used to increase the efficiency of the program. If the Data Node has already been created and if its input/upstream data nodes haven\u2019t changed since the last run (of the pipeline), then it is not necessary to rerun the task that creates it. Input Data Nodes configuration \u00b6 These are the input Data Nodes. They represent the variables in Taipy when a pipeline is executed. Still, first, we have to configure them to create the DAG. initial_dataset is simply the initial CSV file. Taipy needs some parameters to read this data: path and header . The scope is global; each scenario or pipeline has the same initial dataset. day is the beginning of the predictions. The default value is the 26th of July. It means the training data will end before the 26th of July, and predictions will begin on this day. n_predictions is the number of predictions you want to make while predicting. The default value is 40. A prediction represents the number of items sold in a given store per 15-minute time slot. max_capacity is the maximum value that can take a prediction; it is the ceiling of the projections. The default value is 200. It means that, in our example, the maximum number of items sold per 15 minutes is 200. import datetime as dt import pandas as pd from taipy import Config , Scope ## Input Data Nodes initial_dataset_cfg = Config . configure_data_node ( id = \"initial_dataset\" , storage_type = \"csv\" , path = path_to_csv , scope = Scope . GLOBAL ) # We assume the current day is the 26th of July 2021. # This day can be changed to simulate multiple executions of scenarios on different days day_cfg = Config . configure_data_node ( id = \"day\" , default_data = dt . datetime ( 2021 , 7 , 26 )) n_predictions_cfg = Config . configure_data_node ( id = \"n_predictions\" , default_data = 40 ) max_capacity_cfg = Config . configure_data_node ( id = \"max_capacity\" , default_data = 200 ) Remaining Data Nodes \u00b6 cleaned_dataset is the dataset after cleaning (after the clean_data() function). cacheable is set to True with a scope.GLOBAL . It means if the initial dataset didn't change, Taipy will not re-execute the clean_data() task. In other words, after the creation of this data node through clean_data() , Taipy knows that it is not necessary to create it again. predictions are the predictions of the model. In this pipeline, it will be the output of the predict_baseline() function. Each pipeline will create its own prediction Data Node hence scope=Scope.PIPELINE . ## Remaining Data Nodes cleaned_dataset_cfg = Config . configure_data_node ( id = \"cleaned_dataset\" , cacheable = True , validity_period = dt . timedelta ( days = 1 ), scope = Scope . GLOBAL ) predictions_cfg = Config . configure_data_node ( id = \"predictions\" , scope = Scope . PIPELINE ) Functions \u00b6 Here\u2019s the code of each of the two Python functions: clean_data() and predict_baseline() . Their goal is respectively to clean the data and to predict the data. def clean_data ( initial_dataset : pd . DataFrame ): print ( \" Cleaning data\" ) # Convert the date column to datetime initial_dataset [ \"Date\" ] = pd . to_datetime ( initial_dataset [ \"Date\" ]) cleaned_dataset = initial_dataset . copy () return cleaned_dataset def predict_baseline ( cleaned_dataset : pd . DataFrame , n_predictions : int , day : dt . datetime , max_capacity : int ): print ( \" Predicting baseline\" ) # Select the train data train_dataset = cleaned_dataset [ cleaned_dataset [ \"Date\" ] < day ] predictions = train_dataset [ \"Value\" ][ - n_predictions :] . reset_index ( drop = True ) predictions = predictions . apply ( lambda x : min ( x , max_capacity )) return predictions Tasks \u00b6 Tasks are the translation of functions in Taipy. These tasks combined with Data Nodes create your graph (DAG). Creating a task is simple; you need: An id A function Inputs Outputs clean_data_task \u00b6 The first task that you want to create is your clean_data() task. It will take your initial dataset (input Data Node), clean it (calling the clean_data() function) and generate the cleaned dataset Data Node. clean_data_task_cfg = Config . configure_task ( id = \"clean_data\" , function = clean_data , input = initial_dataset_cfg , output = cleaned_dataset_cfg ) predict_baseline_task \u00b6 This task will take the cleaned dataset and predict it according to your parameters i.e. the three input Data Nodes: Day , Number of predictions and Max Capacity . predict_baseline_task_cfg = Config . configure_task ( id = \"predict_baseline\" , function = predict_baseline , input = [ cleaned_dataset_cfg , n_predictions_cfg , day_cfg , max_capacity_cfg ], output = predictions_cfg )","title":"Step 3: Introducing Taipy Core"},{"location":"getting_started/step_03/ReadMe/#step-3-introducing-taipy-core","text":"From Step 2, you now know the basics of Taipy GUI. Let's go for a moment over the Scenario Management aspect of Taipy. Even if Taipy GUI can be used without Taipy Core (and vice-versa), there are a lot of reasons for using Taipy Core: Taipy Core efficiently manages the execution of your functions/pipelines. Taipy Core manages data sources and monitors KPIs. Taipy Core provides an easy management of multiple pipelines and end-user scenarios which comes in handy in the context of Machine Learning or Mathematical optimization. To apprehend the Scenario Management aspect of Taipy, you need to understand four essential concepts.","title":"Step 3: Introducing Taipy Core"},{"location":"getting_started/step_03/ReadMe/#four-fundamental-concepts-in-taipy-core","text":"Data Nodes : are the translation of variables in Taipy. Data Nodes don't contain the data itself but know how to retrieve it. They can refer to any kind of data: any Python object ( string , int , list , dict , model , dataframe , etc), a Pickle file, a CSV file, an SQL database, etc. They know how to read and write data. You can even write your own custom Data Node if needed to access a particular data format. Tasks : are the translation of functions in Taipy. Pipelines : are a list of tasks executed with intelligent scheduling created automatically by Taipy. They usually represent a sequence of Tasks/functions corresponding to different algorithms like a simple baseline Algorithm or a more sophisticated Machine-Learning pipeline. Scenarios : End-Users very often require modifying various parameters to reflect different business situations. Taipy Scenarios will provide the framework to \"play\"/\"execute\" pipelines under different conditions/variations (i.e. data/parameters modified by the end-user) Let's create a Machine Learning (ML) example to clarify these concepts. In a ML context, it is common to have numerous training and testing pipelines for different algorithms. For simplification, we will only configure a single baseline pipeline that will predict on a given day the values for the following days. In Taipy, you will describe (i.e. configure) your pipeline with three tasks: Retrieval of the initial dataset, Data Cleaning, Predictions (for number of predictions ) from day onwards. In our example, predictions represents the number of items sold in a given store on a 15-min basis. This graph is created by configuring Data Nodes (variables) and tasks (functions). This configuration doesn't execute anything; it is just a configuration that enables Taipy to map the Tasks and Data Nodes as a Directed Acyclic Graph (DAG).","title":"Four fundamental concepts in Taipy Core:"},{"location":"getting_started/step_03/ReadMe/#data-nodes-configuration","text":"Data Nodes can point to: any kind of Python variables by default: int , string , dict , list , np.array , pd.DataFrame , models , etc. a CSV file, Pickle file or SQL database. During the configuration of the Data Nodes, the developer specifies the type or format of each Data Node. A Python variable is stored by default by a Pickle file. Some parameters for Data Node configuration: Storage type : This is where the storage type is selected: CSV file, SQL database, Pickle file, etc. Here, the initial dataset is a CSV file so storage_type=\"csv\" for this Data Node. Taipy knows how to access it, thanks to the path. By default, the storage type is pickle . Scope : You can find below three types of Scope in the code: the Pipeline, the Scenario (by default) and the Global scope. Global scope : all Data Nodes are shared between every pipelines, scenarios and cycles. For example, the initial dataset is shared between every pipelines and scenarios. Scenario scope : they are shared between all the pipelines of the scenario. Pipeline scope : Data Nodes don't have access to other Data Nodes from other pipelines. A 'predictions' Data Node is created for each pipeline in the current example. So, adding pipelines/algorithms will store predictions in different \"predictions\" Data Nodes. Cacheable : This is a parameter used to increase the efficiency of the program. If the Data Node has already been created and if its input/upstream data nodes haven\u2019t changed since the last run (of the pipeline), then it is not necessary to rerun the task that creates it.","title":"Data Nodes configuration"},{"location":"getting_started/step_03/ReadMe/#input-data-nodes-configuration","text":"These are the input Data Nodes. They represent the variables in Taipy when a pipeline is executed. Still, first, we have to configure them to create the DAG. initial_dataset is simply the initial CSV file. Taipy needs some parameters to read this data: path and header . The scope is global; each scenario or pipeline has the same initial dataset. day is the beginning of the predictions. The default value is the 26th of July. It means the training data will end before the 26th of July, and predictions will begin on this day. n_predictions is the number of predictions you want to make while predicting. The default value is 40. A prediction represents the number of items sold in a given store per 15-minute time slot. max_capacity is the maximum value that can take a prediction; it is the ceiling of the projections. The default value is 200. It means that, in our example, the maximum number of items sold per 15 minutes is 200. import datetime as dt import pandas as pd from taipy import Config , Scope ## Input Data Nodes initial_dataset_cfg = Config . configure_data_node ( id = \"initial_dataset\" , storage_type = \"csv\" , path = path_to_csv , scope = Scope . GLOBAL ) # We assume the current day is the 26th of July 2021. # This day can be changed to simulate multiple executions of scenarios on different days day_cfg = Config . configure_data_node ( id = \"day\" , default_data = dt . datetime ( 2021 , 7 , 26 )) n_predictions_cfg = Config . configure_data_node ( id = \"n_predictions\" , default_data = 40 ) max_capacity_cfg = Config . configure_data_node ( id = \"max_capacity\" , default_data = 200 )","title":"Input Data Nodes configuration"},{"location":"getting_started/step_03/ReadMe/#remaining-data-nodes","text":"cleaned_dataset is the dataset after cleaning (after the clean_data() function). cacheable is set to True with a scope.GLOBAL . It means if the initial dataset didn't change, Taipy will not re-execute the clean_data() task. In other words, after the creation of this data node through clean_data() , Taipy knows that it is not necessary to create it again. predictions are the predictions of the model. In this pipeline, it will be the output of the predict_baseline() function. Each pipeline will create its own prediction Data Node hence scope=Scope.PIPELINE . ## Remaining Data Nodes cleaned_dataset_cfg = Config . configure_data_node ( id = \"cleaned_dataset\" , cacheable = True , validity_period = dt . timedelta ( days = 1 ), scope = Scope . GLOBAL ) predictions_cfg = Config . configure_data_node ( id = \"predictions\" , scope = Scope . PIPELINE )","title":"Remaining Data Nodes"},{"location":"getting_started/step_03/ReadMe/#functions","text":"Here\u2019s the code of each of the two Python functions: clean_data() and predict_baseline() . Their goal is respectively to clean the data and to predict the data. def clean_data ( initial_dataset : pd . DataFrame ): print ( \" Cleaning data\" ) # Convert the date column to datetime initial_dataset [ \"Date\" ] = pd . to_datetime ( initial_dataset [ \"Date\" ]) cleaned_dataset = initial_dataset . copy () return cleaned_dataset def predict_baseline ( cleaned_dataset : pd . DataFrame , n_predictions : int , day : dt . datetime , max_capacity : int ): print ( \" Predicting baseline\" ) # Select the train data train_dataset = cleaned_dataset [ cleaned_dataset [ \"Date\" ] < day ] predictions = train_dataset [ \"Value\" ][ - n_predictions :] . reset_index ( drop = True ) predictions = predictions . apply ( lambda x : min ( x , max_capacity )) return predictions","title":"Functions"},{"location":"getting_started/step_03/ReadMe/#tasks","text":"Tasks are the translation of functions in Taipy. These tasks combined with Data Nodes create your graph (DAG). Creating a task is simple; you need: An id A function Inputs Outputs","title":"Tasks"},{"location":"getting_started/step_03/ReadMe/#clean_data_task","text":"The first task that you want to create is your clean_data() task. It will take your initial dataset (input Data Node), clean it (calling the clean_data() function) and generate the cleaned dataset Data Node. clean_data_task_cfg = Config . configure_task ( id = \"clean_data\" , function = clean_data , input = initial_dataset_cfg , output = cleaned_dataset_cfg )","title":"clean_data_task"},{"location":"getting_started/step_03/ReadMe/#predict_baseline_task","text":"This task will take the cleaned dataset and predict it according to your parameters i.e. the three input Data Nodes: Day , Number of predictions and Max Capacity . predict_baseline_task_cfg = Config . configure_task ( id = \"predict_baseline\" , function = predict_baseline , input = [ cleaned_dataset_cfg , n_predictions_cfg , day_cfg , max_capacity_cfg ], output = predictions_cfg )","title":"predict_baseline_task"},{"location":"getting_started/step_04/ReadMe/","text":"You can download the code of this step here or all the steps here . For Notebooks The \"Getting Started\" Notebook is available here . The code of the steps doesn't deal with the specific GUI functions for Notebooks. Step 4: Pipeline Management \u00b6 In Step 3, you have described your graph; let's implement it with Taipy! Pipeline configuration \u00b6 To configure your first pipeline, you need to list all the tasks you want to be done by the pipeline. This pipeline executes the cleaning ( clean_data_task ) and the predicting ( predict_baseline_task ). Note that the task_configs is a list, so you don't have to worry about the order of the tasks. Taipy does that for you and optimizes its execution. # Create the the first scenario configuration baseline_pipeline_cfg = Config . configure_pipeline ( id = \"baseline\" , task_configs = [ clean_data_task_cfg , predict_baseline_task_cfg ]) Pipeline creation and execution \u00b6 Then, create your pipeline from its configuration, submit it, and print the \"predictions\" Data Node results. import taipy as tp # Create the pipeline baseline_pipeline = tp . create_pipeline ( baseline_pipeline_cfg ) # Submit the pipeline (Execution) tp . submit ( baseline_pipeline ) # Read output data from the pipeline baseline_predictions = baseline_pipeline . predictions . read () print ( \"Predictions of baseline algorithm \\n \" , baseline_predictions ) Note that when creating the pipeline ( tp.create_pipeline() ), all associated Taipy objects of the pipeline (Data nodes, Tasks, etc) get automatically created (unless already present).","title":"Step 4: Pipeline Management"},{"location":"getting_started/step_04/ReadMe/#step-4-pipeline-management","text":"In Step 3, you have described your graph; let's implement it with Taipy!","title":"Step 4: Pipeline Management"},{"location":"getting_started/step_04/ReadMe/#pipeline-configuration","text":"To configure your first pipeline, you need to list all the tasks you want to be done by the pipeline. This pipeline executes the cleaning ( clean_data_task ) and the predicting ( predict_baseline_task ). Note that the task_configs is a list, so you don't have to worry about the order of the tasks. Taipy does that for you and optimizes its execution. # Create the the first scenario configuration baseline_pipeline_cfg = Config . configure_pipeline ( id = \"baseline\" , task_configs = [ clean_data_task_cfg , predict_baseline_task_cfg ])","title":"Pipeline configuration"},{"location":"getting_started/step_04/ReadMe/#pipeline-creation-and-execution","text":"Then, create your pipeline from its configuration, submit it, and print the \"predictions\" Data Node results. import taipy as tp # Create the pipeline baseline_pipeline = tp . create_pipeline ( baseline_pipeline_cfg ) # Submit the pipeline (Execution) tp . submit ( baseline_pipeline ) # Read output data from the pipeline baseline_predictions = baseline_pipeline . predictions . read () print ( \"Predictions of baseline algorithm \\n \" , baseline_predictions ) Note that when creating the pipeline ( tp.create_pipeline() ), all associated Taipy objects of the pipeline (Data nodes, Tasks, etc) get automatically created (unless already present).","title":"Pipeline creation and execution"},{"location":"getting_started/step_05/ReadMe/","text":"You can download the code of this step here or all the steps here . For Notebooks The \"Getting Started\" Notebook is available here . The code of the steps doesn't deal with the specific GUI functions for Notebooks. Step 5: GUI and Pipeline \u00b6 In Step 4, we created a first pipeline using only Taipy Core. Let's update the GUI to reflect the results of the pipeline. A \"Predict\" button is added to the page to create the pipeline and run it. When you press a button, Taipy calls the function passed to the on_action property. <|Text displayed on button|button|on_action=fct_name_called_when_pressed|> A chart control can be found at the end of the markdown to visualize the predictions. The chart plots two traces: the historical values and the predicted values. import numpy as np import pandas as pd # Initialize the \"predictions\" dataset predictions_dataset = pd . DataFrame ({ \"Date\" :[ dt . datetime ( 2021 , 6 , 1 )], \"Historical values\" :[ np . NaN ], \"Predicted values\" :[ np . NaN ]}) # Add a button and a chart for our predictions pipeline_page = page + \"\"\" Press <|predict|button|on_action=predict|> to predict with default parameters (30 predictions) and June 1st as day. <| {predictions_dataset} |chart|x=Date|y[1]=Historical values|type[1]=bar|y[2]=Predicted values|type[2]=scatter|height=80%|width=100%|> \"\"\" create_and_submit_pipeline() creates and executes the pipeline after being called by predict() . def predict ( state ): print ( \"'Predict' button clicked\" ) pipeline = create_and_submit_pipeline () update_predictions_dataset ( state , pipeline ) def create_and_submit_pipeline (): print ( \"Execution of pipeline...\" ) # Create the pipeline from the pipeline config pipeline = tp . create_pipeline ( baseline_pipeline_cfg ) # Submit the pipeline (Execution) tp . submit ( pipeline ) return pipeline After the execution of the pipeline ( tp.submit() ), the data stored in predictions and cleaned_data Data Nodes become accessible. The read() method accesses the data in Data Nodes. The create_predictions_dataset() function below creates a final dataframe (that concatenates the predictions and the historical data together) containing three columns: Date, Historical values, Predicted values. def create_predictions_dataset ( pipeline ): print ( \"Creating predictions dataset...\" ) # Read data from the pipeline predictions = pipeline . predictions . read () day = pipeline . day . read () n_predictions = pipeline . n_predictions . read () cleaned_data = pipeline . cleaned_dataset . read () # Set arbitrarily the time window for the chart as 5 times the number of predictions window = 5 * n_predictions # Create the historical dataset that will be displayed new_length = len ( cleaned_data [ cleaned_data [ \"Date\" ] < day ]) + n_predictions temp_df = cleaned_data [: new_length ] temp_df = temp_df [ - window :] . reset_index ( drop = True ) # Create the series that will be used in the concat historical_values = pd . Series ( temp_df [ \"Value\" ], name = \"Historical values\" ) predicted_values = pd . Series ([ np . NaN ] * len ( temp_df ), name = \"Predicted values\" ) # change ? Fred predicted_values [ - len ( predictions ):] = predictions # Create the predictions dataset # Columns : [Date, Historical values, Predicted values] return pd . concat ([ temp_df [ \"Date\" ], historical_values , predicted_values ], axis = 1 ) It is now really simple to get the predictions dataset and display it in the \"Prediction chart\" created above. When you press the \"Predict\" button, this function below is called. It will update the predictions' dataset, and this change will propagate to the chart. def update_predictions_dataset ( state , pipeline ): print ( \"Updating predictions dataset...\" ) state . predictions_dataset = create_predictions_dataset ( pipeline ) This is what the structure of the code looks like for the GUI: Gui ( page = pipeline_page ) . run ( dark_mode = False ) Important Remark : A better option would have been to have the create_predictions_dataset() modeled as a last Task inside the pipeline graph.","title":"Step 5: GUI and Pipeline"},{"location":"getting_started/step_05/ReadMe/#step-5-gui-and-pipeline","text":"In Step 4, we created a first pipeline using only Taipy Core. Let's update the GUI to reflect the results of the pipeline. A \"Predict\" button is added to the page to create the pipeline and run it. When you press a button, Taipy calls the function passed to the on_action property. <|Text displayed on button|button|on_action=fct_name_called_when_pressed|> A chart control can be found at the end of the markdown to visualize the predictions. The chart plots two traces: the historical values and the predicted values. import numpy as np import pandas as pd # Initialize the \"predictions\" dataset predictions_dataset = pd . DataFrame ({ \"Date\" :[ dt . datetime ( 2021 , 6 , 1 )], \"Historical values\" :[ np . NaN ], \"Predicted values\" :[ np . NaN ]}) # Add a button and a chart for our predictions pipeline_page = page + \"\"\" Press <|predict|button|on_action=predict|> to predict with default parameters (30 predictions) and June 1st as day. <| {predictions_dataset} |chart|x=Date|y[1]=Historical values|type[1]=bar|y[2]=Predicted values|type[2]=scatter|height=80%|width=100%|> \"\"\" create_and_submit_pipeline() creates and executes the pipeline after being called by predict() . def predict ( state ): print ( \"'Predict' button clicked\" ) pipeline = create_and_submit_pipeline () update_predictions_dataset ( state , pipeline ) def create_and_submit_pipeline (): print ( \"Execution of pipeline...\" ) # Create the pipeline from the pipeline config pipeline = tp . create_pipeline ( baseline_pipeline_cfg ) # Submit the pipeline (Execution) tp . submit ( pipeline ) return pipeline After the execution of the pipeline ( tp.submit() ), the data stored in predictions and cleaned_data Data Nodes become accessible. The read() method accesses the data in Data Nodes. The create_predictions_dataset() function below creates a final dataframe (that concatenates the predictions and the historical data together) containing three columns: Date, Historical values, Predicted values. def create_predictions_dataset ( pipeline ): print ( \"Creating predictions dataset...\" ) # Read data from the pipeline predictions = pipeline . predictions . read () day = pipeline . day . read () n_predictions = pipeline . n_predictions . read () cleaned_data = pipeline . cleaned_dataset . read () # Set arbitrarily the time window for the chart as 5 times the number of predictions window = 5 * n_predictions # Create the historical dataset that will be displayed new_length = len ( cleaned_data [ cleaned_data [ \"Date\" ] < day ]) + n_predictions temp_df = cleaned_data [: new_length ] temp_df = temp_df [ - window :] . reset_index ( drop = True ) # Create the series that will be used in the concat historical_values = pd . Series ( temp_df [ \"Value\" ], name = \"Historical values\" ) predicted_values = pd . Series ([ np . NaN ] * len ( temp_df ), name = \"Predicted values\" ) # change ? Fred predicted_values [ - len ( predictions ):] = predictions # Create the predictions dataset # Columns : [Date, Historical values, Predicted values] return pd . concat ([ temp_df [ \"Date\" ], historical_values , predicted_values ], axis = 1 ) It is now really simple to get the predictions dataset and display it in the \"Prediction chart\" created above. When you press the \"Predict\" button, this function below is called. It will update the predictions' dataset, and this change will propagate to the chart. def update_predictions_dataset ( state , pipeline ): print ( \"Updating predictions dataset...\" ) state . predictions_dataset = create_predictions_dataset ( pipeline ) This is what the structure of the code looks like for the GUI: Gui ( page = pipeline_page ) . run ( dark_mode = False ) Important Remark : A better option would have been to have the create_predictions_dataset() modeled as a last Task inside the pipeline graph.","title":"Step 5: GUI and Pipeline"},{"location":"getting_started/step_06/ReadMe/","text":"You can download the code of this step here or all the steps here . For Notebooks The \"Getting Started\" Notebook is available here . The code of the steps doesn't deal with the specific GUI functions for Notebooks. Step 6: Creation of Scenarios \u00b6 Now that you have seen how to create and run a single pipeline, let's configure a scenario. Remember, scenarios are required whenever the end-user wants to run variations of the pipelines and perform what-if analysis to simulate different business situations . Each scenario would represent a different solution to your problem. Here, max_capacity , day and number of predictions can influence the scenario. In this example, we will run two pipelines: our initial pipeline ( baseline ) together with a new one (referred as \" ml \") that will implement a different prediction function/model. # For the sake of clarity, we have used an AutoRegressive model rather than a pure ML model such as: # Random Forest, Linear Regression, LSTM, etc from statsmodels.tsa.ar_model import AutoReg # This is the function that will be used by the task def predict_ml ( cleaned_dataset : pd . DataFrame , n_predictions : int , day : dt . datetime , max_capacity : int ): print ( \" Predicting with ML\" ) # Select the train data train_dataset = cleaned_dataset [ cleaned_dataset [ \"Date\" ] < day ] # Fit the AutoRegressive model model = AutoReg ( train_dataset [ \"Value\" ], lags = 7 ) . fit () # Get the n_predictions forecasts predictions = model . forecast ( n_predictions ) . reset_index ( drop = True ) predictions = predictions . apply ( lambda x : min ( x , max_capacity )) return predictions A predict_ml Task config will need to be created and associated with the newly created predict_ml() function. The predict_ml Task configuration is created using the same format as before with a function, inputs, and outputs. # Create the task configuration of the predict_ml function. ## We use the same input and ouput as the previous predict_baseline task but we change the funtion predict_ml_task_cfg = Config . configure_task ( id = \"predict_ml\" , function = predict_ml , input = [ cleaned_dataset_cfg , n_predictions_cfg , day_cfg , max_capacity_cfg ], output = predictions_cfg ) With this new task, the Machine Learning pipeline can finally be configured. # Create the new ml pipeline that will clean and predict with the ml model ml_pipeline_cfg = Config . configure_pipeline ( id = \"ml\" , task_configs = [ clean_data_task_cfg , predict_ml_task_cfg ]) To configure a scenario, you need to use tp.configure_scenario and the list of the related pipelines. You can easily add more pipelines/algorithms if you wished to. # Configure our scenario which is our business problem. scenario_cfg = Config . configure_scenario ( id = \"scenario\" , pipeline_configs = [ baseline_pipeline_cfg , ml_pipeline_cfg ]) The configuration is now complete. Now, you can create your scenario and execute it. When creating it, Taipy will create your pipelines (and its associated Tasks), and when you submit the scenario, it will run them based on Taipy\u2019s built-in intelligent scheduling. Taipy knows in which sequence the Tasks need to be performed. # Create the scenario scenario = tp . create_scenario ( scenario_cfg ) # Execute it tp . submit ( scenario ) # Get the resulting scenario ## Print the predictions of the two pipelines (baseline and ml) print ( \" \\n Baseline predictions \\n \" , scenario . baseline . predictions . read ()) print ( \" \\n Machine Learning predictions \\n \" , scenario . ml . predictions . read ())","title":"Step 6: Creation of Scenarios"},{"location":"getting_started/step_06/ReadMe/#step-6-creation-of-scenarios","text":"Now that you have seen how to create and run a single pipeline, let's configure a scenario. Remember, scenarios are required whenever the end-user wants to run variations of the pipelines and perform what-if analysis to simulate different business situations . Each scenario would represent a different solution to your problem. Here, max_capacity , day and number of predictions can influence the scenario. In this example, we will run two pipelines: our initial pipeline ( baseline ) together with a new one (referred as \" ml \") that will implement a different prediction function/model. # For the sake of clarity, we have used an AutoRegressive model rather than a pure ML model such as: # Random Forest, Linear Regression, LSTM, etc from statsmodels.tsa.ar_model import AutoReg # This is the function that will be used by the task def predict_ml ( cleaned_dataset : pd . DataFrame , n_predictions : int , day : dt . datetime , max_capacity : int ): print ( \" Predicting with ML\" ) # Select the train data train_dataset = cleaned_dataset [ cleaned_dataset [ \"Date\" ] < day ] # Fit the AutoRegressive model model = AutoReg ( train_dataset [ \"Value\" ], lags = 7 ) . fit () # Get the n_predictions forecasts predictions = model . forecast ( n_predictions ) . reset_index ( drop = True ) predictions = predictions . apply ( lambda x : min ( x , max_capacity )) return predictions A predict_ml Task config will need to be created and associated with the newly created predict_ml() function. The predict_ml Task configuration is created using the same format as before with a function, inputs, and outputs. # Create the task configuration of the predict_ml function. ## We use the same input and ouput as the previous predict_baseline task but we change the funtion predict_ml_task_cfg = Config . configure_task ( id = \"predict_ml\" , function = predict_ml , input = [ cleaned_dataset_cfg , n_predictions_cfg , day_cfg , max_capacity_cfg ], output = predictions_cfg ) With this new task, the Machine Learning pipeline can finally be configured. # Create the new ml pipeline that will clean and predict with the ml model ml_pipeline_cfg = Config . configure_pipeline ( id = \"ml\" , task_configs = [ clean_data_task_cfg , predict_ml_task_cfg ]) To configure a scenario, you need to use tp.configure_scenario and the list of the related pipelines. You can easily add more pipelines/algorithms if you wished to. # Configure our scenario which is our business problem. scenario_cfg = Config . configure_scenario ( id = \"scenario\" , pipeline_configs = [ baseline_pipeline_cfg , ml_pipeline_cfg ]) The configuration is now complete. Now, you can create your scenario and execute it. When creating it, Taipy will create your pipelines (and its associated Tasks), and when you submit the scenario, it will run them based on Taipy\u2019s built-in intelligent scheduling. Taipy knows in which sequence the Tasks need to be performed. # Create the scenario scenario = tp . create_scenario ( scenario_cfg ) # Execute it tp . submit ( scenario ) # Get the resulting scenario ## Print the predictions of the two pipelines (baseline and ml) print ( \" \\n Baseline predictions \\n \" , scenario . baseline . predictions . read ()) print ( \" \\n Machine Learning predictions \\n \" , scenario . ml . predictions . read ())","title":"Step 6: Creation of Scenarios"},{"location":"getting_started/step_07/ReadMe/","text":"You can download the code of this step here or all the steps here . For Notebooks The \"Getting Started\" Notebook is available here . The code of the steps doesn't deal with the specific GUI functions for Notebooks. Step 7: GUI and Scenario \u00b6 In Step 6, using Taipy Core, we implemented a scenario configuration and created our first scenario (based on that config) . In this step, we will implement a graphical interface that makes use of scenarios. First, a scenario will be created and executed at the beginning. Then, a Taipy GUI selector will be used to select one of the two pipelines associated with the scenario: the baseline or the ml pipeline. A selector only needs two properties: a value that gets dynamically updated through the selector and the list of values possible (aka \"lov\"). Here is the syntax for a selector: <|{selected_value}|selector|lov={lov_selector}|> . An \"Update chart\" button will update the chart according to the selected pipeline. These variables below are the parameters of the pipeline selector. The selected pipeline will be the first among \"baseline\" and \"ml\" when starting the client. # Set the list of pipelines names # It will be used in a selector of pipelines pipeline_selector = [ \"baseline\" , \"ml\" ] selected_pipeline = pipeline_selector [ 0 ] This pipeline selector is added in the Markdown file just before the chart as well as the \"Update chart\" button. scenario_page = page + \"\"\" Select the pipeline <| {selected_pipeline} |selector|lov= {pipeline_selector} |> <|Update chart|button|on_action=update_chart|> <| {predictions_dataset} |chart|x=Date|y[1]=Historical values|type[1]=bar|y[2]=Predicted values|type[2]=scatter|height=80%|width=100%|> \"\"\" The code around the GUI has evolved. create_scenario() is creating a scenario and submitting it with the submit_scenario() function. update_chart() is updating the chart based upon the selected scenario and pipeline. def create_scenario (): print ( \"Creating scenario...\" ) scenario = tp . create_scenario ( scenario_cfg ) scenario = submit_scenario ( scenario ) return scenario def submit_scenario ( scenario ): print ( \"Submitting scenario...\" ) tp . submit ( scenario ) return scenario def update_chart ( state ): print ( \"'Update chart' button clicked\" ) # Select the right pipeline pipeline = scenario . pipelines [ state . selected_pipeline ] # Update the chart based on this pipeline # It is the same function as created before in step_5 update_predictions_dataset ( state , pipeline ) Before running the GUI, these two lines of code will erase the previous scenarios, pipelines, data nodes that you created in the previous steps to avoid any problem of compatibility. # Delete all entities Config . configure_global_app ( clean_entities_enabled = True ) tp . clean_all_entities () # Creation of our first scenario scenario = create_scenario () Gui ( page = scenario_page ) . run ( dark_mode = False )","title":"Step 7: GUI and Scenario"},{"location":"getting_started/step_07/ReadMe/#step-7-gui-and-scenario","text":"In Step 6, using Taipy Core, we implemented a scenario configuration and created our first scenario (based on that config) . In this step, we will implement a graphical interface that makes use of scenarios. First, a scenario will be created and executed at the beginning. Then, a Taipy GUI selector will be used to select one of the two pipelines associated with the scenario: the baseline or the ml pipeline. A selector only needs two properties: a value that gets dynamically updated through the selector and the list of values possible (aka \"lov\"). Here is the syntax for a selector: <|{selected_value}|selector|lov={lov_selector}|> . An \"Update chart\" button will update the chart according to the selected pipeline. These variables below are the parameters of the pipeline selector. The selected pipeline will be the first among \"baseline\" and \"ml\" when starting the client. # Set the list of pipelines names # It will be used in a selector of pipelines pipeline_selector = [ \"baseline\" , \"ml\" ] selected_pipeline = pipeline_selector [ 0 ] This pipeline selector is added in the Markdown file just before the chart as well as the \"Update chart\" button. scenario_page = page + \"\"\" Select the pipeline <| {selected_pipeline} |selector|lov= {pipeline_selector} |> <|Update chart|button|on_action=update_chart|> <| {predictions_dataset} |chart|x=Date|y[1]=Historical values|type[1]=bar|y[2]=Predicted values|type[2]=scatter|height=80%|width=100%|> \"\"\" The code around the GUI has evolved. create_scenario() is creating a scenario and submitting it with the submit_scenario() function. update_chart() is updating the chart based upon the selected scenario and pipeline. def create_scenario (): print ( \"Creating scenario...\" ) scenario = tp . create_scenario ( scenario_cfg ) scenario = submit_scenario ( scenario ) return scenario def submit_scenario ( scenario ): print ( \"Submitting scenario...\" ) tp . submit ( scenario ) return scenario def update_chart ( state ): print ( \"'Update chart' button clicked\" ) # Select the right pipeline pipeline = scenario . pipelines [ state . selected_pipeline ] # Update the chart based on this pipeline # It is the same function as created before in step_5 update_predictions_dataset ( state , pipeline ) Before running the GUI, these two lines of code will erase the previous scenarios, pipelines, data nodes that you created in the previous steps to avoid any problem of compatibility. # Delete all entities Config . configure_global_app ( clean_entities_enabled = True ) tp . clean_all_entities () # Creation of our first scenario scenario = create_scenario () Gui ( page = scenario_page ) . run ( dark_mode = False )","title":"Step 7: GUI and Scenario"},{"location":"getting_started/step_08/ReadMe/","text":"You can download the code of this step here or all the steps here . For Notebooks The \"Getting Started\" Notebook is available here . The code of the steps doesn't deal with the specific GUI functions for Notebooks. Step 8: Modify Data Nodes content \u00b6 Now that the GUI has been created to handle one scenario, it would be interesting to change the \"initial\" variables to see their impact on the predictions. These variables are: the number of predictions , the max capacity and the day . How can we interact with them in real-time? It can easily be done using the write() function of Data Nodes. First, to link these variables to a visual element, they have to be initialized. # Initial variables ## Initial variables for the scenario day = dt . datetime ( 2021 , 7 , 26 ) n_predictions = 40 max_capacity = 200 Second, we will add to the Markdown (before the chart), a visual element binding each of these variables. We will be using them to \"modify\" the scenario. See the documentation for these newly introduced visual elements here: date and number . A \"Save button\" is also created to run the \"submit_scenario()\" function when pressed. page_scenario_manager = page + \"\"\" # Change your scenario **Prediction date** \\n\\n <| {day} |date|not with_time|> **Max capacity** \\n\\n <| {max_capacity} |number|> **Number of predictions** \\n\\n <| {n_predictions} |number|> <|Save changes|button|on_action= {submit_scenario} |> Select the pipeline <| {selected_pipeline} |selector|lov= {pipeline_selector} |> <|Update chart|button|on_action= {update_chart} |> <| {predictions_dataset} |chart|x=Date|y[1]=Historical values|type[1]=bar|y[2]=Predicted values|type[2]=scatter|height=80%|width=100%|> \"\"\" create_scenario() function is almost the same as before except for the need to track the scenario_id of the newly created scenario (using the Global variable selected_scenario ). def create_scenario (): global selected_scenario print ( \"Creating scenario...\" ) scenario = tp . create_scenario ( scenario_cfg ) selected_scenario = scenario . id tp . submit ( scenario ) The submit_scenario() function introduces two essential Taipy functions: tp.get(scenario_id) : Taipy function used to get the scenario from its id. write(new_value) : a Data Node function that changes the value stored in the Data Node. For example, scenario.max_capacity is a Data Node whose value can be changed to 100 like this scenario.max_capacity.write(100) . def submit_scenario ( state ): print ( \"Submitting scenario...\" ) # Get the selected scenario: in this current step a single scenario is created then modified here. scenario = tp . get ( selected_scenario ) # Conversion to the right format state_day = dt . datetime ( state . day . year , state . day . month , state . day . day ) # Change the default parameters by writing in the datanodes scenario . day . write ( state_day ) scenario . n_predictions . write ( int ( state . n_predictions )) scenario . max_capacity . write ( int ( state . max_capacity )) # Execute the pipelines/code tp . submit ( scenario ) # Update the chart when we change the scenario update_chart ( state ) update_chart() uses a previous function ( update_predictions_dataset() ) to update the predictions_dataset with the correct pipeline. def update_chart ( state ): # Select the right scenario and pipeline scenario = tp . get ( selected_scenario ) pipeline = scenario . pipelines [ state . selected_pipeline ] # Update the chart based on this pipeline update_predictions_dataset ( state , pipeline ) global selected_scenario # Creation of a single scenario create_scenario () Gui ( page = page_scenario_manager ) . run ( dark_mode = False )","title":"Step 8: Modify Data Nodes content"},{"location":"getting_started/step_08/ReadMe/#step-8-modify-data-nodes-content","text":"Now that the GUI has been created to handle one scenario, it would be interesting to change the \"initial\" variables to see their impact on the predictions. These variables are: the number of predictions , the max capacity and the day . How can we interact with them in real-time? It can easily be done using the write() function of Data Nodes. First, to link these variables to a visual element, they have to be initialized. # Initial variables ## Initial variables for the scenario day = dt . datetime ( 2021 , 7 , 26 ) n_predictions = 40 max_capacity = 200 Second, we will add to the Markdown (before the chart), a visual element binding each of these variables. We will be using them to \"modify\" the scenario. See the documentation for these newly introduced visual elements here: date and number . A \"Save button\" is also created to run the \"submit_scenario()\" function when pressed. page_scenario_manager = page + \"\"\" # Change your scenario **Prediction date** \\n\\n <| {day} |date|not with_time|> **Max capacity** \\n\\n <| {max_capacity} |number|> **Number of predictions** \\n\\n <| {n_predictions} |number|> <|Save changes|button|on_action= {submit_scenario} |> Select the pipeline <| {selected_pipeline} |selector|lov= {pipeline_selector} |> <|Update chart|button|on_action= {update_chart} |> <| {predictions_dataset} |chart|x=Date|y[1]=Historical values|type[1]=bar|y[2]=Predicted values|type[2]=scatter|height=80%|width=100%|> \"\"\" create_scenario() function is almost the same as before except for the need to track the scenario_id of the newly created scenario (using the Global variable selected_scenario ). def create_scenario (): global selected_scenario print ( \"Creating scenario...\" ) scenario = tp . create_scenario ( scenario_cfg ) selected_scenario = scenario . id tp . submit ( scenario ) The submit_scenario() function introduces two essential Taipy functions: tp.get(scenario_id) : Taipy function used to get the scenario from its id. write(new_value) : a Data Node function that changes the value stored in the Data Node. For example, scenario.max_capacity is a Data Node whose value can be changed to 100 like this scenario.max_capacity.write(100) . def submit_scenario ( state ): print ( \"Submitting scenario...\" ) # Get the selected scenario: in this current step a single scenario is created then modified here. scenario = tp . get ( selected_scenario ) # Conversion to the right format state_day = dt . datetime ( state . day . year , state . day . month , state . day . day ) # Change the default parameters by writing in the datanodes scenario . day . write ( state_day ) scenario . n_predictions . write ( int ( state . n_predictions )) scenario . max_capacity . write ( int ( state . max_capacity )) # Execute the pipelines/code tp . submit ( scenario ) # Update the chart when we change the scenario update_chart ( state ) update_chart() uses a previous function ( update_predictions_dataset() ) to update the predictions_dataset with the correct pipeline. def update_chart ( state ): # Select the right scenario and pipeline scenario = tp . get ( selected_scenario ) pipeline = scenario . pipelines [ state . selected_pipeline ] # Update the chart based on this pipeline update_predictions_dataset ( state , pipeline ) global selected_scenario # Creation of a single scenario create_scenario () Gui ( page = page_scenario_manager ) . run ( dark_mode = False )","title":"Step 8: Modify Data Nodes content"},{"location":"getting_started/step_09/ReadMe/","text":"You can download the code of this step here or all the steps here . For Notebooks The \"Getting Started\" Notebook is available here . The code of the steps doesn't deal with the specific GUI functions for Notebooks. Step 9: Manage Scenarios \u00b6 Now that you know how to create a scenario, submit it and change it, you will create in this step a Taipy program able to manage multiple scenarios (and pipelines). Dynamic selectors \u00b6 Let's manage multiple scenarios through a dynamic scenario selector. This selector will be updated whenever a new scenario is created. It will store the \"id\" of the scenarios and their names. For clarity, only their names do get displayed (in the selector). This code initializes the scenario selector with previously created scenarios. If there are no scenarios yet, the scenario selector will be empty. # Get all the scenarios already created all_scenarios = tp . get_scenarios () # Delete the scenarios that don't have a name attribute # All the scenarios of the previous steps do not have an associated name so they will be deleted, # this will not be the case for those created by this step [ tp . delete ( scenario . id ) for scenario in all_scenarios if scenario . name is None ] # Initial variable for the scenario selector # The list of possible values (lov) for the scenario selector is a list of tuples (scenario_id, scenario_name), # but the selected_scenario is just used to retrieve the scenario id and what gets displayed is the name of the scenario. scenario_selector = [( scenario . id , scenario . name ) for scenario in tp . get_scenarios ()] selected_scenario = None Beside adding to the Markdown the new scenario selector, we also add a new \"Create new scenario\" button. This button calls the create_scenario() function. So, now each time we modify the parameters ( day , max_capacity , n_prediction ) we will create a new scenario upon clicking on this \"Create new scenario\" button. scenario_manager_page = page + \"\"\" # Create your scenario **Prediction date** \\n\\n <| {day} |date|not with_time|> **Max capacity** \\n\\n <| {max_capacity} |number|> **Number of predictions** \\n\\n <| {n_predictions} |number|> <|Create new scenario|button|on_action=create_scenario|> ## Scenario <| {selected_scenario} |selector|lov= {scenario_selector} |dropdown|> ## Display the pipeline <| {selected_pipeline} |selector|lov= {pipeline_selector} |> <| {predictions_dataset} |chart|x=Date|y[1]=Historical values|type[1]=bar|y[2]=Predicted values|type[2]=scatter|height=80%|width=100%|> \"\"\" Here is the main code for managing scenarios. As you can see, the architecture doesn't change from the previous code. Two functions have been altered: _create_scenario() and submit_scenario() . def create_name_for_scenario ( state ) -> str : name = f \"Scenario ( { state . day . strftime ( '%A, %d %b' ) } ; { state . max_capacity } ; { state . n_predictions } )\" # Change the name if it is the same as some scenarios if name in [ s [ 1 ] for s in state . scenario_selector ]: name += f \" ( { len ( state . scenario_selector ) } )\" return name def update_chart ( state ): # Now, the selected_scenario comes from the state, it is interactive scenario = tp . get ( state . selected_scenario [ 0 ]) pipeline = scenario . pipelines [ state . selected_pipeline ] update_predictions_dataset ( state , pipeline ) # Change the create_scenario function in order to change the default parameters # and allow the creation of multiple scenarios def create_scenario ( state ): print ( \"Execution of scenario...\" ) # Extra information for the scenario creation_date = state . day name = create_name_for_scenario ( state ) # Create a scenario scenario = tp . create_scenario ( scenario_cfg , creation_date = creation_date , name = name ) state . selected_scenario = ( scenario . id , name ) # Submit the scenario that is currently selected submit_scenario ( state ) def submit_scenario ( state ): print ( \"Submitting scenario...\" ) # Get the currently selected scenario scenario = tp . get ( state . selected_scenario [ 0 ]) # Conversion to the right format (change?) day = dt . datetime ( state . day . year , state . day . month , state . day . day ) # Change the default parameters by writing in the Data Nodes scenario . day . write ( day ) scenario . n_predictions . write ( int ( state . n_predictions )) scenario . max_capacity . write ( int ( state . max_capacity )) scenario . creation_date = state . day # Execute the scenario tp . submit ( scenario ) # Update the scenario selector and the scenario that is currently selected update_scenario_selector ( state , scenario ) # change list to scenario # Update the chart directly update_chart ( state ) The function below will update the scenario selector whenever the user creates a new scenario. It is called in the submit_scenario function. def update_scenario_selector ( state , scenario ): print ( \"Updating scenario selector...\" ) # Update the scenario selector state . scenario_selector += [( scenario . id , scenario . name )] This graph summarizes the code for the GUI. Automating the graph update - on_change function \u00b6 The on_change function can automatically change the graph when another pipeline or scenario is selected. def on_change ( state , var_name : str , var_value ): if var_name == \"n_week\" : # Update the dataset when the slider is moved state . dataset_week = dataset [ dataset [ \"Date\" ] . dt . isocalendar () . week == var_value ] elif var_name == \"selected_pipeline\" or var_name == \"selected_scenario\" : # Update the chart when the scenario or the pipeline is changed # Check if we can read the Data Node to update the chart if tp . get ( state . selected_scenario [ 0 ]) . predictions . read () is not None : update_chart ( state ) Run the Gui. Gui ( page = scenario_manager_page ) . run ( dark_mode = False )","title":"Step 9: Manage Scenarios"},{"location":"getting_started/step_09/ReadMe/#step-9-manage-scenarios","text":"Now that you know how to create a scenario, submit it and change it, you will create in this step a Taipy program able to manage multiple scenarios (and pipelines).","title":"Step 9: Manage Scenarios"},{"location":"getting_started/step_09/ReadMe/#dynamic-selectors","text":"Let's manage multiple scenarios through a dynamic scenario selector. This selector will be updated whenever a new scenario is created. It will store the \"id\" of the scenarios and their names. For clarity, only their names do get displayed (in the selector). This code initializes the scenario selector with previously created scenarios. If there are no scenarios yet, the scenario selector will be empty. # Get all the scenarios already created all_scenarios = tp . get_scenarios () # Delete the scenarios that don't have a name attribute # All the scenarios of the previous steps do not have an associated name so they will be deleted, # this will not be the case for those created by this step [ tp . delete ( scenario . id ) for scenario in all_scenarios if scenario . name is None ] # Initial variable for the scenario selector # The list of possible values (lov) for the scenario selector is a list of tuples (scenario_id, scenario_name), # but the selected_scenario is just used to retrieve the scenario id and what gets displayed is the name of the scenario. scenario_selector = [( scenario . id , scenario . name ) for scenario in tp . get_scenarios ()] selected_scenario = None Beside adding to the Markdown the new scenario selector, we also add a new \"Create new scenario\" button. This button calls the create_scenario() function. So, now each time we modify the parameters ( day , max_capacity , n_prediction ) we will create a new scenario upon clicking on this \"Create new scenario\" button. scenario_manager_page = page + \"\"\" # Create your scenario **Prediction date** \\n\\n <| {day} |date|not with_time|> **Max capacity** \\n\\n <| {max_capacity} |number|> **Number of predictions** \\n\\n <| {n_predictions} |number|> <|Create new scenario|button|on_action=create_scenario|> ## Scenario <| {selected_scenario} |selector|lov= {scenario_selector} |dropdown|> ## Display the pipeline <| {selected_pipeline} |selector|lov= {pipeline_selector} |> <| {predictions_dataset} |chart|x=Date|y[1]=Historical values|type[1]=bar|y[2]=Predicted values|type[2]=scatter|height=80%|width=100%|> \"\"\" Here is the main code for managing scenarios. As you can see, the architecture doesn't change from the previous code. Two functions have been altered: _create_scenario() and submit_scenario() . def create_name_for_scenario ( state ) -> str : name = f \"Scenario ( { state . day . strftime ( '%A, %d %b' ) } ; { state . max_capacity } ; { state . n_predictions } )\" # Change the name if it is the same as some scenarios if name in [ s [ 1 ] for s in state . scenario_selector ]: name += f \" ( { len ( state . scenario_selector ) } )\" return name def update_chart ( state ): # Now, the selected_scenario comes from the state, it is interactive scenario = tp . get ( state . selected_scenario [ 0 ]) pipeline = scenario . pipelines [ state . selected_pipeline ] update_predictions_dataset ( state , pipeline ) # Change the create_scenario function in order to change the default parameters # and allow the creation of multiple scenarios def create_scenario ( state ): print ( \"Execution of scenario...\" ) # Extra information for the scenario creation_date = state . day name = create_name_for_scenario ( state ) # Create a scenario scenario = tp . create_scenario ( scenario_cfg , creation_date = creation_date , name = name ) state . selected_scenario = ( scenario . id , name ) # Submit the scenario that is currently selected submit_scenario ( state ) def submit_scenario ( state ): print ( \"Submitting scenario...\" ) # Get the currently selected scenario scenario = tp . get ( state . selected_scenario [ 0 ]) # Conversion to the right format (change?) day = dt . datetime ( state . day . year , state . day . month , state . day . day ) # Change the default parameters by writing in the Data Nodes scenario . day . write ( day ) scenario . n_predictions . write ( int ( state . n_predictions )) scenario . max_capacity . write ( int ( state . max_capacity )) scenario . creation_date = state . day # Execute the scenario tp . submit ( scenario ) # Update the scenario selector and the scenario that is currently selected update_scenario_selector ( state , scenario ) # change list to scenario # Update the chart directly update_chart ( state ) The function below will update the scenario selector whenever the user creates a new scenario. It is called in the submit_scenario function. def update_scenario_selector ( state , scenario ): print ( \"Updating scenario selector...\" ) # Update the scenario selector state . scenario_selector += [( scenario . id , scenario . name )] This graph summarizes the code for the GUI.","title":"Dynamic selectors"},{"location":"getting_started/step_09/ReadMe/#automating-the-graph-update---on_change-function","text":"The on_change function can automatically change the graph when another pipeline or scenario is selected. def on_change ( state , var_name : str , var_value ): if var_name == \"n_week\" : # Update the dataset when the slider is moved state . dataset_week = dataset [ dataset [ \"Date\" ] . dt . isocalendar () . week == var_value ] elif var_name == \"selected_pipeline\" or var_name == \"selected_scenario\" : # Update the chart when the scenario or the pipeline is changed # Check if we can read the Data Node to update the chart if tp . get ( state . selected_scenario [ 0 ]) . predictions . read () is not None : update_chart ( state ) Run the Gui. Gui ( page = scenario_manager_page ) . run ( dark_mode = False )","title":"Automating the graph update - on_change function"},{"location":"getting_started/step_10/ReadMe/","text":"You can download the code of this step here or all the steps here . For Notebooks The \"Getting Started\" Notebook is available here . The code of the steps doesn't deal with the specific GUI functions for Notebooks. Step 10: Embellish your App \u00b6 With just a few steps, you have created a full forecasting application which predicts across multiple days with different parameters. However, the page's layout is not yet optimal and it could be greatly improved. This will be done during this step. To get a more aesthetically pleasing page, three new useful controls will be used. These are: menu : creates a menu on the left to navigate through the pages. <|menu|label=Menu|lov={lov_pages}|on_action=on_menu|> . For example, this code creates a menu with two pages: from taipy import Gui def on_menu (): print ( 'Menu function called' ) Gui ( page = \"<|menu|label=Menu|lov={['Data Visualization', 'Scenario Manager']}|on_action=on_menu|>\" ) . run () part : creates a group of text/visual elements. A useful property of part is render . If set to False, it will not display the part. This allows the developer to dynamically display a group of visual elements or not. <|part|render={bool_variable}| Text Or visual elements... |> layout : creates invisible columns where you can put your texts and visual elements. The columns property indicates the width and number of columns. Here, we create three columns of the same width. <|layout|columns=1 1 1| Button in first column <|Press|button|> Second column Third column |> One strategy to switch from one page to another is: To create a specific Markdown string for each page; Use the Menu control to switch from one page to another by controlling the page variable. This is how you can easily create multiple pages; there are many other ways to do so. First, let\u2019s start by creating the 2 pages. The first page contains the original chart and slider defined in Step 2. Let\u2019s use the same Markdown as the one defined in Step 2. It is named page (and is also present in Step 9). # Our first page is the original page # (with the slider and the chart that displays a week of the historical data) page_data_visualization = page Then let\u2019s create our second page which contains the page corresponding to the creation of scenarios seen in Step 9. # Second page: create scenarios and display results page_scenario_manager = \"\"\" # Create your scenario <|layout|columns=1 1 1 1| <| **Prediction date** \\n\\n <| {day} |date|not with_time|> |> <| **Max capacity** \\n\\n <| {max_capacity} |number|> |> <| **Number of predictions** \\n\\n <| {n_predictions} |number|> |> <| <br/> \\n <|Create new scenario|button|on_action=create_scenario|> |> |> <|part|render={len(scenario_selector) > 0}| <|layout|columns=1 1| <| ## Scenario \\n <| {selected_scenario} |selector|lov= {scenario_selector} |dropdown|> |> <| ## Display the pipeline \\n <| {selected_pipeline} |selector|lov= {pipeline_selector} |dropdown|> |> |> <| {predictions_dataset} |chart|x=Date|y[1]=Historical values|type[1]=bar|y[2]=Predicted values|type[2]=scatter|height=80%|width=100%|> |> \"\"\" The menu combines these two pages. When a page is selected in the menu control, on_menu() is called and updates the page. # Create a menu with our pages multi_pages = \"\"\" <|menu|label=Menu|lov={[\"Data Visualization\", \"Scenario Manager\"]}|on_action=on_menu|> <|part|render={page==\"Data Visualization\"}|\"\"\" + page_data_visualization + \"\"\"|> <|part|render={page==\"Scenario Manager\"}|\"\"\" + page_scenario_manager + \"\"\"|> \"\"\" # The initial page is the \"Data Visualization\" page page = \"Data Visualization\" def on_menu ( state , var_name : str , fct : str , var_value : list ): # Change the value of the state.page variable in order to render the correct page state . page = var_value [ \"args\" ][ 0 ] Gui ( page = multi_pages ) . run ( dark_mode = False )","title":"Step 10: Embellish your App"},{"location":"getting_started/step_10/ReadMe/#step-10-embellish-your-app","text":"With just a few steps, you have created a full forecasting application which predicts across multiple days with different parameters. However, the page's layout is not yet optimal and it could be greatly improved. This will be done during this step. To get a more aesthetically pleasing page, three new useful controls will be used. These are: menu : creates a menu on the left to navigate through the pages. <|menu|label=Menu|lov={lov_pages}|on_action=on_menu|> . For example, this code creates a menu with two pages: from taipy import Gui def on_menu (): print ( 'Menu function called' ) Gui ( page = \"<|menu|label=Menu|lov={['Data Visualization', 'Scenario Manager']}|on_action=on_menu|>\" ) . run () part : creates a group of text/visual elements. A useful property of part is render . If set to False, it will not display the part. This allows the developer to dynamically display a group of visual elements or not. <|part|render={bool_variable}| Text Or visual elements... |> layout : creates invisible columns where you can put your texts and visual elements. The columns property indicates the width and number of columns. Here, we create three columns of the same width. <|layout|columns=1 1 1| Button in first column <|Press|button|> Second column Third column |> One strategy to switch from one page to another is: To create a specific Markdown string for each page; Use the Menu control to switch from one page to another by controlling the page variable. This is how you can easily create multiple pages; there are many other ways to do so. First, let\u2019s start by creating the 2 pages. The first page contains the original chart and slider defined in Step 2. Let\u2019s use the same Markdown as the one defined in Step 2. It is named page (and is also present in Step 9). # Our first page is the original page # (with the slider and the chart that displays a week of the historical data) page_data_visualization = page Then let\u2019s create our second page which contains the page corresponding to the creation of scenarios seen in Step 9. # Second page: create scenarios and display results page_scenario_manager = \"\"\" # Create your scenario <|layout|columns=1 1 1 1| <| **Prediction date** \\n\\n <| {day} |date|not with_time|> |> <| **Max capacity** \\n\\n <| {max_capacity} |number|> |> <| **Number of predictions** \\n\\n <| {n_predictions} |number|> |> <| <br/> \\n <|Create new scenario|button|on_action=create_scenario|> |> |> <|part|render={len(scenario_selector) > 0}| <|layout|columns=1 1| <| ## Scenario \\n <| {selected_scenario} |selector|lov= {scenario_selector} |dropdown|> |> <| ## Display the pipeline \\n <| {selected_pipeline} |selector|lov= {pipeline_selector} |dropdown|> |> |> <| {predictions_dataset} |chart|x=Date|y[1]=Historical values|type[1]=bar|y[2]=Predicted values|type[2]=scatter|height=80%|width=100%|> |> \"\"\" The menu combines these two pages. When a page is selected in the menu control, on_menu() is called and updates the page. # Create a menu with our pages multi_pages = \"\"\" <|menu|label=Menu|lov={[\"Data Visualization\", \"Scenario Manager\"]}|on_action=on_menu|> <|part|render={page==\"Data Visualization\"}|\"\"\" + page_data_visualization + \"\"\"|> <|part|render={page==\"Scenario Manager\"}|\"\"\" + page_scenario_manager + \"\"\"|> \"\"\" # The initial page is the \"Data Visualization\" page page = \"Data Visualization\" def on_menu ( state , var_name : str , fct : str , var_value : list ): # Change the value of the state.page variable in order to render the correct page state . page = var_value [ \"args\" ][ 0 ] Gui ( page = multi_pages ) . run ( dark_mode = False )","title":"Step 10: Embellish your App"},{"location":"getting_started/step_11/ReadMe/","text":"You can download the code of this step here or all the steps here . For Notebooks The \"Getting Started\" Notebook is available here . The code of the steps doesn't deal with the specific GUI functions for Notebooks. Step 11: Introducing Cycles \u00b6 So far, we have talked about how having different scenarios helps us to oversee our assumptions about the future. For example, in business, it is critical to weigh different options in order to come up with an optimal solution. However, this decision making process isn\u2019t just a one-time task, but rather a recurrent operation that happens over a time period. This is why we want to introduce Cycles . A cycle can be thought of as a place to store different and recurrent scenarios, within a time frame. In Taipy Core, each cycle will have a unique primary scenario, which represents the reference scenario for a time period. Typically, in a Machine Learning problem, a lot of scenarios are created daily to predict the next day. Among all those scenarios, there is only one primary scenario. In the step's example, scenarios are attached to a DAILY cycle. Using Cycles is useful because some specific Taipy's functions exist to navigate through these Cycles. Taipy can get all the scenarios created in a day by providing the Cycle. You can also get every primary scenario ever made to quickly see their progress over time. Moreover, nothing is more straightforward than creating a Cycle. The frequency parameter in a scenario configuration will create the desired type of Cycle. In the code below, the scenario has a daily cycle. It will be attached to the correct period (day) when it is created. As you can see, a Cycle can be made very easily once you have the desired frequency. In this snippet of code, since we have specified frequency=Frequency.DAILY , the corresponding scenario will be automatically attached to the correct period ( day ) once it is created. from taipy import Config , Frequency # Create scenarios each week and compare them scenario_daily_cfg = Config . configure_scenario ( id = \"scenario\" , pipeline_configs = [ baseline_pipeline_cfg , ml_pipeline_cfg ], frequency = Frequency . DAILY ) To avoid any compatibility issue between scenarios with or without cycle, this code will erase the previous scenarios, pipelines, datanodes that you have maybe created in the previous steps. # Delete all entities Config . configure_global_app ( clean_entities_enabled = True ) tp . clean_all_entities () To clarify this concept of primary scenario, the scenario selector will show a * before its name if the scenario is primary. This is why we update the following functions. # Change the inital scenario selector to see which scenarios are primary scenario_selector = [( scenario . id , ( \"*\" if scenario . is_primary else \"\" ) + scenario . name ) for scenario in all_scenarios ] # Redefine update_scenario_selector to add \"*\" in the display name when the scnario is primary def update_scenario_selector ( state , scenario ): print ( \"Updating scenario selector...\" ) # Create the scenario name for the scenario selector # This name changes dependind whether the scenario is primary or not scenario_name = ( \"*\" if scenario . is_primary else \"\" ) + scenario . name print ( scenario_name ) # Update the scenario selector state . scenario_selector += [( scenario . id , scenario_name )] In create_scenario() , scenario_daily_cfg is now the configuration used to create the scenario. By creating it, you also create the dependent Cycle. For example, setting creation_date to 04/02/2021 makes a cycle related to this day. All scenarios that are created on this day belong to this Cycle with just one primary scenario. Changing creation_date again will create another cycle for a different day and so on. # Change the create_scenario function to create a scenario with the selected frequency def create_scenario ( state ): print ( \"Execution of scenario...\" ) # Extra information for scenario creation_date = state . day name = create_name_for_scenario ( state ) # Create a scenario with the week cycle scenario = tp . create_scenario ( scenario_daily_cfg , creation_date = creation_date , name = name ) state . selected_scenario = ( scenario . id , name ) # Change the scenario that is currently selected submit_scenario ( state ) Two buttons are added to the GUI (\"Make primary\" and \"Delete scenario\"). They call the make_primary() and delete_scenario() functions below. make_primary() changes the current primary scenario of the cycle thanks to tp.set_primary(scenario) . It is the Taipy function used to make a scenario primary. Note that the previous primary scenario will not longer be primary. There is always just one primary scenario in a cycle. selected_scenario_is_primary = None def make_primary ( state ): print ( \"Making the current scenario primary...\" ) scenario = tp . get ( state . selected_scenario [ 0 ]) # Take the current scenario primary tp . set_primary ( scenario ) # Update the scenario selector accordingly state . scenario_selector = [( scenario . id , ( \"*\" if scenario . is_primary else \"\" ) + scenario . name ) for scenario in tp . get_scenarios ()] state . selected_scenario_is_primary = True This function is triggered by the \"Delete scenario\" button. Note that a primary scenario cannot be deleted. from taipy.gui import notify def remove_scenario_from_selector ( state , scenario : list ): # Take all the scenarios in the selector that doesn't have the scenario.id state . scenario_selector = [( s [ 0 ], s [ 1 ]) for s in state . scenario_selector if s [ 0 ] != scenario . id ] state . selected_scenario = state . scenario_selector [ - 1 ] def delete_scenario ( state ): scenario = tp . get ( state . selected_scenario [ 0 ]) if scenario . is_primary : # Notify the user that primary scenarios can not be deleted notify ( state , \"info\" , \"Cannot delete the primary scenario\" ) else : # Delete the scenario and the related objects (datanodes, tasks, jobs,...) tp . delete ( scenario . id ) # Update the scenario selector accordingly remove_scenario_from_selector ( state , scenario ) As previously said, just two visual elements (\"Make primary\" and \"Delete scenario\" buttons) have been added to the page. This code is almost identical to the previous page_scenario_manager . # Add a \"Delete scenario\" and a \"Make primary\" buttons page_scenario_manager = \"\"\" # Create your scenario: <|layout|columns=1 1 1 1| <| **Prediction date** \\n\\n <| {day} |date|not with_time|> |> <| **Max capacity** \\n\\n <| {max_capacity} |number|> |> <| **Number of predictions** \\n\\n <| {n_predictions} |number|> |> <| <br/> <br/> <|Create new scenario|button|on_action=create_scenario|> |> |> <|part|render={len(scenario_selector) > 0}| <|layout|columns=1 1| <|layout|columns=1 1| <| ## Scenario \\n <| {selected_scenario} |selector|lov= {scenario_selector} |dropdown|> |> <br/> <br/> <br/> <br/> <|Delete scenario|button|on_action=delete_scenario|active={len(scenario_selector)>0}|> <|Make primary|button|on_action=make_primary|active={not(selected_scenario_is_primary) and len(scenario_selector)>0}|> |> <| ## Display the pipeline \\n <| {selected_pipeline} |selector|lov= {pipeline_selector} |dropdown|> |> |> <| {predictions_dataset} |chart|x=Date|y[1]=Historical values|type[1]=bar|y[2]=Predicted values|type[2]=scatter|height=80%|width=100%|> |> \"\"\" # Redefine the multi_pages multi_pages = \"\"\" <|menu|label=Menu|lov={[\"Data Visualization\", \"Scenario Manager\"]}|on_action=on_menu|> <|part|render={page==\"Data Visualization\"}|\"\"\" + page_data_visualization + \"\"\"|> <|part|render={page==\"Scenario Manager\"}|\"\"\" + page_scenario_manager + \"\"\"|> \"\"\" When the selected scenario is changed, Taipy calls the on_change and will update state. selected_scenario_is_primary (set to True if the selected scenario is primary). def on_change ( state , var_name : str , var_value ): if var_name == \"n_week\" : # Update the dataset when the slider is moved state . dataset_week = dataset [ dataset [ \"Date\" ] . dt . isocalendar () . week == var_value ] elif var_name == \"selected_pipeline\" or var_name == \"selected_scenario\" : # Update selected_scenario_is_primary indicating if the current scenario is primary or not state . selected_scenario_is_primary = tp . get ( state . selected_scenario [ 0 ]) . is_primary # Check if we can read the Data Node to update the chart if tp . get ( state . selected_scenario [ 0 ]) . predictions . read () is not None : update_chart ( state ) Gui ( page = multi_pages ) . run ( dark_mode = False )","title":"Step 11: Introducing Cycles"},{"location":"getting_started/step_11/ReadMe/#step-11-introducing-cycles","text":"So far, we have talked about how having different scenarios helps us to oversee our assumptions about the future. For example, in business, it is critical to weigh different options in order to come up with an optimal solution. However, this decision making process isn\u2019t just a one-time task, but rather a recurrent operation that happens over a time period. This is why we want to introduce Cycles . A cycle can be thought of as a place to store different and recurrent scenarios, within a time frame. In Taipy Core, each cycle will have a unique primary scenario, which represents the reference scenario for a time period. Typically, in a Machine Learning problem, a lot of scenarios are created daily to predict the next day. Among all those scenarios, there is only one primary scenario. In the step's example, scenarios are attached to a DAILY cycle. Using Cycles is useful because some specific Taipy's functions exist to navigate through these Cycles. Taipy can get all the scenarios created in a day by providing the Cycle. You can also get every primary scenario ever made to quickly see their progress over time. Moreover, nothing is more straightforward than creating a Cycle. The frequency parameter in a scenario configuration will create the desired type of Cycle. In the code below, the scenario has a daily cycle. It will be attached to the correct period (day) when it is created. As you can see, a Cycle can be made very easily once you have the desired frequency. In this snippet of code, since we have specified frequency=Frequency.DAILY , the corresponding scenario will be automatically attached to the correct period ( day ) once it is created. from taipy import Config , Frequency # Create scenarios each week and compare them scenario_daily_cfg = Config . configure_scenario ( id = \"scenario\" , pipeline_configs = [ baseline_pipeline_cfg , ml_pipeline_cfg ], frequency = Frequency . DAILY ) To avoid any compatibility issue between scenarios with or without cycle, this code will erase the previous scenarios, pipelines, datanodes that you have maybe created in the previous steps. # Delete all entities Config . configure_global_app ( clean_entities_enabled = True ) tp . clean_all_entities () To clarify this concept of primary scenario, the scenario selector will show a * before its name if the scenario is primary. This is why we update the following functions. # Change the inital scenario selector to see which scenarios are primary scenario_selector = [( scenario . id , ( \"*\" if scenario . is_primary else \"\" ) + scenario . name ) for scenario in all_scenarios ] # Redefine update_scenario_selector to add \"*\" in the display name when the scnario is primary def update_scenario_selector ( state , scenario ): print ( \"Updating scenario selector...\" ) # Create the scenario name for the scenario selector # This name changes dependind whether the scenario is primary or not scenario_name = ( \"*\" if scenario . is_primary else \"\" ) + scenario . name print ( scenario_name ) # Update the scenario selector state . scenario_selector += [( scenario . id , scenario_name )] In create_scenario() , scenario_daily_cfg is now the configuration used to create the scenario. By creating it, you also create the dependent Cycle. For example, setting creation_date to 04/02/2021 makes a cycle related to this day. All scenarios that are created on this day belong to this Cycle with just one primary scenario. Changing creation_date again will create another cycle for a different day and so on. # Change the create_scenario function to create a scenario with the selected frequency def create_scenario ( state ): print ( \"Execution of scenario...\" ) # Extra information for scenario creation_date = state . day name = create_name_for_scenario ( state ) # Create a scenario with the week cycle scenario = tp . create_scenario ( scenario_daily_cfg , creation_date = creation_date , name = name ) state . selected_scenario = ( scenario . id , name ) # Change the scenario that is currently selected submit_scenario ( state ) Two buttons are added to the GUI (\"Make primary\" and \"Delete scenario\"). They call the make_primary() and delete_scenario() functions below. make_primary() changes the current primary scenario of the cycle thanks to tp.set_primary(scenario) . It is the Taipy function used to make a scenario primary. Note that the previous primary scenario will not longer be primary. There is always just one primary scenario in a cycle. selected_scenario_is_primary = None def make_primary ( state ): print ( \"Making the current scenario primary...\" ) scenario = tp . get ( state . selected_scenario [ 0 ]) # Take the current scenario primary tp . set_primary ( scenario ) # Update the scenario selector accordingly state . scenario_selector = [( scenario . id , ( \"*\" if scenario . is_primary else \"\" ) + scenario . name ) for scenario in tp . get_scenarios ()] state . selected_scenario_is_primary = True This function is triggered by the \"Delete scenario\" button. Note that a primary scenario cannot be deleted. from taipy.gui import notify def remove_scenario_from_selector ( state , scenario : list ): # Take all the scenarios in the selector that doesn't have the scenario.id state . scenario_selector = [( s [ 0 ], s [ 1 ]) for s in state . scenario_selector if s [ 0 ] != scenario . id ] state . selected_scenario = state . scenario_selector [ - 1 ] def delete_scenario ( state ): scenario = tp . get ( state . selected_scenario [ 0 ]) if scenario . is_primary : # Notify the user that primary scenarios can not be deleted notify ( state , \"info\" , \"Cannot delete the primary scenario\" ) else : # Delete the scenario and the related objects (datanodes, tasks, jobs,...) tp . delete ( scenario . id ) # Update the scenario selector accordingly remove_scenario_from_selector ( state , scenario ) As previously said, just two visual elements (\"Make primary\" and \"Delete scenario\" buttons) have been added to the page. This code is almost identical to the previous page_scenario_manager . # Add a \"Delete scenario\" and a \"Make primary\" buttons page_scenario_manager = \"\"\" # Create your scenario: <|layout|columns=1 1 1 1| <| **Prediction date** \\n\\n <| {day} |date|not with_time|> |> <| **Max capacity** \\n\\n <| {max_capacity} |number|> |> <| **Number of predictions** \\n\\n <| {n_predictions} |number|> |> <| <br/> <br/> <|Create new scenario|button|on_action=create_scenario|> |> |> <|part|render={len(scenario_selector) > 0}| <|layout|columns=1 1| <|layout|columns=1 1| <| ## Scenario \\n <| {selected_scenario} |selector|lov= {scenario_selector} |dropdown|> |> <br/> <br/> <br/> <br/> <|Delete scenario|button|on_action=delete_scenario|active={len(scenario_selector)>0}|> <|Make primary|button|on_action=make_primary|active={not(selected_scenario_is_primary) and len(scenario_selector)>0}|> |> <| ## Display the pipeline \\n <| {selected_pipeline} |selector|lov= {pipeline_selector} |dropdown|> |> |> <| {predictions_dataset} |chart|x=Date|y[1]=Historical values|type[1]=bar|y[2]=Predicted values|type[2]=scatter|height=80%|width=100%|> |> \"\"\" # Redefine the multi_pages multi_pages = \"\"\" <|menu|label=Menu|lov={[\"Data Visualization\", \"Scenario Manager\"]}|on_action=on_menu|> <|part|render={page==\"Data Visualization\"}|\"\"\" + page_data_visualization + \"\"\"|> <|part|render={page==\"Scenario Manager\"}|\"\"\" + page_scenario_manager + \"\"\"|> \"\"\" When the selected scenario is changed, Taipy calls the on_change and will update state. selected_scenario_is_primary (set to True if the selected scenario is primary). def on_change ( state , var_name : str , var_value ): if var_name == \"n_week\" : # Update the dataset when the slider is moved state . dataset_week = dataset [ dataset [ \"Date\" ] . dt . isocalendar () . week == var_value ] elif var_name == \"selected_pipeline\" or var_name == \"selected_scenario\" : # Update selected_scenario_is_primary indicating if the current scenario is primary or not state . selected_scenario_is_primary = tp . get ( state . selected_scenario [ 0 ]) . is_primary # Check if we can read the Data Node to update the chart if tp . get ( state . selected_scenario [ 0 ]) . predictions . read () is not None : update_chart ( state ) Gui ( page = multi_pages ) . run ( dark_mode = False )","title":"Step 11: Introducing Cycles"},{"location":"getting_started/step_12/ReadMe/","text":"You can download the code of this step here or all the steps here . For Notebooks The \"Getting Started\" Notebook is available here . The code of the steps doesn't deal with the specific GUI functions for Notebooks. Step 12: Compare Scenarios \u00b6 Cycles are helpful to keep track of KPI over time. The goal of this step is to compare the primary scenario of every cycle and its pipelines over time. To achieve this: A new dataframe has to be initialized. It will store the metrics for the baseline and ml pipeline. Then, a part will use a boolean to show or not the comparison. Finally, a selector will change the displayed metrics of the graph. # Initial dataset for comparison comparison_scenario = pd . DataFrame ({ \"Scenario Name\" :[], \"RMSE baseline\" :[], \"MAE baseline\" :[], \"RMSE ML\" :[], \"MAE ML\" :[]}) # Indicates if the comparison is done comparison_scenario_done = False # Selector for metrics metric_selector = [ \"RMSE\" , \"MAE\" ] selected_metric = metric_selector [ 0 ] First, a function has to be created to compare the primary scenario of all the cycles. tp.get_primary_scenarios() is the useful function to use for this effect. compare() goes through all of these scenarios and pipelines and add the metrics in lists. In the end, state.comparison_scenario is updated and comparison_scenario_done set to True . from sklearn.metrics import mean_absolute_error , mean_squared_error def compute_metrics ( historical_data , predicted_data ): rmse = mean_squared_error ( historical_data , predicted_data ) mae = mean_absolute_error ( historical_data , predicted_data ) return rmse , mae def compare ( state ): print ( \"Comparing...\" ) # Initial lists for comparison scenario_names = [] rmses_baseline = [] maes_baseline = [] rmses_ml = [] maes_ml = [] # Go through all the primary scenarios all_scenarios = tp . get_primary_scenarios () all_scenarios_ordered = sorted ( all_scenarios , key = lambda x : x . creation_date . timestamp ()) for scenario in all_scenarios_ordered : print ( f \"Scenario { scenario . name } \" ) # Go through all the pipelines for pipeline in scenario . pipelines . values (): print ( f \" Pipeline { pipeline . config_id } \" ) # Get the predictions dataset with the historical data only_prediction_dataset = create_predictions_dataset ( pipeline )[ - pipeline . n_predictions . read ():] # Series to compute the metrics (true values and predicted values) historical_values = only_prediction_dataset [ \"Historical values\" ] predicted_values = only_prediction_dataset [ \"Predicted values\" ] # Compute the metrics for this pipeline and primary scenario rmse , mae = compute_metrics ( historical_values , predicted_values ) # Add values to the appropriate lists if \"baseline\" in pipeline . config_id : rmses_baseline . append ( rmse ) maes_baseline . append ( mae ) elif \"ml\" in pipeline . config_id : rmses_ml . append ( rmse ) maes_ml . append ( mae ) scenario_names . append ( scenario . creation_date . strftime ( \"%A %d %b\" )) # Update comparison_scenario state . comparison_scenario = pd . DataFrame ({ \"Scenario Name\" : scenario_names , \"RMSE baseline\" : rmses_baseline , \"MAE baseline\" : maes_baseline , \"RMSE ML\" : rmses_ml , \"MAE ML\" : maes_ml }) # When comparison_scenario_done will be set to True, # the part with the graphs will be finally rendered state . comparison_scenario_done = True Let's create a page related to this comparison. As said before, this page will contain a graph to compare scenarios and pipelines; and a selector to choose the metric on which to compare. When pressed the button at the bottom of the page calls the compare() function. When finished, the render property of the part will render the rest of the page. Also, a new Taipy's block is present in the Markdown: expandable . # Performance page page_performance = \"\"\" <br/> <|part|render= {comparison_scenario_done} | <|Table|expanded=False|expandable| <| {comparison_scenario} |table|width=100%|> |> <| {selected_metric} |selector|lov= {metric_selector} |dropdown|> <|part|render={selected_metric==\"RMSE\"}| <| {comparison_scenario} |chart|type=bar|x=Scenario Name|y[1]=RMSE baseline|y[2]=RMSE ML|height=100%|width=100%|> |> <|part|render={selected_metric==\"MAE\"}| <| {comparison_scenario} |chart|type=bar|x=Scenario Name|y[1]=MAE baseline|y[2]=MAE ML|height=100%|width=100%|> |> |> <center> <|Compare primarys|button|on_action=compare|> </center> \"\"\" # Add the page_performance section to the menu multi_pages = \"\"\" <|menu|label=Menu|lov={[\"Data Visualization\", \"Scenario Manager\", \"Performance\"]}|on_action=on_menu|> <|part|render={page==\"Data Visualization\"}|\"\"\" + page_data_visualization + \"\"\"|> <|part|render={page==\"Scenario Manager\"}|\"\"\" + page_scenario_manager + \"\"\"|> <|part|render={page==\"Performance\"}|\"\"\" + page_performance + \"\"\"|> \"\"\" Gui ( page = multi_pages ) . run ( dark_mode = False )","title":"Step 12: Compare Scenarios"},{"location":"getting_started/step_12/ReadMe/#step-12-compare-scenarios","text":"Cycles are helpful to keep track of KPI over time. The goal of this step is to compare the primary scenario of every cycle and its pipelines over time. To achieve this: A new dataframe has to be initialized. It will store the metrics for the baseline and ml pipeline. Then, a part will use a boolean to show or not the comparison. Finally, a selector will change the displayed metrics of the graph. # Initial dataset for comparison comparison_scenario = pd . DataFrame ({ \"Scenario Name\" :[], \"RMSE baseline\" :[], \"MAE baseline\" :[], \"RMSE ML\" :[], \"MAE ML\" :[]}) # Indicates if the comparison is done comparison_scenario_done = False # Selector for metrics metric_selector = [ \"RMSE\" , \"MAE\" ] selected_metric = metric_selector [ 0 ] First, a function has to be created to compare the primary scenario of all the cycles. tp.get_primary_scenarios() is the useful function to use for this effect. compare() goes through all of these scenarios and pipelines and add the metrics in lists. In the end, state.comparison_scenario is updated and comparison_scenario_done set to True . from sklearn.metrics import mean_absolute_error , mean_squared_error def compute_metrics ( historical_data , predicted_data ): rmse = mean_squared_error ( historical_data , predicted_data ) mae = mean_absolute_error ( historical_data , predicted_data ) return rmse , mae def compare ( state ): print ( \"Comparing...\" ) # Initial lists for comparison scenario_names = [] rmses_baseline = [] maes_baseline = [] rmses_ml = [] maes_ml = [] # Go through all the primary scenarios all_scenarios = tp . get_primary_scenarios () all_scenarios_ordered = sorted ( all_scenarios , key = lambda x : x . creation_date . timestamp ()) for scenario in all_scenarios_ordered : print ( f \"Scenario { scenario . name } \" ) # Go through all the pipelines for pipeline in scenario . pipelines . values (): print ( f \" Pipeline { pipeline . config_id } \" ) # Get the predictions dataset with the historical data only_prediction_dataset = create_predictions_dataset ( pipeline )[ - pipeline . n_predictions . read ():] # Series to compute the metrics (true values and predicted values) historical_values = only_prediction_dataset [ \"Historical values\" ] predicted_values = only_prediction_dataset [ \"Predicted values\" ] # Compute the metrics for this pipeline and primary scenario rmse , mae = compute_metrics ( historical_values , predicted_values ) # Add values to the appropriate lists if \"baseline\" in pipeline . config_id : rmses_baseline . append ( rmse ) maes_baseline . append ( mae ) elif \"ml\" in pipeline . config_id : rmses_ml . append ( rmse ) maes_ml . append ( mae ) scenario_names . append ( scenario . creation_date . strftime ( \"%A %d %b\" )) # Update comparison_scenario state . comparison_scenario = pd . DataFrame ({ \"Scenario Name\" : scenario_names , \"RMSE baseline\" : rmses_baseline , \"MAE baseline\" : maes_baseline , \"RMSE ML\" : rmses_ml , \"MAE ML\" : maes_ml }) # When comparison_scenario_done will be set to True, # the part with the graphs will be finally rendered state . comparison_scenario_done = True Let's create a page related to this comparison. As said before, this page will contain a graph to compare scenarios and pipelines; and a selector to choose the metric on which to compare. When pressed the button at the bottom of the page calls the compare() function. When finished, the render property of the part will render the rest of the page. Also, a new Taipy's block is present in the Markdown: expandable . # Performance page page_performance = \"\"\" <br/> <|part|render= {comparison_scenario_done} | <|Table|expanded=False|expandable| <| {comparison_scenario} |table|width=100%|> |> <| {selected_metric} |selector|lov= {metric_selector} |dropdown|> <|part|render={selected_metric==\"RMSE\"}| <| {comparison_scenario} |chart|type=bar|x=Scenario Name|y[1]=RMSE baseline|y[2]=RMSE ML|height=100%|width=100%|> |> <|part|render={selected_metric==\"MAE\"}| <| {comparison_scenario} |chart|type=bar|x=Scenario Name|y[1]=MAE baseline|y[2]=MAE ML|height=100%|width=100%|> |> |> <center> <|Compare primarys|button|on_action=compare|> </center> \"\"\" # Add the page_performance section to the menu multi_pages = \"\"\" <|menu|label=Menu|lov={[\"Data Visualization\", \"Scenario Manager\", \"Performance\"]}|on_action=on_menu|> <|part|render={page==\"Data Visualization\"}|\"\"\" + page_data_visualization + \"\"\"|> <|part|render={page==\"Scenario Manager\"}|\"\"\" + page_scenario_manager + \"\"\"|> <|part|render={page==\"Performance\"}|\"\"\" + page_performance + \"\"\"|> \"\"\" Gui ( page = multi_pages ) . run ( dark_mode = False )","title":"Step 12: Compare Scenarios"},{"location":"manuals/about/","text":"About Taipy's User Manual \u00b6 This User Manual covers all the topics and concepts that you can find in Taipy. For each topic, we are trying to provide as many examples as possible so that you as a Taipy user can perform a specific task. If you are just starting with Taipy, you may want to look at the Getting Started document in order to see a step-by-step example of a complete Taipy application. Graphical User Interface (GUI) - taipy.gui \u00b6 The taipy.gui^ package allows you to design an effective Graphic User Interface. It provides many interactive widgets, controls, and presentative elements to enhance the user\u2019s experience. GUI user manual Taipy Core - taipy.core \u00b6 The taipy.core^ package is a Python library made to build powerful and customized data-driven back-end applications. It provides the necessary tools to help Python developer transform their algorithms into a complete back-end application. Taipy Core brings algorithm management to another level: algorithms are now connected to the end-user through user-defined scenarios, interactive data, smart scheduling, etc. Definition of Taipy Core concepts , Documentation on Taipy Core configuration , Description of Taipy Core entities Taipy REST - taipy.rest \u00b6 The taipy.rest package allows you to interact with Taipy Core concepts such as scenarios, pipelines, etc. through a dedicated REST API. This package aims to provide a solution to easily integrate Taipy applications with other IT systems. The API comes with multiple endpoints for you to work with Taipy Core concept conveniently and efficiently. Taipy REST user manual Deployment \u00b6 Heroku Deployment manual","title":"About Taipy's User Manual"},{"location":"manuals/about/#about-taipys-user-manual","text":"This User Manual covers all the topics and concepts that you can find in Taipy. For each topic, we are trying to provide as many examples as possible so that you as a Taipy user can perform a specific task. If you are just starting with Taipy, you may want to look at the Getting Started document in order to see a step-by-step example of a complete Taipy application.","title":"About Taipy's User Manual"},{"location":"manuals/about/#graphical-user-interface-gui---taipygui","text":"The taipy.gui^ package allows you to design an effective Graphic User Interface. It provides many interactive widgets, controls, and presentative elements to enhance the user\u2019s experience. GUI user manual","title":"Graphical User Interface (GUI) - taipy.gui"},{"location":"manuals/about/#taipy-core---taipycore","text":"The taipy.core^ package is a Python library made to build powerful and customized data-driven back-end applications. It provides the necessary tools to help Python developer transform their algorithms into a complete back-end application. Taipy Core brings algorithm management to another level: algorithms are now connected to the end-user through user-defined scenarios, interactive data, smart scheduling, etc. Definition of Taipy Core concepts , Documentation on Taipy Core configuration , Description of Taipy Core entities","title":"Taipy Core - taipy.core"},{"location":"manuals/about/#taipy-rest---taipyrest","text":"The taipy.rest package allows you to interact with Taipy Core concepts such as scenarios, pipelines, etc. through a dedicated REST API. This package aims to provide a solution to easily integrate Taipy applications with other IT systems. The API comes with multiple endpoints for you to work with Taipy Core concept conveniently and efficiently. Taipy REST user manual","title":"Taipy REST - taipy.rest"},{"location":"manuals/about/#deployment","text":"Heroku Deployment manual","title":"Deployment"},{"location":"manuals/reference/","text":"Taipy Python API packages \u00b6 Taipy is made of different Python packages. The API reference for Taipy is therefore split into several sections. taipy : The main package of Taipy. taipy.gui : The package dedicated to Graphical User Interface generation.","title":"About Taipy's Reference Manual"},{"location":"manuals/reference/#taipy-python-api-packages","text":"Taipy is made of different Python packages. The API reference for Taipy is therefore split into several sections. taipy : The main package of Taipy. taipy.gui : The package dedicated to Graphical User Interface generation.","title":"Taipy Python API packages"},{"location":"manuals/core/","text":"Taipy Core \u00b6 The Taipy Core package is a python library made to build powerful and customized data-driven back-end applications. It provides the necessary tools to help Python developer transform their algorithms into a complete back-end application. Taipy Core brings algorithm management to another level: algorithms are now connected to the end-user through user-defined scenarios, powerful scenario comparison, interactive data, smart scheduling, etc. Definition of Taipy Core concepts , Documentation on the python configuration , Description of Taipy Core entities","title":"Taipy Core"},{"location":"manuals/core/#taipy-core","text":"The Taipy Core package is a python library made to build powerful and customized data-driven back-end applications. It provides the necessary tools to help Python developer transform their algorithms into a complete back-end application. Taipy Core brings algorithm management to another level: algorithms are now connected to the end-user through user-defined scenarios, powerful scenario comparison, interactive data, smart scheduling, etc. Definition of Taipy Core concepts , Documentation on the python configuration , Description of Taipy Core entities","title":"Taipy Core"},{"location":"manuals/core/concepts/","text":"Taipy's Core concepts \u00b6 Taipy Core is an application builder designed to help Python developer turn their data algorithms into an interactive production-ready data-driven application. Taipy Core provides the necessary concepts for modeling, executing, and monitoring algorithms. In this documentation, such algorithms are called pipelines. A pipeline can be seen as a succession of functions that exchange data. It can be described as an execution graph (a Directed Acyclic Graph or DAG). With Taipy one can model simple pipelines as well as more complex pipelines. Let's take some examples. Simple single function example The following picture represents a simple pipeline made of a single cleaning function processing a single input, the raw data , and returning a single output, the cleaned data . Linear example with two functions The second example below is slightly more complex. The first function cleaning processes a single input, the raw data , and returns some intermediate data named cleaned data . The second function filtering reads the same intermediate data cleaned data and returns a single output filtered data . Branching example The third example below introduces some complexity. As you can see in the picture below, the function generating does not have any input. On the contrary, the function aggregating takes multiple inputs and returns multiple outputs. The purpose of this section is to define the following Taipy Core concepts. A Data node (the dark blue boxes) represents a dataset. It can be shared by multiple tasks as input or output. A Task (the orange boxes) can be seen as a function taking some data node(s) as input and returning some data node(s). A Job is a unique execution of a Task. A Pipeline represents an algorithm or pipeline made of tasks that should run together. A Scenario is made of one or multiple pipelines. It represents an instance of a business problem to solve. A Cycle or work cycle is a time period corresponding to an iteration of a recurrent scenario. A Scope represents the visibility of a data node in the graph of entities, and the level of its parent (Pipeline, Scenario, Cycle). Definition: Config vs Entities Among the concepts described in this section, the data nodes , tasks , pipelines , and scenarios have two types of Taipy objects related to them: configuration objects and runtime objects. To differentiate the configuration objects from their runtime counterparts, they are named configs ( DataNodeConfig , TaskConfig , PipelineConfig , and ScenarioConfig ) while the runtime objects ( DataNode , Task , Pipeline , and Scenario ) are called entities . It will benefit the reader to visualize the different Taipy configs like a set of Russian dolls where each config belongs to a \"larger\" config : One thing to wrap your head around (it may not be very intuitive for everyone at first) is that the configs are really just configuration objects specifying the characteristics and the behaviors of the concepts they relate to. Configs can be seen as generators. Indeed, each entity is created from a config . Note also that the same config can be used to instantiate multiple entities . More details on the configs are available in the Configuration chapter. More details on the entities are available in the Entities chapter. The next section introduces the data node concept .","title":"Taipy's Core concepts"},{"location":"manuals/core/concepts/#taipys-core-concepts","text":"Taipy Core is an application builder designed to help Python developer turn their data algorithms into an interactive production-ready data-driven application. Taipy Core provides the necessary concepts for modeling, executing, and monitoring algorithms. In this documentation, such algorithms are called pipelines. A pipeline can be seen as a succession of functions that exchange data. It can be described as an execution graph (a Directed Acyclic Graph or DAG). With Taipy one can model simple pipelines as well as more complex pipelines. Let's take some examples. Simple single function example The following picture represents a simple pipeline made of a single cleaning function processing a single input, the raw data , and returning a single output, the cleaned data . Linear example with two functions The second example below is slightly more complex. The first function cleaning processes a single input, the raw data , and returns some intermediate data named cleaned data . The second function filtering reads the same intermediate data cleaned data and returns a single output filtered data . Branching example The third example below introduces some complexity. As you can see in the picture below, the function generating does not have any input. On the contrary, the function aggregating takes multiple inputs and returns multiple outputs. The purpose of this section is to define the following Taipy Core concepts. A Data node (the dark blue boxes) represents a dataset. It can be shared by multiple tasks as input or output. A Task (the orange boxes) can be seen as a function taking some data node(s) as input and returning some data node(s). A Job is a unique execution of a Task. A Pipeline represents an algorithm or pipeline made of tasks that should run together. A Scenario is made of one or multiple pipelines. It represents an instance of a business problem to solve. A Cycle or work cycle is a time period corresponding to an iteration of a recurrent scenario. A Scope represents the visibility of a data node in the graph of entities, and the level of its parent (Pipeline, Scenario, Cycle). Definition: Config vs Entities Among the concepts described in this section, the data nodes , tasks , pipelines , and scenarios have two types of Taipy objects related to them: configuration objects and runtime objects. To differentiate the configuration objects from their runtime counterparts, they are named configs ( DataNodeConfig , TaskConfig , PipelineConfig , and ScenarioConfig ) while the runtime objects ( DataNode , Task , Pipeline , and Scenario ) are called entities . It will benefit the reader to visualize the different Taipy configs like a set of Russian dolls where each config belongs to a \"larger\" config : One thing to wrap your head around (it may not be very intuitive for everyone at first) is that the configs are really just configuration objects specifying the characteristics and the behaviors of the concepts they relate to. Configs can be seen as generators. Indeed, each entity is created from a config . Note also that the same config can be used to instantiate multiple entities . More details on the configs are available in the Configuration chapter. More details on the entities are available in the Entities chapter. The next section introduces the data node concept .","title":"Taipy's Core concepts"},{"location":"manuals/core/concepts/cycle/","text":"Data applications are often used to solve business problems that operate in time cycles. Examples: Predictions of sales data for Store X will need to occur every week The master planning of Company A\u2019s supply chain needs to happen every month etc. For this purpose, Taipy brings the concept of Cycle^ (or work cycle), which represents a single iteration of such a work pattern. Each cycle has a start date and a duration dependent upon the production publication frequency of the scenarios. In Taipy, scenarios may have a Frequency^ among: Frequency.DAILY Frequency.WEEKLY Frequency.MONTHLY Frequency.QUARTERLY Frequency.YEARLY At its creation, a new scenario is attached to a cycle, the one that matches its frequency and its creation_date . Example for January cycle In our example, the end-user must publish production orders (i.e., a production plan) every month. During each month (the cycle), the end-user will be interested in \"playing\" with different scenarios untill only one of those scenarios is selected as the official production plan to be published. Using Taipy, each month is modeled as a cycle, and each Taipy cycle will contain one or more Taipy scenarios. The picture on the left shows the tree of entities: Cycles, Scenarios and their associated Pipeline(s). There is an existing past cycle for December and a current cycle for January containing a single scenario. When comes the end of a cycle (start date + duration), only one of the scenarios is applied in production. This \"official\" scenario is called the primary scenario . Only one primary scenario per cycle is allowed. Example for February cycle Now we start working on the February work cycle. We create two scenarios for the February cycle (one with a low capacity assumption and one with a high capacity assumption). As a user of the application, I can decide to apply the low capacity scenario in production for February. To accomplish that, I promote my low capacity scenario as primary for the February cycle. The tree of entities resulting from the various scenarios created is represented in the picture on the left. The underlined scenarios are primary . Note Note that cycles are optional. If a scenario has no Frequency, it will not be attached to any cycle. The attributes of a scenario (the set of pipelines, the cycle, ... ) are populated based on the scenario configuration ScenarioConfig^ that must be provided when instantiating a new scenario. (Please refer to the configuration details documentation for more details on configuration). The next section introduces the Job concept.","title":"Cycle"},{"location":"manuals/core/concepts/data-node/","text":"A data node is one of the most important concepts in Taipy Core. It does not contain the data itself but holds all the necessary information to read and write the actual data. It can be seen as a dataset descriptor or data reference. A data node can reference any data: a text, a numeric value, a list of parameters, a custom python object, the content of a JSON file, a CSV file, a Pickle file, etc. the content of one or multiple database table(s), any other data. It is designed to model any type of data: input, intermediate, or output data, internal or external data, local or remote data, historical data, a set of parameters, a trained model, etc. The data node information depends on the data itself, its exposed format, and its storage type. First example: If the data is stored in an SQL database, the corresponding data node should contain the username, password, host, port, the queries to read and write the data,as well as the python class used for deserialization. Second example: If the data is stored in a CSV file, the corresponding data node should contain, for instance, the path to the file and the python class used for deserialization. Let's take a realistic example. Let's assume we want to build an application to predict the monthly sales demand in order to adjust production planning, constrained by some capacity. The flowchart below represents the various data nodes we want to be processed byt the tasks (in orange). For that purpose, we have six data nodes modeling the data (the dark blue boxes). One each for the sales history , the trained model , the current month , the sales predictions , the production capacity , and the production orders . Note Taipy proposes various predefined data nodes corresponding to the most popular storage types . More details on the Data node configuration page In our example, the sales history comes as a CSV file. For example, the sales history comes from our company record system, so we do not control its storage type. We got the data as a CSV file. We can use a predefined CSV data node to model the sales history . As for the production orders data node, we want to write the data into a database shared by other systems. We can use the SQL data node to model the production orders . We have no particular specification for the other data nodes. We can use the default storage type: Pickle. The data node's attributes are populated based on the data node configuration DataNodeConfig^ that must be provided when instantiating a new data node. (Please refer to the configuration details documentation for more details on configuration). The next section introduces the Task concept .","title":"Data node"},{"location":"manuals/core/concepts/execution-flow/","text":"Reminder: Config vs Entities The data nodes , tasks , pipelines , and scenarios concepts have two types of Taipy objects related to them: configs and runtime entities . Remember that each entity is created from a config . Remember also that the same config can be used to instantiate multiple entities . Let's take some scenario entity use cases to illustrate the logic behind the Taipy execution flow. For this purpose, we will use the configuration graph below. The picture above represents the graph of configs objects ( DataNodeConfig and TaskConfig objects). Single Scenario Execution \u00b6 Let\u2019s assume we instantiate a new scenario from the previous configuration graph. Let\u2019s call it Scenario 1 . All the entities of Scenario 1 will be instantiated from the various configuration objects. Scenario 1 can also be represented as the entity graph below: Thanks to this graph representation, Taipy automatically understand the execution precedence constraints. When a scenario/pipeline is submitted for execution, the tasks are smartly scheduled and executed in the correct sequence. Taipy also optimizes the execution of pipelines and scenarios by not recomputing tasks that do not need to be executed. Let\u2019s assume that scenario 1 has already been executed. If the end-user decides to re-execute the same scenario, then only three situations can occur: Situation 1 : Taipy re-executes all the tasks. This is the default behavior. Situation 2 : None of the data nodes have been modified since the last run. The data nodes sales predictions and production orders are cached, and they don't need to be re-executed. Taipy does not re-execute the tasks. (Please refer to DataNodeConfig^ documentation to activate the \"cacheable\" feature). Situation 3 : If at least one of the input data nodes has been modified since the last run, Taipy only executes the \"appropriate\" tasks. It implies that: If the predict task entity has any of its two input data nodes ( trained model or current month ) changed since the last run, then in the second run, Taipy re-executes both the predict and the planning tasks. If trained model and current month have not been modified but capacity has, then Taipy only re-executes the planning task. Multiple Scenario Execution \u00b6 Let\u2019s continue with the previous example by creating a second scenario from the same config. Let\u2019s call it Scenario 2 . In the case of two scenarios instantiated from the same configuration, what is the impact of executing scenario 1 over the execution of scenario 2 . Two options are possible with Taipy: Option 1 : Taipy assumes that the entities of each scenario are \"local\" to each scenario and are not shared with other scenarios. Similar to the first scenario, the following entity graph is created for Scenario 2 . Note that even if both scenarios share the same configuration graph, all their data nodes and tasks are separate instances. Scenario 2 's data nodes and tasks are separate instances and are prefixed by 2 . Option 2 : Taipy assumes that only some entities of the scenarios are \"global\" and are shared among scenarios. For instance, current month can be shared by Scenario 1 and Scenario 2 . In this second option, the following entity graph is created for Scenario 2 . To illustrate the difference between the two options, let\u2019s assume that: First, Scenario 1 has been executed with its current month entity set to \" January \". Then, the current month data node entity of Scenario 2 has been set to \" February \". If Option 1 applies, then when the end-user re-executes Scenario 1 , Taipy produces the same execution as before (or does not re-execute the tasks if the \"cacheable\" feature is activated). If Option 2 applies, current month and current month 2 data nodes are the same entity. When the end\u2013user re-execute Scenario 1 , Taipy detects that the current month data node entity has changed. Then re-executing Scenario 1 , runs the entity graph with the current month set to \" February \". To enable the difference in behavior, Taipy introduces the concept of Scope. In Taipy, Option 1 corresponds to the by-default behavior: SCOPE default value is at the SCENARIO level. While Option 2 corresponds to setting the scope to a level above SCENARIO (either CYCLE or GLOBAL ). The next section introduces the Scope concept.","title":"Execution flow"},{"location":"manuals/core/concepts/execution-flow/#single-scenario-execution","text":"Let\u2019s assume we instantiate a new scenario from the previous configuration graph. Let\u2019s call it Scenario 1 . All the entities of Scenario 1 will be instantiated from the various configuration objects. Scenario 1 can also be represented as the entity graph below: Thanks to this graph representation, Taipy automatically understand the execution precedence constraints. When a scenario/pipeline is submitted for execution, the tasks are smartly scheduled and executed in the correct sequence. Taipy also optimizes the execution of pipelines and scenarios by not recomputing tasks that do not need to be executed. Let\u2019s assume that scenario 1 has already been executed. If the end-user decides to re-execute the same scenario, then only three situations can occur: Situation 1 : Taipy re-executes all the tasks. This is the default behavior. Situation 2 : None of the data nodes have been modified since the last run. The data nodes sales predictions and production orders are cached, and they don't need to be re-executed. Taipy does not re-execute the tasks. (Please refer to DataNodeConfig^ documentation to activate the \"cacheable\" feature). Situation 3 : If at least one of the input data nodes has been modified since the last run, Taipy only executes the \"appropriate\" tasks. It implies that: If the predict task entity has any of its two input data nodes ( trained model or current month ) changed since the last run, then in the second run, Taipy re-executes both the predict and the planning tasks. If trained model and current month have not been modified but capacity has, then Taipy only re-executes the planning task.","title":"Single Scenario Execution"},{"location":"manuals/core/concepts/execution-flow/#multiple-scenario-execution","text":"Let\u2019s continue with the previous example by creating a second scenario from the same config. Let\u2019s call it Scenario 2 . In the case of two scenarios instantiated from the same configuration, what is the impact of executing scenario 1 over the execution of scenario 2 . Two options are possible with Taipy: Option 1 : Taipy assumes that the entities of each scenario are \"local\" to each scenario and are not shared with other scenarios. Similar to the first scenario, the following entity graph is created for Scenario 2 . Note that even if both scenarios share the same configuration graph, all their data nodes and tasks are separate instances. Scenario 2 's data nodes and tasks are separate instances and are prefixed by 2 . Option 2 : Taipy assumes that only some entities of the scenarios are \"global\" and are shared among scenarios. For instance, current month can be shared by Scenario 1 and Scenario 2 . In this second option, the following entity graph is created for Scenario 2 . To illustrate the difference between the two options, let\u2019s assume that: First, Scenario 1 has been executed with its current month entity set to \" January \". Then, the current month data node entity of Scenario 2 has been set to \" February \". If Option 1 applies, then when the end-user re-executes Scenario 1 , Taipy produces the same execution as before (or does not re-execute the tasks if the \"cacheable\" feature is activated). If Option 2 applies, current month and current month 2 data nodes are the same entity. When the end\u2013user re-execute Scenario 1 , Taipy detects that the current month data node entity has changed. Then re-executing Scenario 1 , runs the entity graph with the current month set to \" February \". To enable the difference in behavior, Taipy introduces the concept of Scope. In Taipy, Option 1 corresponds to the by-default behavior: SCOPE default value is at the SCENARIO level. While Option 2 corresponds to setting the scope to a level above SCENARIO (either CYCLE or GLOBAL ). The next section introduces the Scope concept.","title":"Multiple Scenario Execution"},{"location":"manuals/core/concepts/job/","text":"Tasks, Pipelines and Scenarios entities can be submitted for execution. The submission of a scenario triggers the submission of all the pipelines it refers to. Similarly, submission of a pipeline triggers the submission of all the tasks it refers to. Each time a task is submitted for execution, a new Job is created. A Job^ represents a single execution of a task. It holds all the information related to the task execution, including the creation date , the execution Status^ , the log messages of the user function, and the stacktrace of any exception that may be raised. The Next section provide information on the Execution flow.","title":"Job"},{"location":"manuals/core/concepts/pipeline/","text":"A Pipeline^ is made to model an algorithm. It represents a direct acyclic graph of input, intermediate, and output data nodes linked together by tasks. A pipeline is a set of tasks designed to perform a set of functions. For instance, in a typical machine learning application, we may have a pipeline dedicated to preprocessing and preparing data, a pipeline for computing a training model, and a pipeline dedicated to scoring. In the example We have chosen to model two pipelines. First, a sales pipeline (boxed in green in the picture) containing training and predict tasks. Second, a production pipeline (boxed in dark gray in the picture) containing the planning task. In fact, the two pipelines can be customized to represent two different workflows that run independently, under different schedules (for batch execution running on a fixed schedule (e.g. every week)) or by different users (For interactive execution triggered by end-users). Note that the pipelines are not necessarily disjoint. The attributes of a pipeline (the set of tasks) are populated based on the pipeline configuration PipelineConfig^ that must be provided when instantiating a new pipeline. (Please refer to the configuration details documentation for more details on configuration). The next section introduces the Scenario concept.","title":"Pipeline"},{"location":"manuals/core/concepts/scenario/","text":"We have introduced in Taipy the important concept of a Scenario^ . The Taipy Scenario represents an instance of a business problem to solve on consistent data and parameter sets. As its name implies, Taipy scenarios enable the business user to instantiate different versions of a business problem with different assumptions. This is extremely useful in a business context where impact analysis and what-if analysis are essential in the decision process. After having analyzed its first scenario, the end-user may be very interested in modifying input data nodes (not the intermediate nor the output data nodes), re-running the same pipelines and comparing the results with the previous run. For this purpose, it will just need to instantiate a second scenario, execute it and compare it with the first scenario. This process can be repeated across multiple scenarios. In the example In our example, we want our scenario to have the two pipelines described earlier. In the flowchart below, the external light blue box represents my scenario that contains both pipelines. A scenario represents one instance of a business problem to solve. Each new business problem instance is represented by a new scenario. Taipy allows us to give the end users the ability to store, edit, and execute various scenarios in the same application. Example Suppose that we want to build an application to predict the monthly demand of a store and optimize production orders. In that case, we can create the first scenario for January. It must contain everything we need to understand the January case, access input data, compute predictions, visualize our forecast algorithm results, make production decisions, and publish January production orders. Then we can create another scenario for February production planning. And so on. Two scenarios can also be used to represent the same instance of a business problem but with two different sets of assumptions. Example We would like to perform some simulation on the impact of our capacity data on production planning for the February use case. The first scenario can forecast demand and compute production orders assuming a low capacity, whereas the second scenario assumes a high capacity value. The next section introduces the Cycle concept.","title":"Scenario"},{"location":"manuals/core/concepts/scope/","text":"The Scope^ of a data node is an enum among the following values : Scope.PIPELINE Scope.SCENARIO (Default value) Scope.CYCLE Scope.GLOBAL Each data node has a scope. It is an attribute provided by the DataNodeConfig^ and represents the visibility of the data node in the graph of entities. The entities can be described as a graph where each node belongs to one or several upper nodes. A data node 'belongs' to at least one pipeline, which belongs to at least one scenario, which belongs to a single cycle. In other words : A data node with the scope equals Scope.PIPELINE , can only be shared by multiple tasks in the same pipeline. A data node with the scope equals Scope.SCENARIO , can be shared by multiple tasks and pipelines within a unique scenario, but it cannot belong to other tasks or pipelines from another scenario. A data node with the scope equals Scope.CYCLE , can be shared by all the tasks, pipelines, and scenarios from one cycle but cannot be shared with tasks, pipelines, or scenarios from another cycle. A data node with the scope equals Scope.GLOBAL , can be shared by any task, pipeline, and scenario, whatever their cycles. Example In our example with two pipelines, we have several possibilities. The following pictures represent two examples. The scopes are written in green at the bottom of each data node. The first picture represents the basic case. We let Taipy apply the default scope ( Scope.PIPELINE ) for most data nodes. However, as you can see, the sales predictions data node is shared by the two pipelines of my scenario. Consequently, its scope cannot be Scope.PIPELINE , but must be at least Scope.SCENARIO . In this case, my various scenarios do not share any data nodes. In the second picture, we have a second use case. In this example, several changes are made: The first assumption is that the historical sales are stored in a single system of records. The sales history becomes a data node shared by all the tasks, pipelines, scenarios, and cycles. Its scope is Scope.GLOBAL . That means there will be only one Sales history data node, whatever the number of cycles or scenarios. All the scenarios will share the same data pointed by the same data node. The sales pipeline execution only depends on the current month (i.e., the cycle). The trained model , the current month , and the sales predictions data nodes have a Scope.CYCLE scope. All the scenarios from the same cycle will share the three data nodes. For example, both scenarios with low and high capacity for the February cycle share the three data nodes. The linked tasks (training and predict) can only be executed once for both scenarios. Finally, since there are multiple scenarios to simulate various capacities for a single cycle, the capacity and the production orders data nodes must have a Scope.SCENARIO scope so that multiple scenarios do not share them. The next section introduces the Core configuration.","title":"Scope"},{"location":"manuals/core/concepts/task/","text":"A Task^ is a runnable python code provided by the developer (typically a data scientist). It represents one of the steps that the developer will need to implement his/her pipeline. Concretely, a task means a python function that can be executed. For example, a task could be a pre-processing function to clean the initial dataset. It could also be a more complex function that develops a training model using machine learning algorithms. Since a task represents a function, it can take a set of parameters as input and return a set of results as output. Each input parameter and each output result is modeled as a data node. The attributes of a task (the input data nodes, the output data nodes, the python function) are populated based on the task configuration TaskConfig^ that must be provided when instantiating a new task. (Please refer to the configuration details documentation for more details on configuration). In our example We create three tasks: The first is the training task that takes the sales history as the input data node and returns the trained model as the output data node. The second is the predict task that takes the trained model and the current month as input and returns the sales predictions . And the third task is the production planning task that takes the capacity and the sales predictions as input data nodes and returns the production orders as output. Important Since no task computes them, sales history , current month , and capacity are considered as input data nodes. The trained model and sales predictions ' data nodes are considered as intermediate data nodes while the production orders data node is considered as an output data node since no task reads it. The next section introduces the Pipeline concept.","title":"Task"},{"location":"manuals/core/config/","text":"Taipy's Core configuration \u00b6 In the previous chapter, the few Taipy Core concepts are defined. Taipy Core is an application builder designed to help Python developer turn efficiently their algorithms into an interactive production-ready data-driven application. To build such an application, the first step consists in configuring the characteristics and the desired behavior of your application and its entities. Reminder: Config vs Entities The data nodes , tasks , pipelines , and scenarios concepts have two types of Taipy objects related to them: configuration objects and runtime objects. To differentiate the configuration objects from their runtime counterparts, they are named configs ( DataNodeConfig , TaskConfig , PipelineConfig , and ScenarioConfig ) while the runtime objects ( DataNode , Task , Pipeline , and Scenario ) are called entities . One thing to wrap your head around (it may not be very intuitive for everyone at first) is that the configs are really just configuration objects specifying the characteristics and the behaviors of the concepts they relate to. Configs can be seen as generators. Indeed, each entity is created from a config . Note also that the same config can be used to instantiate multiple entities . More details on the entities are available in the Entities chapter. This chapter is dedicated to the configuration and focuses on the various configs objects. Its sections are organized as follows: Config section introduces the Config^ singleton class which is the single entrypoint for Taipy Core configuration. Data node configs section provides documentation on the data nodes' configurations using the python DataNodeConfig^ class. Task configs section provides documentation on the tasks' configurations using the python TaskConfig^ class. Pipeline configs section provides documentation on the pipelines' configurations using the python PipelineConfig^ class. Scenario configs section provides documentation on the scenarios' configurations using the python ScenarioConfig^ class. Global config section documents the global configuration fields and the python GlobalAppConfig^ class. Job scheduling config section documents the configuration of the job scheduling using the python JobConfig^ class. Config checker section presents the configuration checkers. Advanced configuration section provides details on advanced configuration features, and in particular the capacity to overwrite configuration fields with TOML files. The next section introduces the Config singleton .","title":"Taipy's Core configuration"},{"location":"manuals/core/config/#taipys-core-configuration","text":"In the previous chapter, the few Taipy Core concepts are defined. Taipy Core is an application builder designed to help Python developer turn efficiently their algorithms into an interactive production-ready data-driven application. To build such an application, the first step consists in configuring the characteristics and the desired behavior of your application and its entities. Reminder: Config vs Entities The data nodes , tasks , pipelines , and scenarios concepts have two types of Taipy objects related to them: configuration objects and runtime objects. To differentiate the configuration objects from their runtime counterparts, they are named configs ( DataNodeConfig , TaskConfig , PipelineConfig , and ScenarioConfig ) while the runtime objects ( DataNode , Task , Pipeline , and Scenario ) are called entities . One thing to wrap your head around (it may not be very intuitive for everyone at first) is that the configs are really just configuration objects specifying the characteristics and the behaviors of the concepts they relate to. Configs can be seen as generators. Indeed, each entity is created from a config . Note also that the same config can be used to instantiate multiple entities . More details on the entities are available in the Entities chapter. This chapter is dedicated to the configuration and focuses on the various configs objects. Its sections are organized as follows: Config section introduces the Config^ singleton class which is the single entrypoint for Taipy Core configuration. Data node configs section provides documentation on the data nodes' configurations using the python DataNodeConfig^ class. Task configs section provides documentation on the tasks' configurations using the python TaskConfig^ class. Pipeline configs section provides documentation on the pipelines' configurations using the python PipelineConfig^ class. Scenario configs section provides documentation on the scenarios' configurations using the python ScenarioConfig^ class. Global config section documents the global configuration fields and the python GlobalAppConfig^ class. Job scheduling config section documents the configuration of the job scheduling using the python JobConfig^ class. Config checker section presents the configuration checkers. Advanced configuration section provides details on advanced configuration features, and in particular the capacity to overwrite configuration fields with TOML files. The next section introduces the Config singleton .","title":"Taipy's Core configuration"},{"location":"manuals/core/config/advanced-config/","text":"Taipy provides three ways to configure your application : A Python configuration An explicit file configuration using TOML format An environment variable file configuration Example Here is a typical workflow that shows how to adapt the configuration of a Taipy application at each stage of a software project (from initial development to production). To get started, as a developer I will be designing my application by configuring all the new entities (data nodes, tasks, pipelines, scenarios) using the Python code configuration with just a minimal number of attributes configured. The default configuration is used for the other attributes. Then, I am testing the application built. At this step, I need my application to have a more realistic behavior like real data. For that, I need more configuration. I can specify for my specific input dataset what file to use. I am using the Python code configuration for that. Then, once I am happy with my application running on my local dev environment, I am deploying it to a remote environment for testing. This is a dedicated environment made for testing deployment and for integration testing. I can then use an explicit TOML file configuration. I can now easily update the file if necessary to be efficient in debugging, without changing the code directly. Once the step 3 is done, I want to be able to deploy a released and tagged version of my application in several remote environments (e.g. pre-production, production). I am creating one TOML file per remote environment with a few values that differ from step 3, and on each environment, I am setting a different environment variable value to point to the right TOML configuration file. These methods are described below. Python code configuration \u00b6 A code configuration can be done on a Python file directly when designing the pipelines and scenarios. This configuration can be done using methods from the Config^ class. This python configuration is meant to be used during the application development phase. It overrides the default configuration: if some values are not provided, the default configuration applies. Design of the application to configure Let's imagine we want to configure an application corresponding to the design described in the picture. We use the following python configuration code. Python configuration Below is the python code corresponding to the design above. my_config.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from datetime import datetime from my_functions import plan , predict , train from taipy import Config , Frequency , Scope # Configure all six data nodes sales_history_cfg = Config . configure_csv_data_node ( id = \"sales_history\" , scope = Scope . GLOBAL , path = \"my/file/path.csv\" ) trained_model_cfg = Config . configure_data_node ( id = \"trained_model\" , scope = Scope . CYCLE ) current_month_cfg = Config . configure_data_node ( id = \"current_month\" , scope = Scope . CYCLE , default_data = datetime ( 2020 , 1 , 1 )) sales_predictions_cfg = Config . configure_data_node ( id = \"sales_predictions\" , scope = Scope . CYCLE ) capacity_cfg = Config . configure_data_node ( id = \"capacity\" ) production_orders_cfg = Config . configure_sql_data_node ( id = \"production_orders\" , db_username = \"admin\" , db_password = \"ENV[PWD]\" , db_name = \"production_planning\" , db_engine = \"mssql\" , read_query = \"SELECT * from production_order\" , write_table = \"production_order\" ) # Configure the three tasks training_cfg = Config . configure_task ( \"training\" , train , sales_history_cfg , [ trained_model_cfg ]) predicting_cfg = Config . configure_task ( id = \"predicting\" , function = predict , input = [ trained_model_cfg , current_month_cfg ], output = sales_predictions_cfg ) planning_cfg = Config . configure_task ( id = \"planning\" , function = plan , input = [ sales_predictions_cfg , capacity_cfg ], output = [ production_orders_cfg ]) # Configure the two pipelines sales_pipeline_cfg = Config . configure_pipeline ( id = \"sales\" , task_configs = [ training_cfg , predicting_cfg ]) production_pipeline_cfg = Config . configure_pipeline ( id = \"production\" , task_configs = [ planning_cfg ]) # Configure the scenario monthly_scenario_cfg = Config . configure_scenario ( id = \"scenario_configuration\" , pipeline_configs = [ sales_pipeline_cfg , production_pipeline_cfg ], frequency = Frequency . MONTHLY ) The train , predict , and plan methods used in lines 22, 24, and 28 are the user functions imported in line 2 from the module my_functions that represents a user python module. my_functions.py module The following module \"my_function\" is imported in the python configuration. my_functions.py 1 2 3 4 5 6 7 8 9 10 11 12 13 import pandas as pd def train ( sales_history : pd . DataFrame ): print ( \"Running training\" ) return \"TRAINED_MODEL\" def predict ( model , current_month ): print ( \"Running predicting\" ) return \"SALES_PREDICTIONS\" def plan ( sales_predictions , capacity ): print ( \"Running planning\" ) return \"PRODUCTION_ORDERS\" TOML export of the python configuration The following file is the TOML version of the python configuration. config.toml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 [TAIPY] [JOB] [DATA_NODE.sales_history] storage_type = \"csv\" scope = \"GLOBAL\" path = \"my/file/path.csv\" has_header = \"True:bool\" cacheable = \"False:bool\" [DATA_NODE.trained_model] storage_type = \"pickle\" scope = \"CYCLE\" cacheable = \"False:bool\" [DATA_NODE.current_month] storage_type = \"pickle\" scope = \"CYCLE\" default_data = 2020-01-01 T00 : 00 : 00 cacheable = \"False:bool\" [DATA_NODE.sales_predictions] storage_type = \"pickle\" scope = \"CYCLE\" cacheable = \"False:bool\" [DATA_NODE.capacity] storage_type = \"pickle\" scope = \"SCENARIO\" cacheable = \"False:bool\" [DATA_NODE.production_orders] storage_type = \"sql\" scope = \"SCENARIO\" db_username = \"admin\" db_password = \"ENV[PWD]\" db_name = \"production_planning\" db_host = \"localhost\" db_engine = \"mssql\" db_driver = \"ODBC Driver 17 for SQL Server\" read_query = \"SELECT * from production_order\" write_table = \"production_order\" db_port = \"1433:int\" cacheable = \"False:bool\" [TASK.training] inputs = [ \"sales_history\" ,] outputs = [ \"trained_model\" ,] [TASK.predicting] inputs = [ \"trained_model\" , \"current_month\" ,] outputs = [ \"sales_predictions\" ,] [TASK.planning] inputs = [ \"sales_predictions\" , \"capacity\" ,] outputs = [ \"production_orders\" ,] [PIPELINE.sales] tasks = [ \"training\" , \"predicting\" ,] [PIPELINE.production] tasks = [ \"planning\" ,] [SCENARIO.scenario_configuration] pipelines = [ \"sales\" , \"production\" ,] frequency = \"MONTHLY\" Note that the type of the non-string configuration attributes is specified in the TOML file by adding at the end of the value (':bool', ':int', or ':float'). Security Note that in line 15 of the python code, and in line 37 of the TOML export, the password is not exposed. The property's value is a template referencing the environment variable PWD that contains the value. It must be exported as follows: export PWD=my_pwd See section environment-based configuration for more details. Explicit TOML file configuration \u00b6 Taipy also provides file configuration. Indeed, a TOML file can be explicitly provided by the developer to the Taipy application using Python coding such as : 1 2 3 from taipy import Config Config . load ( \"folder/config.toml\" ) This file configuration overrides the attributes in the code configuration (and the default configuration). Here is an example of a TOML file overriding the code configuration provided above as an example : folder/config.toml 1 2 3 4 5 6 7 [JOB] mode = \"standalone\" nb_of_workers = 5 [DATA_NODE.sales_history] storage_type = \"csv\" path = \"./path/to/my/file.csv\" Two behaviors occur if the previous TOML file is used as file configuration. First, the Taipy application now has five workers (By default, the number of workers is 1). Then, the sales_history data node now is a CSV data node pointing to the file ./path/to/my/file.csv . All other configuration fields remain unchanged. Environment variable file configuration \u00b6 Finally, if the environment variable TAIPY_CONFIG_PATH is defined with the path of a TOML config, Taipy will automatically load the file and override the previous configurations (explicit file configuration, code configuration and default configuration). This functionality can be handy to change the configuration of a Taipy application without having to restart it. Attribute in an environment variable \u00b6 Configuration can be set dynamically using environment variables with the syntax ENV[MY_VARIABLE] . This syntax can be used both in python configuration or TOML configuration. At runtime, Taipy will search for MY_VARIABLE among the environment variables then use it. This can be used to set a different configuration field value depending on the environment on which the application will run. This is also especially useful if you want to use secret strings such as host names, usernames or passwords. For example, if you are using Airflow as a Taipy scheduler, you can hide the password from the configuration file using an environment variable. Let's take an example with two environment variables. One string password and one integer value. You can export the PWD and NB_WORKERS variables with the following command lines 1 2 export PWD=MySeCrEtPaSsWoRd export NB_WORKERS=4 and refer to it with the following Taipy configuration: python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( airflow_password = \"ENV[PWD]\" , nb_workers = \"ENV[NB_WORKERS]\" ) TOML configuration 1 2 3 [JOB] airflow_password = \"ENV[PWD]\" nb_workers = \"ENV[NB_WORKERS]:int\" Note that if the type of the configuration attribute is not a string, it must be specified in the TOML file (':bool', ':int', ':float'). Exporting configuration \u00b6 Taipy also provides a method to export the compiled configuration applied after the compilation of all the configurations (default, Python code, explicit file, and environment variable configurations) which is the result of the overwriting. 1 2 3 from taipy import Config Config . export ( \"config.toml\" )","title":"Advanced configuration"},{"location":"manuals/core/config/advanced-config/#python-code-configuration","text":"A code configuration can be done on a Python file directly when designing the pipelines and scenarios. This configuration can be done using methods from the Config^ class. This python configuration is meant to be used during the application development phase. It overrides the default configuration: if some values are not provided, the default configuration applies. Design of the application to configure Let's imagine we want to configure an application corresponding to the design described in the picture. We use the following python configuration code. Python configuration Below is the python code corresponding to the design above. my_config.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from datetime import datetime from my_functions import plan , predict , train from taipy import Config , Frequency , Scope # Configure all six data nodes sales_history_cfg = Config . configure_csv_data_node ( id = \"sales_history\" , scope = Scope . GLOBAL , path = \"my/file/path.csv\" ) trained_model_cfg = Config . configure_data_node ( id = \"trained_model\" , scope = Scope . CYCLE ) current_month_cfg = Config . configure_data_node ( id = \"current_month\" , scope = Scope . CYCLE , default_data = datetime ( 2020 , 1 , 1 )) sales_predictions_cfg = Config . configure_data_node ( id = \"sales_predictions\" , scope = Scope . CYCLE ) capacity_cfg = Config . configure_data_node ( id = \"capacity\" ) production_orders_cfg = Config . configure_sql_data_node ( id = \"production_orders\" , db_username = \"admin\" , db_password = \"ENV[PWD]\" , db_name = \"production_planning\" , db_engine = \"mssql\" , read_query = \"SELECT * from production_order\" , write_table = \"production_order\" ) # Configure the three tasks training_cfg = Config . configure_task ( \"training\" , train , sales_history_cfg , [ trained_model_cfg ]) predicting_cfg = Config . configure_task ( id = \"predicting\" , function = predict , input = [ trained_model_cfg , current_month_cfg ], output = sales_predictions_cfg ) planning_cfg = Config . configure_task ( id = \"planning\" , function = plan , input = [ sales_predictions_cfg , capacity_cfg ], output = [ production_orders_cfg ]) # Configure the two pipelines sales_pipeline_cfg = Config . configure_pipeline ( id = \"sales\" , task_configs = [ training_cfg , predicting_cfg ]) production_pipeline_cfg = Config . configure_pipeline ( id = \"production\" , task_configs = [ planning_cfg ]) # Configure the scenario monthly_scenario_cfg = Config . configure_scenario ( id = \"scenario_configuration\" , pipeline_configs = [ sales_pipeline_cfg , production_pipeline_cfg ], frequency = Frequency . MONTHLY ) The train , predict , and plan methods used in lines 22, 24, and 28 are the user functions imported in line 2 from the module my_functions that represents a user python module. my_functions.py module The following module \"my_function\" is imported in the python configuration. my_functions.py 1 2 3 4 5 6 7 8 9 10 11 12 13 import pandas as pd def train ( sales_history : pd . DataFrame ): print ( \"Running training\" ) return \"TRAINED_MODEL\" def predict ( model , current_month ): print ( \"Running predicting\" ) return \"SALES_PREDICTIONS\" def plan ( sales_predictions , capacity ): print ( \"Running planning\" ) return \"PRODUCTION_ORDERS\" TOML export of the python configuration The following file is the TOML version of the python configuration. config.toml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 [TAIPY] [JOB] [DATA_NODE.sales_history] storage_type = \"csv\" scope = \"GLOBAL\" path = \"my/file/path.csv\" has_header = \"True:bool\" cacheable = \"False:bool\" [DATA_NODE.trained_model] storage_type = \"pickle\" scope = \"CYCLE\" cacheable = \"False:bool\" [DATA_NODE.current_month] storage_type = \"pickle\" scope = \"CYCLE\" default_data = 2020-01-01 T00 : 00 : 00 cacheable = \"False:bool\" [DATA_NODE.sales_predictions] storage_type = \"pickle\" scope = \"CYCLE\" cacheable = \"False:bool\" [DATA_NODE.capacity] storage_type = \"pickle\" scope = \"SCENARIO\" cacheable = \"False:bool\" [DATA_NODE.production_orders] storage_type = \"sql\" scope = \"SCENARIO\" db_username = \"admin\" db_password = \"ENV[PWD]\" db_name = \"production_planning\" db_host = \"localhost\" db_engine = \"mssql\" db_driver = \"ODBC Driver 17 for SQL Server\" read_query = \"SELECT * from production_order\" write_table = \"production_order\" db_port = \"1433:int\" cacheable = \"False:bool\" [TASK.training] inputs = [ \"sales_history\" ,] outputs = [ \"trained_model\" ,] [TASK.predicting] inputs = [ \"trained_model\" , \"current_month\" ,] outputs = [ \"sales_predictions\" ,] [TASK.planning] inputs = [ \"sales_predictions\" , \"capacity\" ,] outputs = [ \"production_orders\" ,] [PIPELINE.sales] tasks = [ \"training\" , \"predicting\" ,] [PIPELINE.production] tasks = [ \"planning\" ,] [SCENARIO.scenario_configuration] pipelines = [ \"sales\" , \"production\" ,] frequency = \"MONTHLY\" Note that the type of the non-string configuration attributes is specified in the TOML file by adding at the end of the value (':bool', ':int', or ':float'). Security Note that in line 15 of the python code, and in line 37 of the TOML export, the password is not exposed. The property's value is a template referencing the environment variable PWD that contains the value. It must be exported as follows: export PWD=my_pwd See section environment-based configuration for more details.","title":"Python code configuration"},{"location":"manuals/core/config/advanced-config/#explicit-toml-file-configuration","text":"Taipy also provides file configuration. Indeed, a TOML file can be explicitly provided by the developer to the Taipy application using Python coding such as : 1 2 3 from taipy import Config Config . load ( \"folder/config.toml\" ) This file configuration overrides the attributes in the code configuration (and the default configuration). Here is an example of a TOML file overriding the code configuration provided above as an example : folder/config.toml 1 2 3 4 5 6 7 [JOB] mode = \"standalone\" nb_of_workers = 5 [DATA_NODE.sales_history] storage_type = \"csv\" path = \"./path/to/my/file.csv\" Two behaviors occur if the previous TOML file is used as file configuration. First, the Taipy application now has five workers (By default, the number of workers is 1). Then, the sales_history data node now is a CSV data node pointing to the file ./path/to/my/file.csv . All other configuration fields remain unchanged.","title":"Explicit TOML file configuration"},{"location":"manuals/core/config/advanced-config/#environment-variable-file-configuration","text":"Finally, if the environment variable TAIPY_CONFIG_PATH is defined with the path of a TOML config, Taipy will automatically load the file and override the previous configurations (explicit file configuration, code configuration and default configuration). This functionality can be handy to change the configuration of a Taipy application without having to restart it.","title":"Environment variable file configuration"},{"location":"manuals/core/config/advanced-config/#attribute-in-an-environment-variable","text":"Configuration can be set dynamically using environment variables with the syntax ENV[MY_VARIABLE] . This syntax can be used both in python configuration or TOML configuration. At runtime, Taipy will search for MY_VARIABLE among the environment variables then use it. This can be used to set a different configuration field value depending on the environment on which the application will run. This is also especially useful if you want to use secret strings such as host names, usernames or passwords. For example, if you are using Airflow as a Taipy scheduler, you can hide the password from the configuration file using an environment variable. Let's take an example with two environment variables. One string password and one integer value. You can export the PWD and NB_WORKERS variables with the following command lines 1 2 export PWD=MySeCrEtPaSsWoRd export NB_WORKERS=4 and refer to it with the following Taipy configuration: python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( airflow_password = \"ENV[PWD]\" , nb_workers = \"ENV[NB_WORKERS]\" ) TOML configuration 1 2 3 [JOB] airflow_password = \"ENV[PWD]\" nb_workers = \"ENV[NB_WORKERS]:int\" Note that if the type of the configuration attribute is not a string, it must be specified in the TOML file (':bool', ':int', ':float').","title":"Attribute in an environment variable"},{"location":"manuals/core/config/advanced-config/#exporting-configuration","text":"Taipy also provides a method to export the compiled configuration applied after the compilation of all the configurations (default, Python code, explicit file, and environment variable configurations) which is the result of the overwriting. 1 2 3 from taipy import Config Config . export ( \"config.toml\" )","title":"Exporting configuration"},{"location":"manuals/core/config/config-checker/","text":"Taipy provides a checking mechanism to validate if your configuration is correct. You can trigger the check by calling: 1 2 3 from taipy import Config Config . check () The Config.check()^ method returns a collector of issues. Each issue corresponds to an inconsistency in the configuration attached to an issue level ( INFO , WARNING , ERROR ). Config.check()^ raises an exception if at least one issue collected has the ERROR level. Here is the list of the possible issues that could be returned by the checker: An ERROR issue is created if the clean_entities_enabled property is populated in the GlobalAppConfig^ with a non-Boolean value. An ERROR issue is created if the storage_type and the scope properties of any DataNodeConfig^ have not been provided with a correct value. Depending on the storage_type value of a DataNodeConfig^ , an ERROR issue is created if a specific required property is missing. An ERROR issue is created if one of the inputs and outputs parameters of a TaskConfig^ does not correspond to a DataNodeConfig . A WARNING issue is created if a TaskConfig^ has no input and no output. An ERROR issue is created if the function parameter of a TaskConfig^ is not a callable function. An ERROR issue is created if one of the task parameters of a PipelineConfig^ does not correspond to a TaskConfig . A WARNING issue is created if a PipelineConfig^ has no task configuration defined. An ERROR issue is created if one of the pipeline parameters of a ScenarioConfig^ does not correspond to a PipelineConfig . A WARNING issue is created if a ScenarioConfig^ has no pipeline configuration defined. An ERROR issue is created if the frequency parameter of a ScenarioConfig^ has an incorrect Frequency^ value. An INFO issue is created if a ScenarioConfig^ has no comparator defined. If the JobConfig^ has been configured with multiple workers, an ERROR issue is created if an \"in_memory\" DataNodeConfig^ is defined. The next section presents advanced configuration .","title":"Config checker"},{"location":"manuals/core/config/config/","text":"The Config^ class is the entrypoint for Taipy Core configuration. It is accessible using the following import: 1 from taipy import Config It exposes all the necessary attributes and methods to manage the configuration. In particular, it holds : the data node configurations as a dictionary of DataNodeConfig^ s: 1 2 3 from taipy import Config Config . data_nodes the task configurations as a dictionary of TaskConfig^ s: 1 2 3 from taipy import Config Config . tasks the pipeline configurations as a dictionary of PipelineConfig^ s: 1 2 3 from taipy import Config Config . pipelines the scenario configurations as a dictionary of ScenarioConfig^ s: 1 2 3 from taipy import Config Config . scenarios the job configuration as a JobConfig^ : 1 2 3 from taipy import Config Confi . job_config the global configuration as a GlobalAppConfig^ : 1 2 3 from taipy import Config Confi . global_config The next section introduces the data node configuration .","title":"Config"},{"location":"manuals/core/config/data-node-config/","text":"For Taipy to instantiate a Data node , a data node configuration must be provided. DataNodeConfig^ is used to configure the various data nodes that Taipy will manipulate. To configure a new DataNodeConfig^ , one can use the function Config.configure_data_node()^ . 1 2 3 from taipy import Config data_node_cfg = Config . configure_data_node ( id = \"data_node_cfg\" ) In the previous code, we configured a simple data node just providing an identifier as a string \"data_node_cfg\". More optional attributes are available on data nodes, including: id is the identifier of the data node config. It is a mandatory parameter that must be unique. It must be a valid Python identifier. scope is a Scope^ . It corresponds to the scope of the data node that will be instantiated from the data node configuration. The default value is Scope.SCENARIO . storage_type is an attribute that indicates the type of storage of the data node. The possible values are \"pickle\" ( the default value ), \"csv\" , \"excel\" , \"sql\" , \"in_memory\" , or \"generic\" . As explained in the following subsections, depending on the storage_type , other configuration attributes must be provided in the parameter properties parameter. Any other custom attribute can be provided through the parameter properties , which is a dictionary (a description, a tag, etc.) This properties dictionary is used to configure the parameters specific to each storage type. Note also that all this dictionary properties is copied in the dictionary properties of all the data nodes instantiated from this data node configuration. Below are two examples of data node configurations. 1 2 3 4 5 6 7 8 9 from taipy import Config , Scope date_cfg = Config . configure_data_node ( id = \"date_cfg\" , description = \"The current date of the scenario\" ) model_cfg = Config . configure_data_node ( id = \"model_cfg\" , scope = Scope . CYCLE , storage_type = \"pickle\" , description = \"The trained model shared by all scenarios\" , code = 54 ) In line 3, we configured a simple data node with the id \"date_cfg\". The default value for scope is SCENARIO . The storage_type also has the default value \"pickle\". An optional custom property called description is also added: this property is propagated to the data nodes instantiated from this config. In lines 5-9, we add another data node configuration with the id \"model_cfg\". scope is set to CYCLE , so the corresponding data nodes will be shared by all the scenarios from the same cycle. storage_type is \"pickle\" as well, and two optional custom properties are added: a description string and an integer code . These two properties are propagated to the data nodes instantiated from this config. Storage type \u00b6 Taipy proposes various predefined data nodes corresponding to the most popular storage types . Thanks to predefined data nodes , the Python developer does not need to spend much time configuring the storage types or the query system . Most of the time, a predefined data node corresponding to a basic and standard use case satisfies the user's needs like pickle file, csv file, sql table, Excel sheet, etc. The various predefined storage types are mainly used for input data. Indeed, the input data is usually provided by an external component, and the Python developer user does not control the format. However, in most cases, particularly for intermediate or output data nodes , it is not relevant to prefer one storage type . The end-user wants to manipulate the corresponding data within the Taipy application. Still, the user does not have any particular specifications regarding the storage type . In such a case, the Python developer is recommended to use the default storage type pickle that does not require any configuration. In case a more specific method to store, read and write the data is needed by the user, Taipy proposes a Generic data node that can be used for any storage type or any kind of query system . The user only needs to provide two python functions, one for reading and one for writing the data. Each predefined data node is described in a subsequent section. Pickle \u00b6 A PickleDataNode^ is a specific data node used to model pickle data. To add a new pickle data node configuration, the Config.configure_pickle_data_node()^ method can be used. In addition to the generic parameters described in the previous section Data node configuration , two optional parameters can be provided. The path parameter represents the file path used by Taipy to read and write the data. If the pickle file already exists (in the case of a shared input data node, for instance), it is necessary to provide the file path as the path parameter. If no value is provided, Taipy will use an internal path in the Taipy storage folder (more details on the Taipy storage folder configuration available on the Global configuration documentation). If the default_data is provided, the data node is automatically written with the corresponding value. Any serializable Python object can be used. 1 2 3 4 5 6 from taipy import Config from datetime import datetime date_cfg = Config . configure_pickle_data_node ( id = \"date_cfg\" , default_data = datetime ( 2022 , 1 , 25 )) model_cfg = Config . configure_pickle_data_node ( id = \"model_cfg\" , path = \"path/to/my/model.p\" , description = \"The trained model\" ) In line 4, we configure a simple pickle data node with the id \"date_cfg\". The scope is SCENARIO (default value), and a default data is provided. In line 6, we add another pickle data node configuration with the id \"model_cfg\". The default SCENARIO scope is used. Since the data node config corresponds to a pre-existing pickle file, a path \"path/to/my/model.p\" is provided. We also added an optional custom description. Note To configure a pickle data node, it is equivalent to use the method Config.configure_pickle_data_node()^ or the method Config.configure_data_node()^ with parameter storage_type=\"pickle\" . Csv \u00b6 A CSVDataNode^ data node is a specific data node used to model csv file data. To add a new csv data node configuration, the Config.configure_csv_data_node()^ method can be used. In addition to the generic parameters described in the previous section Data node configuration , one mandatory and two optional parameters can be provided. The path parameter is a mandatory parameter and represents the csv file path used by Taipy to read and write the data. The has_header parameter represents if the file has a header of not. By default, has_header is True and Taipy will use the 1st row in the CSV file as the header. When the exposed_type is given as a parameter, if the exposed_type value provided is numpy , the data node will read the csv file to a numpy array. If the provided value is a custom class, data node will create a list of custom object with the given custom class, each object will represent a row in the csv file.If exposed_type is not provided, the data node will read the csv file as a pandas DataFrame. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from taipy import Config class SaleRow : date : str nb_sales : int temp_cfg = Config . configure_csv_data_node ( id = \"historical_temperature\" , path = \"path/hist_temp.csv\" , has_header = True , exposed_type = \"numpy\" ) sales_cfg = Config . configure_csv_data_node ( id = \"sale_history\" , path = \"path/sale_history.csv\" , exposed_type = SaleRow ) In lines 3-5, we define a custom class SaleRow representing a row of the CSV file. In lines 7-10, we configure a basic csv data node with the id \"historical_temperature\". Its scope is by default SCENARIO . The path corresponds to the file path/hist_temp.csv . The property has_header being True, representing the csv file has a header. In lines 12-14, we add another csv data node configuration with the id \"sale_history\". The default SCENARIO scope is used again. Since we have a custom class pre-defined for this csv file ( SaleRow ), we provide it as the exposed_type parameter. Note To configure a csv data node, it is equivalent to use the method Config.configure_csv_data_node()^ or the method Config.configure_data_node()^ with parameter storage_type=\"csv\" . Excel \u00b6 An ExcelDataNode^ is a specific data node used to model xlsx file data. To add a new Excel data node configuration, the Config.configure_excel_data_node()^ method can be used. In addition to the generic parameters described in the previous section Data node configuration , a mandatory and three optional parameters can be provided. The path is a mandatory parameter that represents the Excel file path used by Taipy to read and write the data. The has_header parameter specifies if the file has a header of not. If has_header is True (by default or was specified), Taipy will use the 1st row in the Excel file as the header. The sheet_name parameter represents which specific sheet in the Excel file to read. If sheet_name is provided with a list of sheet names, the data node will return a dictionary with the key being the sheet name and the value being the data of the corresponding sheet. If a string is provided, the data node will read only the data of the corresponding sheet. The default value of sheet_name is None and the data node will return all sheets in the provided Excel file when reading it. When the exposed_type is given as a parameter, if the exposed_type value provided is numpy , the data node will read the Excel file to a numpy array. If the provided value is a custom class, data node will create a list of custom objects with the given custom class, each object will represent a row in the Excel file. If exposed_type is not provided, the data node will read the Excel file as a pandas DataFrame. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from taipy import Config class SaleRow : date : str nb_sales : int hist_temp_cfg = Config . configure_excel_data_node ( id = \"historical_temperature\" , path = \"path/hist_temp.xlsx\" , exposed_type = \"numpy\" ) sales_cfg = Config . configure_excel_data_node ( id = \"sale_history\" , path = \"path/sale_history.xlsx\" , sheet_name = [ \"January\" , \"February\" ], exposed_type = SaleRow ) In lines 3-5, we define a custom class SaleRow , representing an the Excel file row. In lines 7-9, we configure an Excel data node. The id identifier is \"historical_temperature\". Its scope is SCENARIO (default value), and the path is the file hist_temp.xlsx. With has_header being True, the Excel file must have a header. The sheet_name is not provided so Taipy will use the default value \"Sheet1\". In lines 10-13, we add another excel data node configuration. The id identifier is \"sale_history\", the default SCENARIO scope is used. Since we have a custom class pre-defined for this Excel file, we will provide it in the exposed_type . We also provide the list of specific sheets we want to use as the sheet_name parameter. Note To configure an Excel data node, it is equivalent to use the method Config.configure_excel_data_node()^ or the method Config.configure_data_node()^ with parameter storage_type=\"excel\" . Sql \u00b6 A SQLDataNode^ is a specific data node used to model Sql data. To add a new sql data node configuration, the Config.configure_sql_data_node()^ method can be used. In addition to the generic parameters described in the previous section Data node configuration , multiple parameters can be provided. The db_username parameter represents the database username that will be used by Taipy to access the database. The db_password parameter represents the database user's password that will be used by Taipy to access the database. The db_name parameter represents the name of the database. The db_engine parameter represents the engine of the database. The read_query parameter represents the SQL query that will be used by Taipy to read the data from the database. The write_table parameter represents the name of the table in the database that Taipy will be writing the data to. The db_port parameter represents the database port that will be used by Taipy to access the database. The default value of db_port is 1433. The db_host parameter represents the database host that will be used by Taipy to access the database. The default value of db_host is \"localhost\". The db_driver parameter represents the database driver that will be used by Taipy. The default value of db_driver is \"ODBC Driver 17 for SQL Server\". 1 2 3 4 5 6 7 8 9 from taipy import Config forecasts_cfg = Config . configure_sql_data_node ( id = \"forecasts\" , db_username = \"admin\" , db_password = \"password\" , db_name = \"taipy\" , db_engine = \"mssql\" , read_query = \"SELECT * from forecast_table\" , write_table = \"forecast_table\" ) In the previous example, we configure a sql data node with the id \"forecasts\". Its scope is the default value SCENARIO . The database username is \"admin\", the user's password is \"password\", the database name is \"taipy\", and the database engine is mssql (short for Microsoft SQL). The read query will be \"SELECT * from forecast_table\", and the table the data will be written to is \"forecast_table\". Note To configure a sql data node, it is equivalent to use the method Config.configure_sql_data_node()^ or the method Config.configure_data_node()^ with parameter storage_type=\"sql\" . Generic \u00b6 A GenericDataNode^ is a specific data node used to model generic data types where the read and the write functions are defined by the user. To add a new generic data node configuration, the Config.configure_generic_data_node()^ method can be used. In addition to the parameters described in the previous section Data node configuration , two optional parameters can be provided. The read_fct is a mandatory parameter that represents a Python function provided by the user. It will be used to read the data. More optional parameters can be passed through the read_fct_params parameter. The write_fct is a mandatory parameter representing a Python function provided by the user. It will be used to write/serialize the data. The provided function must have at least one parameter dedicated to receiving data to be written. More optional parameters can be passed through the write_fct_params parameter. The parameter read_fct_params represents the parameters that are passed to the read_fct to read/de-serialize the data. It must be a List type object. The parameter write_fct_params represents the parameters that are passed to the write_fct to write the data. It must be a List type object. 1 2 3 4 5 6 7 8 9 10 11 12 from taipy import Config def read_data (): pass def write_data ( data : Any , path : str ): pass historical_data_cfg = Config . configure_generic_data_node ( id = \"historical_data\" , read_fct = read_data , write_fct = write_data , write_fct_params = [ '../path/' ]) In this small example, we configure a generic data node with the id \"historical_data\". We provide two Python functions (previously defined) as read_fct and write_fct parameters to read and write the data. We also provided a list object for the write_fct_params with a path to let the write_fct know where to write the data. Note To configure a generic data node, it is equivalent to use the method Config.configure_generic_data_node()^ or the method Config.configure_data_node()^ with parameter storage_type=\"generic\" . In memory \u00b6 An InMemoryDataNode^ is a specific data node used to model any data in the RAM. The Config.configure_in_memory_data_node()^ method can be used to add a new in_memory data node configuration. In addition to the generic parameters described in the previous section Data node configuration , an optional parameter can be provided. If the default_data is given as a parameter, the data node is automatically written with the corresponding value (note that any python object can be used). 1 2 3 4 from taipy import Config from datetime import datetime date_cfg = Config . configure_in_memory_data_node ( id = \"date\" , default_data = datetime ( 2022 , 1 , 25 )) In this example, we configure an in_memory data node with the id \"date\", the scope is SCENARIO (default value), and a default data is provided. Warning Since the data is stored in memory, it cannot be used in a multiprocess environment. (See Job configuration for more details). Note To configure an in_memory data node, it is equivalent to use the method Config.configure_in_memory_data_node()^ or the method Config.configure_data_node()^ with parameter storage_type=\"in_memory\" . The next section introduces the task configuration .","title":"Data node configs"},{"location":"manuals/core/config/data-node-config/#storage-type","text":"Taipy proposes various predefined data nodes corresponding to the most popular storage types . Thanks to predefined data nodes , the Python developer does not need to spend much time configuring the storage types or the query system . Most of the time, a predefined data node corresponding to a basic and standard use case satisfies the user's needs like pickle file, csv file, sql table, Excel sheet, etc. The various predefined storage types are mainly used for input data. Indeed, the input data is usually provided by an external component, and the Python developer user does not control the format. However, in most cases, particularly for intermediate or output data nodes , it is not relevant to prefer one storage type . The end-user wants to manipulate the corresponding data within the Taipy application. Still, the user does not have any particular specifications regarding the storage type . In such a case, the Python developer is recommended to use the default storage type pickle that does not require any configuration. In case a more specific method to store, read and write the data is needed by the user, Taipy proposes a Generic data node that can be used for any storage type or any kind of query system . The user only needs to provide two python functions, one for reading and one for writing the data. Each predefined data node is described in a subsequent section.","title":"Storage type"},{"location":"manuals/core/config/data-node-config/#pickle","text":"A PickleDataNode^ is a specific data node used to model pickle data. To add a new pickle data node configuration, the Config.configure_pickle_data_node()^ method can be used. In addition to the generic parameters described in the previous section Data node configuration , two optional parameters can be provided. The path parameter represents the file path used by Taipy to read and write the data. If the pickle file already exists (in the case of a shared input data node, for instance), it is necessary to provide the file path as the path parameter. If no value is provided, Taipy will use an internal path in the Taipy storage folder (more details on the Taipy storage folder configuration available on the Global configuration documentation). If the default_data is provided, the data node is automatically written with the corresponding value. Any serializable Python object can be used. 1 2 3 4 5 6 from taipy import Config from datetime import datetime date_cfg = Config . configure_pickle_data_node ( id = \"date_cfg\" , default_data = datetime ( 2022 , 1 , 25 )) model_cfg = Config . configure_pickle_data_node ( id = \"model_cfg\" , path = \"path/to/my/model.p\" , description = \"The trained model\" ) In line 4, we configure a simple pickle data node with the id \"date_cfg\". The scope is SCENARIO (default value), and a default data is provided. In line 6, we add another pickle data node configuration with the id \"model_cfg\". The default SCENARIO scope is used. Since the data node config corresponds to a pre-existing pickle file, a path \"path/to/my/model.p\" is provided. We also added an optional custom description. Note To configure a pickle data node, it is equivalent to use the method Config.configure_pickle_data_node()^ or the method Config.configure_data_node()^ with parameter storage_type=\"pickle\" .","title":"Pickle"},{"location":"manuals/core/config/data-node-config/#csv","text":"A CSVDataNode^ data node is a specific data node used to model csv file data. To add a new csv data node configuration, the Config.configure_csv_data_node()^ method can be used. In addition to the generic parameters described in the previous section Data node configuration , one mandatory and two optional parameters can be provided. The path parameter is a mandatory parameter and represents the csv file path used by Taipy to read and write the data. The has_header parameter represents if the file has a header of not. By default, has_header is True and Taipy will use the 1st row in the CSV file as the header. When the exposed_type is given as a parameter, if the exposed_type value provided is numpy , the data node will read the csv file to a numpy array. If the provided value is a custom class, data node will create a list of custom object with the given custom class, each object will represent a row in the csv file.If exposed_type is not provided, the data node will read the csv file as a pandas DataFrame. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from taipy import Config class SaleRow : date : str nb_sales : int temp_cfg = Config . configure_csv_data_node ( id = \"historical_temperature\" , path = \"path/hist_temp.csv\" , has_header = True , exposed_type = \"numpy\" ) sales_cfg = Config . configure_csv_data_node ( id = \"sale_history\" , path = \"path/sale_history.csv\" , exposed_type = SaleRow ) In lines 3-5, we define a custom class SaleRow representing a row of the CSV file. In lines 7-10, we configure a basic csv data node with the id \"historical_temperature\". Its scope is by default SCENARIO . The path corresponds to the file path/hist_temp.csv . The property has_header being True, representing the csv file has a header. In lines 12-14, we add another csv data node configuration with the id \"sale_history\". The default SCENARIO scope is used again. Since we have a custom class pre-defined for this csv file ( SaleRow ), we provide it as the exposed_type parameter. Note To configure a csv data node, it is equivalent to use the method Config.configure_csv_data_node()^ or the method Config.configure_data_node()^ with parameter storage_type=\"csv\" .","title":"Csv"},{"location":"manuals/core/config/data-node-config/#excel","text":"An ExcelDataNode^ is a specific data node used to model xlsx file data. To add a new Excel data node configuration, the Config.configure_excel_data_node()^ method can be used. In addition to the generic parameters described in the previous section Data node configuration , a mandatory and three optional parameters can be provided. The path is a mandatory parameter that represents the Excel file path used by Taipy to read and write the data. The has_header parameter specifies if the file has a header of not. If has_header is True (by default or was specified), Taipy will use the 1st row in the Excel file as the header. The sheet_name parameter represents which specific sheet in the Excel file to read. If sheet_name is provided with a list of sheet names, the data node will return a dictionary with the key being the sheet name and the value being the data of the corresponding sheet. If a string is provided, the data node will read only the data of the corresponding sheet. The default value of sheet_name is None and the data node will return all sheets in the provided Excel file when reading it. When the exposed_type is given as a parameter, if the exposed_type value provided is numpy , the data node will read the Excel file to a numpy array. If the provided value is a custom class, data node will create a list of custom objects with the given custom class, each object will represent a row in the Excel file. If exposed_type is not provided, the data node will read the Excel file as a pandas DataFrame. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from taipy import Config class SaleRow : date : str nb_sales : int hist_temp_cfg = Config . configure_excel_data_node ( id = \"historical_temperature\" , path = \"path/hist_temp.xlsx\" , exposed_type = \"numpy\" ) sales_cfg = Config . configure_excel_data_node ( id = \"sale_history\" , path = \"path/sale_history.xlsx\" , sheet_name = [ \"January\" , \"February\" ], exposed_type = SaleRow ) In lines 3-5, we define a custom class SaleRow , representing an the Excel file row. In lines 7-9, we configure an Excel data node. The id identifier is \"historical_temperature\". Its scope is SCENARIO (default value), and the path is the file hist_temp.xlsx. With has_header being True, the Excel file must have a header. The sheet_name is not provided so Taipy will use the default value \"Sheet1\". In lines 10-13, we add another excel data node configuration. The id identifier is \"sale_history\", the default SCENARIO scope is used. Since we have a custom class pre-defined for this Excel file, we will provide it in the exposed_type . We also provide the list of specific sheets we want to use as the sheet_name parameter. Note To configure an Excel data node, it is equivalent to use the method Config.configure_excel_data_node()^ or the method Config.configure_data_node()^ with parameter storage_type=\"excel\" .","title":"Excel"},{"location":"manuals/core/config/data-node-config/#sql","text":"A SQLDataNode^ is a specific data node used to model Sql data. To add a new sql data node configuration, the Config.configure_sql_data_node()^ method can be used. In addition to the generic parameters described in the previous section Data node configuration , multiple parameters can be provided. The db_username parameter represents the database username that will be used by Taipy to access the database. The db_password parameter represents the database user's password that will be used by Taipy to access the database. The db_name parameter represents the name of the database. The db_engine parameter represents the engine of the database. The read_query parameter represents the SQL query that will be used by Taipy to read the data from the database. The write_table parameter represents the name of the table in the database that Taipy will be writing the data to. The db_port parameter represents the database port that will be used by Taipy to access the database. The default value of db_port is 1433. The db_host parameter represents the database host that will be used by Taipy to access the database. The default value of db_host is \"localhost\". The db_driver parameter represents the database driver that will be used by Taipy. The default value of db_driver is \"ODBC Driver 17 for SQL Server\". 1 2 3 4 5 6 7 8 9 from taipy import Config forecasts_cfg = Config . configure_sql_data_node ( id = \"forecasts\" , db_username = \"admin\" , db_password = \"password\" , db_name = \"taipy\" , db_engine = \"mssql\" , read_query = \"SELECT * from forecast_table\" , write_table = \"forecast_table\" ) In the previous example, we configure a sql data node with the id \"forecasts\". Its scope is the default value SCENARIO . The database username is \"admin\", the user's password is \"password\", the database name is \"taipy\", and the database engine is mssql (short for Microsoft SQL). The read query will be \"SELECT * from forecast_table\", and the table the data will be written to is \"forecast_table\". Note To configure a sql data node, it is equivalent to use the method Config.configure_sql_data_node()^ or the method Config.configure_data_node()^ with parameter storage_type=\"sql\" .","title":"Sql"},{"location":"manuals/core/config/data-node-config/#generic","text":"A GenericDataNode^ is a specific data node used to model generic data types where the read and the write functions are defined by the user. To add a new generic data node configuration, the Config.configure_generic_data_node()^ method can be used. In addition to the parameters described in the previous section Data node configuration , two optional parameters can be provided. The read_fct is a mandatory parameter that represents a Python function provided by the user. It will be used to read the data. More optional parameters can be passed through the read_fct_params parameter. The write_fct is a mandatory parameter representing a Python function provided by the user. It will be used to write/serialize the data. The provided function must have at least one parameter dedicated to receiving data to be written. More optional parameters can be passed through the write_fct_params parameter. The parameter read_fct_params represents the parameters that are passed to the read_fct to read/de-serialize the data. It must be a List type object. The parameter write_fct_params represents the parameters that are passed to the write_fct to write the data. It must be a List type object. 1 2 3 4 5 6 7 8 9 10 11 12 from taipy import Config def read_data (): pass def write_data ( data : Any , path : str ): pass historical_data_cfg = Config . configure_generic_data_node ( id = \"historical_data\" , read_fct = read_data , write_fct = write_data , write_fct_params = [ '../path/' ]) In this small example, we configure a generic data node with the id \"historical_data\". We provide two Python functions (previously defined) as read_fct and write_fct parameters to read and write the data. We also provided a list object for the write_fct_params with a path to let the write_fct know where to write the data. Note To configure a generic data node, it is equivalent to use the method Config.configure_generic_data_node()^ or the method Config.configure_data_node()^ with parameter storage_type=\"generic\" .","title":"Generic"},{"location":"manuals/core/config/data-node-config/#in-memory","text":"An InMemoryDataNode^ is a specific data node used to model any data in the RAM. The Config.configure_in_memory_data_node()^ method can be used to add a new in_memory data node configuration. In addition to the generic parameters described in the previous section Data node configuration , an optional parameter can be provided. If the default_data is given as a parameter, the data node is automatically written with the corresponding value (note that any python object can be used). 1 2 3 4 from taipy import Config from datetime import datetime date_cfg = Config . configure_in_memory_data_node ( id = \"date\" , default_data = datetime ( 2022 , 1 , 25 )) In this example, we configure an in_memory data node with the id \"date\", the scope is SCENARIO (default value), and a default data is provided. Warning Since the data is stored in memory, it cannot be used in a multiprocess environment. (See Job configuration for more details). Note To configure an in_memory data node, it is equivalent to use the method Config.configure_in_memory_data_node()^ or the method Config.configure_data_node()^ with parameter storage_type=\"in_memory\" . The next section introduces the task configuration .","title":"In memory"},{"location":"manuals/core/config/global-config/","text":"The GlobalAppConfig^ holds configuration fields related to the global application. Here are the (optional) configurable properties: root_folder : The path of the base folder for the taipy application, its default value is \"./taipy/\". storage_folder : The folder name used to store Taipy data, its default value is \".data/\". It is used in conjunction with the root_folder field. That means the default storage path is \"./taipy/.data/\". clean_entities_enabled : The field to activate/deactivate the clean entities feature. Its default value is ENV[TAIPY_CLEAN_ENTITIES_ENABLED]:bool meaning that the default value is read from the TAIPY_CLEAN_ENTITIES_ENABLED environment variable. If the environment variable is not set, the default value is False. Since it is risky to delete all entities on a production environment, Taipy proposes a way to activate this feature only on specific environments. That is why the default value points to an environment variable. properties : The dictionary of additional properties. Python configuration 1 2 3 4 5 6 7 from taipy import Config Config . configure_global_app ( root_folder = \".taipy_root_folder/\" , storage_folder = \".data_folder\" , clean_entities_enabled = True , version_name = \"1.0.0\" , application_name = \"my_application\" ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 4 5 6 7 [TAIPY] root_folder = \".taipy_root_folder/\" storage_folder = \".data_folder\" clean_entities_enabled = \"True:bool\" version_name = \"1.0.0\" application_name = \"my_application\" In this example, we set custom values for the root_folder , storage_folder , and clean_entities_enabled parameters. Note that most of the time the default values can be used. In lines 6-7, two custom properties are specified: a version_name and an application_name . The next section introduces the job scheduling configuration .","title":"Global config"},{"location":"manuals/core/config/job-config/","text":"The JobConfig^ allows the developer to configure the Taipy behavior for job executions. Two main modes are available in Taipy: the standalone and the airflow mode (available in the enterprise version only). Standalone \u00b6 With the standalone mode, Taipy executes the jobs in its own execution context. You can configure the standalone mode with the following config: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"standalone\" ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 [JOB] mode = \"standalone\" Note Note that if no mode is configured, the standalone mode is used. By default, Taipy executes each job one-by-one, in a synchronous manner. You can ensure this behavior with: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"standalone\" , nb_workers = 1 ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 [JOB] mode = \"standalone\" nb_of_workers = \"1:int\" Note If no value is provided in the nb_of_workers setting in the configuration, Taipy will set this value to 1. To execute the jobs in parallel, you can set the number of workers to an integer value greater than 1. Taipy will use multiple asynchronous processes, and run each job in a dedicated process. The value of the variable nb_of_workers represents the maximum number of processes spawned in parallel. For example,the following configuration allows Taipy to run at most 8 jobs in parallel: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"standalone\" , nb_workers = 8 ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 [JOB] mode = \"standalone\" nb_of_workers = \"8:int\" Using Airflow (Enterprise version only) \u00b6 With the airflow mode, Taipy delegates the job executions to an Airflow service. You can configure the airflow mode with the following config : Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"airflow\" ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 [JOB] mode = \"airflow\" Starting Airflow from Taipy \u00b6 To let Taipy start the Airflow service, you can use the following configuration: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"airflow\" , start_airflow = True ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 [JOB] mode = \"airflow\" start_airflow = \"True:bool\" By default, Airflow creates a local folder .airflow to store its dependencies. You can change this location with the airflow_folder config: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"airflow\" , airflow_folder = \"my_custom_path\" ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 [JOB] mode = \"airflow\" airflow_folder = \"my_custom_path\" Production setting Taipy starts Airflow in standalone mode. It is an Airflow development mode and not recommended for production. Using an external Airflow \u00b6 By default, Taipy runs with an external Airflow. You can specify it by setting: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"airflow\" , start_airflow = False ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 [JOB] mode = \"airflow\" start_airflow = \"False:bool\" By default, Taipy is connected to Airflow on localhost:8080 . You can change it by: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"airflow\" , start_airflow = False , hostname = \"my_remote_airflow:port\" ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 4 [JOB] mode = \"airflow\" start_airflow = \"False:bool\" hostname = \"my_remote_airflow:port\" Taipy jobs are converted in Airflow DAG through the Airflow DAG Folder. By default, this folder is .dags , but you can update it by: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"airflow\" , start_airflow = False , airflow_dags_folder = \"/my_dag_folder\" ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 4 [JOB] mode = \"airflow\" start_airflow = \"False:bool\" airflow_dags_folder = \"/my_dag_folder\" Remote Airflow The Airflow Dag generation can only be accomplished through this folder. If Taipy and Airflow are not on the same machine or if Airflow uses remote workers, you must make sure that this folder is mounted in a shared mode. Airflow can take time before loading DAGS . In order to wait for Airflow to be ready to schedule tasks, Taipy requests the scheduling several times until the request is actually accepted. Depending on your Airflow configuration, you can update the number of retries: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"airflow\" , start_airflow = False , airflow_api_retry = 10 ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 4 [JOB] mode = \"airflow\" start_airflow = \"False:bool\" airflow_api_retry = \"10:int\" Taipy authentication with Airflow is based on basic_auth . If Airflow is not started by Taipy, you should provide this configuration: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"airflow\" , start_airflow = False , airflow_user = \"user\" , airflow_password = \"pass\" ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 4 5 [JOB] mode = \"airflow\" start_airflow = \"False:bool\" airflow_user = \"user\" airflow_password = \"pass\" Security To ensure you are not exposing your company's confidential information, we recommend using environment-based configuration for airflow_user and airflow_password . The next section introduces the configuration checker .","title":"Job execution config"},{"location":"manuals/core/config/job-config/#standalone","text":"With the standalone mode, Taipy executes the jobs in its own execution context. You can configure the standalone mode with the following config: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"standalone\" ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 [JOB] mode = \"standalone\" Note Note that if no mode is configured, the standalone mode is used. By default, Taipy executes each job one-by-one, in a synchronous manner. You can ensure this behavior with: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"standalone\" , nb_workers = 1 ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 [JOB] mode = \"standalone\" nb_of_workers = \"1:int\" Note If no value is provided in the nb_of_workers setting in the configuration, Taipy will set this value to 1. To execute the jobs in parallel, you can set the number of workers to an integer value greater than 1. Taipy will use multiple asynchronous processes, and run each job in a dedicated process. The value of the variable nb_of_workers represents the maximum number of processes spawned in parallel. For example,the following configuration allows Taipy to run at most 8 jobs in parallel: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"standalone\" , nb_workers = 8 ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 [JOB] mode = \"standalone\" nb_of_workers = \"8:int\"","title":"Standalone"},{"location":"manuals/core/config/job-config/#using-airflow-enterprise-version-only","text":"With the airflow mode, Taipy delegates the job executions to an Airflow service. You can configure the airflow mode with the following config : Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"airflow\" ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 [JOB] mode = \"airflow\"","title":"Using Airflow (Enterprise version only)"},{"location":"manuals/core/config/job-config/#starting-airflow-from-taipy","text":"To let Taipy start the Airflow service, you can use the following configuration: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"airflow\" , start_airflow = True ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 [JOB] mode = \"airflow\" start_airflow = \"True:bool\" By default, Airflow creates a local folder .airflow to store its dependencies. You can change this location with the airflow_folder config: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"airflow\" , airflow_folder = \"my_custom_path\" ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 [JOB] mode = \"airflow\" airflow_folder = \"my_custom_path\" Production setting Taipy starts Airflow in standalone mode. It is an Airflow development mode and not recommended for production.","title":"Starting Airflow from Taipy"},{"location":"manuals/core/config/job-config/#using-an-external-airflow","text":"By default, Taipy runs with an external Airflow. You can specify it by setting: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"airflow\" , start_airflow = False ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 [JOB] mode = \"airflow\" start_airflow = \"False:bool\" By default, Taipy is connected to Airflow on localhost:8080 . You can change it by: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"airflow\" , start_airflow = False , hostname = \"my_remote_airflow:port\" ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 4 [JOB] mode = \"airflow\" start_airflow = \"False:bool\" hostname = \"my_remote_airflow:port\" Taipy jobs are converted in Airflow DAG through the Airflow DAG Folder. By default, this folder is .dags , but you can update it by: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"airflow\" , start_airflow = False , airflow_dags_folder = \"/my_dag_folder\" ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 4 [JOB] mode = \"airflow\" start_airflow = \"False:bool\" airflow_dags_folder = \"/my_dag_folder\" Remote Airflow The Airflow Dag generation can only be accomplished through this folder. If Taipy and Airflow are not on the same machine or if Airflow uses remote workers, you must make sure that this folder is mounted in a shared mode. Airflow can take time before loading DAGS . In order to wait for Airflow to be ready to schedule tasks, Taipy requests the scheduling several times until the request is actually accepted. Depending on your Airflow configuration, you can update the number of retries: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"airflow\" , start_airflow = False , airflow_api_retry = 10 ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 4 [JOB] mode = \"airflow\" start_airflow = \"False:bool\" airflow_api_retry = \"10:int\" Taipy authentication with Airflow is based on basic_auth . If Airflow is not started by Taipy, you should provide this configuration: Python configuration 1 2 3 from taipy import Config Config . configure_job_executions ( mode = \"airflow\" , start_airflow = False , airflow_user = \"user\" , airflow_password = \"pass\" ) TOML configuration 1 2 3 from taipy import Config Config . load ( \"config.toml\" ) config.toml 1 2 3 4 5 [JOB] mode = \"airflow\" start_airflow = \"False:bool\" airflow_user = \"user\" airflow_password = \"pass\" Security To ensure you are not exposing your company's confidential information, we recommend using environment-based configuration for airflow_user and airflow_password . The next section introduces the configuration checker .","title":"Using an external Airflow"},{"location":"manuals/core/config/pipeline-config/","text":"A pipeline configuration is necessary to instantiate a Pipeline . To create a PipelineConfig^ you can use the Config.configure_pipeline()^ method with the following parameters: id : The id of this new pipeline configuration. This id is mandatory and must be a unique and valid Python variable name. tasks : The list of tasks configurations. properties : A dictionary of additional properties. 1 2 3 4 5 6 7 8 9 10 from taipy import Config def double ( nb ): return nb * 2 input_data_node_config = Config . configure_data_node ( \"input\" , default_value = 21 ) output_data_node_config = Config . configure_data_node ( \"output\" ) task_config = Config . configure_task ( \"double_task\" , double , input_data_node_config , output_data_node_config ) pipeline_cfg = Config . configure_pipeline ( \"my_pipeline\" , [ task_config ]) In the previous code example, in line 10, we create a pipeline configuration with the id \"my_pipeline\" and made of a single task configuration task_config . 1 2 3 4 5 6 7 8 9 10 11 12 from taipy import Config def double ( nb ): return nb * 2 input_data_node_config = Config . configure_data_node ( \"input\" , default_value = 21 ) intermediate_data_node_config = Config . configure_data_node ( \"intermediate\" ) output_data_node_config = Config . configure_data_node ( \"output\" ) first_task_config = Config . configure_task ( \"first_double_task\" , double , input_data_node_config , intermediate_data_node_config ) second_task_config = Config . configure_task ( \"second_double_task\" , double , intermediate_data_node_config , output_data_node_config ) other_pipeline_cfg = Config . configure_pipeline ( \"another_pipeline\" , [ first_task_config , second_task_config ]) In this second code example, in line 12, we create a pipeline configuration with the id \"another_pipeline\" and made of the two task configuration created in lines 9 and 10 first_task_config and second_task_config . Note Note that the order of the task_config in the list does not matter. The two following lines are equivalent. pipeline_cfg = Config . configure_pipeline ( \"pipeline\" , [ first_task_config , second_task_config ]) pipeline_cfg = Config . configure_pipeline ( \"pipeline\" , [ second_task_config , first_task_config ]) The next section introduces the scenario configuration .","title":"Pipeline configs"},{"location":"manuals/core/config/scenario-config/","text":"A scenario configuration is necessary to instantiate a Scenario . To create a ScenarioConfig^ you can use the Config.configure_scenario()^ method with the following parameters: id : The id of new scenario configuration to be created. This id is mandatory and must be a unique and valid Python variable name. pipelines : The list of pipeline configs. frequency : The recurrence of the scenarios instantiated from this configuration. Based on this frequency the scenarios will be attached to the right cycles. comparators : The list of functions used to compare scenarios. A comparator function is attached to a scenario's data node configuration. During the scenario comparison, each comparator is applied to all the data nodes instantiated from the data node configuration attached to the comparator. properties : A dictionary of additional properties. Scenario configuration from pipeline configurations \u00b6 Here is a simple example assuming the pipeline configuration pipeline_config has already been created : 1 2 3 from taipy import Config scenario_config = Config . configure_scenario ( \"multiply_scenario\" , [ pipeline_config ]) In this example, we create a scenario configuration ScenarioConfig^ from a pipeline configuration already defined. Scenario configuration from task configurations \u00b6 When the scenario configuration contains only one single pipeline configuration, we can also create the ScenarioConfig^ from the task configurations directly. 1 2 3 from taipy import Config scenario_config = Config . configure_scenario_from_tasks ( \"multiply_scenario\" , [ task_config ]) Behind the scenes, a pipeline configuration is created. Its id will be the scenario configuration id with the _pipeline postfix ( multiply_scenario_pipeline in the example). Note Note that the pipeline id can be configured as an optional parameter as follows: 1 2 3 from taipy import Config scenario_config = Config . configure_scenario_from_tasks ( \"multiply_scenario\" , [ task_config ], pipeline_id = \"multiply_pipeline\" ) Scenario configuration with Cycle \u00b6 Assuming the pipeline configuration pipeline_config has already been created, here is an example of a weekly scenario configuration : 1 2 3 from taipy import Config , Frequency scenario_config = Config . configure_scenario ( \"multiply_scenario\" , [ pipeline_config ], Frequency . WEEKLY ) In this small example, we create a scenario configuration ScenarioConfig^ from a pipeline configuration with a WEEKLY frequency. When scenarios (entities) do get created using the scenario configuration above, they will be associated to a Cycle corresponding to their creation date. See documentation on Scenario and cycle management . The next section introduces the global configuration .","title":"Scenario configs"},{"location":"manuals/core/config/scenario-config/#scenario-configuration-from-pipeline-configurations","text":"Here is a simple example assuming the pipeline configuration pipeline_config has already been created : 1 2 3 from taipy import Config scenario_config = Config . configure_scenario ( \"multiply_scenario\" , [ pipeline_config ]) In this example, we create a scenario configuration ScenarioConfig^ from a pipeline configuration already defined.","title":"Scenario configuration from pipeline configurations"},{"location":"manuals/core/config/scenario-config/#scenario-configuration-from-task-configurations","text":"When the scenario configuration contains only one single pipeline configuration, we can also create the ScenarioConfig^ from the task configurations directly. 1 2 3 from taipy import Config scenario_config = Config . configure_scenario_from_tasks ( \"multiply_scenario\" , [ task_config ]) Behind the scenes, a pipeline configuration is created. Its id will be the scenario configuration id with the _pipeline postfix ( multiply_scenario_pipeline in the example). Note Note that the pipeline id can be configured as an optional parameter as follows: 1 2 3 from taipy import Config scenario_config = Config . configure_scenario_from_tasks ( \"multiply_scenario\" , [ task_config ], pipeline_id = \"multiply_pipeline\" )","title":"Scenario configuration from task configurations"},{"location":"manuals/core/config/scenario-config/#scenario-configuration-with-cycle","text":"Assuming the pipeline configuration pipeline_config has already been created, here is an example of a weekly scenario configuration : 1 2 3 from taipy import Config , Frequency scenario_config = Config . configure_scenario ( \"multiply_scenario\" , [ pipeline_config ], Frequency . WEEKLY ) In this small example, we create a scenario configuration ScenarioConfig^ from a pipeline configuration with a WEEKLY frequency. When scenarios (entities) do get created using the scenario configuration above, they will be associated to a Cycle corresponding to their creation date. See documentation on Scenario and cycle management . The next section introduces the global configuration .","title":"Scenario configuration with Cycle"},{"location":"manuals/core/config/task-config/","text":"A task configuration is necessary to instantiate a Task . To create a TaskConfig^ you can use the taipy.configure_task()^ method with the following parameters: id : The id of the task configuration to be created. This id is mandatory and must be a unique and valid Python variable name. function : The function to execute. inputs : The input data nodes referring the parameter(s) data of the function to be executed. outputs : The output data nodes referring the result(s) data of the function to be executed. Here is a simple example: 1 2 3 4 5 6 7 8 9 from taipy import Config def double ( nb ): return nb * 2 input_data_node_cfg = Config . configure_data_node ( \"input\" , default_value = 21 ) output_data_node_config = Config . configure_data_node ( \"output\" ) double_task_cfg = Config . configure_task ( \"double_task\" , double , input_data_node_config , output_data_node_config ) In the example above, we created a TaskConfig^ named double_task_cfg . In lines 3-4, we define a function that we want to use in a Task instantiated from the task config. It takes a single parameter and return a single value. In lines 6-7, two data node configurations are created. They will be used respectively as the argument of the function double and as the result of the function double. Finally, on line 9, we create the task configuration with the id 'double_task' that represents the function 'double' that expects an 'input' data node as an input parameter and returns an 'output' data node. Because a Task can have several inputs and outputs, taipy.configure_task()^ can receive lists of DataNodeConfig^ objects. 1 2 3 4 5 6 7 8 9 10 11 12 from taipy import Config def multiply_and_add ( nb1 , nb2 ): return nb1 * nb2 , nb1 + nb2 nb_1_cfg = Config . configure_data_node ( \"nb_1\" , default_value = 21 ) nb_2_cfg = Config . configure_data_node ( \"nb_2\" , default_value = 2 ) multiplication_cfg = Config . configure_data_node ( \"multiplication\" ) addition_cfg = Config . configure_data_node ( \"addition\" ) task_cfg = Config . configure_task ( \"foo\" , multiply_and_add , [ nb_1_cfg , nb_2_cfg ], [ multiplication_cfg , addition_cfg ]) In lines 3-4, we define a function with two parameters and two return values. In lines 6-7, two data node configurations are created. They will be used as the function arguments. In line 9-10, two data node are configured. They will be used as the function results. Finally, in line 12, we create the task configuration with the id 'foo' representing the function 'multiply_and_add'. It expects two 'input' data nodes and two 'output' data nodes. The next section introduces the pipeline configuration .","title":"Task configs"},{"location":"manuals/core/entities/","text":"Taipy's Core entities \u00b6 This documentation focuses on providing necessary information to use the Taipy Core entities, and in particular the capabilities related to scenario management. It is assumed that the reader already knows the Taipy Core concepts described in a previous documentation. It is also assumed in the next sections that my_config.py module contains a Taipy configuration already implemented. This configuration corresponds to the design displayed in the following picture. Please refer to the configuration documentation to have information on how to configure a Taipy application. The next section presents the scenario creation .","title":"Taipy's Core entities"},{"location":"manuals/core/entities/#taipys-core-entities","text":"This documentation focuses on providing necessary information to use the Taipy Core entities, and in particular the capabilities related to scenario management. It is assumed that the reader already knows the Taipy Core concepts described in a previous documentation. It is also assumed in the next sections that my_config.py module contains a Taipy configuration already implemented. This configuration corresponds to the design displayed in the following picture. Please refer to the configuration documentation to have information on how to configure a Taipy application. The next section presents the scenario creation .","title":"Taipy's Core entities"},{"location":"manuals/core/entities/data-node-mgt/","text":"In the following, it is assumed that my_config.py module contains a Taipy configuration already implemented. Data nodes get created when scenarios or pipelines are created. Please refer to the Entities' creation section for more details. Data node attributes \u00b6 A DataNode^ entity is identified by a unique identifier id that Taipy generates. A data node also holds various properties and attributes accessible through the entity: config_id : The id of the data node config. scope : The scope of this data node (scenario, pipeline, etc.). id : The unique identifier of this data node. name : The user-readable name of the data node. parent_id : The identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date : The date and time of the last edition. job_ids : The ordered list of jobs that have written on this data node. validity_period : The validity period of a cacheable data node. If validity_period is set to None, the data node is always up-to-date. edition_in_progress : The flag that signals if a task is currently computing this data node. properties : The dictionary of additional arguments. Get data node \u00b6 The first method to get a data node is from its id using the taipy.get()^ method: Example 1 2 3 4 5 6 7 8 9 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) data_node = scenario . sales_history data_node_retrieved = scenario . sales_history data_node = tp . get ( data_node . id ) # data_node == data_node_retrieved The data nodes that are part of a scenario , pipeline or task can be directly accessed as attributes: Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import taipy as tp import my_config # Creating a scenario from a config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) # Access the data node 'sales_history' from the scenario scenario . sales_history # Access the pipeline 'sales' from the scenario and then access the data node 'sales_history' from the pipeline pipeline = scenario . sales pipeline . sales_history # Access the task 'training' from the pipeline and then access the data node 'sales_history' from the task task = pipeline . training task . sales_history All the data nodes can be retrieved using the method taipy.get_data_nodes()^ which returns a list of all existing data nodes. Example 1 2 3 4 5 6 import taipy as tp # Retrieve all data nodes data_nodes = tp . get_data_nodes () data_nodes #[DataNode 1, DataNode 2, ..., DataNode N] Read data node \u00b6 To read the content of a data node you can use the DataNode.read()^ method. The read method returns the data stored on the data node according to the type of data node: Example 1 2 3 4 5 6 7 8 9 10 11 import taipy as tp import my_config # Creating a scenario from a config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) # Retrieve a data node data_node = scenario . sales_history # Returns the content stored on the data node data_node . read () It is also possible to partially read the contents of data nodes, which comes in handy when dealing with large amounts of data. This can be achieved by providing an operator, a Tuple of ( field_name , value , comparison_operator ), or a list of operators to the DataNode.filter()^ method: 1 data_node . filter ([( \"field_name\" , 14 , Operator . EQUAL ), ( \"field_name\" , 10 , Operator . EQUAL )], JoinOperator . OR )) If a list of operators is provided, it is necessary to provide a join operator that will be used to combine the filtered results from the operators. It is also possible to use pandas style filtering: 1 2 temp_data = data_node [ \"field_name\" ] temp_data [( temp_data == 14 ) | ( temp_data == 10 )] Write data node \u00b6 To write some data on the data node, like the output of a task, you can use the DataNode.write()^ method. The method takes a data object (string, dictionary, lists, numpy arrays, pandas dataframes, etc.) as a parameter and writes it on the data node: Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import taipy as tp import my_config # Creating a scenario from a config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) # Retrieve a data node data_node = scenario . sales_history data = [{ \"product\" : \"a\" , \"qty\" : \"2\" }, { \"product\" : \"b\" , \"qty\" : \"4\" }] # Writes the dictionary on the data node data_node . write ( data ) # returns the new data stored on the data node data_retrieved = data_node . read () The next section shows the scheduling and job execution .","title":"Data node management"},{"location":"manuals/core/entities/data-node-mgt/#data-node-attributes","text":"A DataNode^ entity is identified by a unique identifier id that Taipy generates. A data node also holds various properties and attributes accessible through the entity: config_id : The id of the data node config. scope : The scope of this data node (scenario, pipeline, etc.). id : The unique identifier of this data node. name : The user-readable name of the data node. parent_id : The identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date : The date and time of the last edition. job_ids : The ordered list of jobs that have written on this data node. validity_period : The validity period of a cacheable data node. If validity_period is set to None, the data node is always up-to-date. edition_in_progress : The flag that signals if a task is currently computing this data node. properties : The dictionary of additional arguments.","title":"Data node attributes"},{"location":"manuals/core/entities/data-node-mgt/#get-data-node","text":"The first method to get a data node is from its id using the taipy.get()^ method: Example 1 2 3 4 5 6 7 8 9 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) data_node = scenario . sales_history data_node_retrieved = scenario . sales_history data_node = tp . get ( data_node . id ) # data_node == data_node_retrieved The data nodes that are part of a scenario , pipeline or task can be directly accessed as attributes: Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import taipy as tp import my_config # Creating a scenario from a config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) # Access the data node 'sales_history' from the scenario scenario . sales_history # Access the pipeline 'sales' from the scenario and then access the data node 'sales_history' from the pipeline pipeline = scenario . sales pipeline . sales_history # Access the task 'training' from the pipeline and then access the data node 'sales_history' from the task task = pipeline . training task . sales_history All the data nodes can be retrieved using the method taipy.get_data_nodes()^ which returns a list of all existing data nodes. Example 1 2 3 4 5 6 import taipy as tp # Retrieve all data nodes data_nodes = tp . get_data_nodes () data_nodes #[DataNode 1, DataNode 2, ..., DataNode N]","title":"Get data node"},{"location":"manuals/core/entities/data-node-mgt/#read-data-node","text":"To read the content of a data node you can use the DataNode.read()^ method. The read method returns the data stored on the data node according to the type of data node: Example 1 2 3 4 5 6 7 8 9 10 11 import taipy as tp import my_config # Creating a scenario from a config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) # Retrieve a data node data_node = scenario . sales_history # Returns the content stored on the data node data_node . read () It is also possible to partially read the contents of data nodes, which comes in handy when dealing with large amounts of data. This can be achieved by providing an operator, a Tuple of ( field_name , value , comparison_operator ), or a list of operators to the DataNode.filter()^ method: 1 data_node . filter ([( \"field_name\" , 14 , Operator . EQUAL ), ( \"field_name\" , 10 , Operator . EQUAL )], JoinOperator . OR )) If a list of operators is provided, it is necessary to provide a join operator that will be used to combine the filtered results from the operators. It is also possible to use pandas style filtering: 1 2 temp_data = data_node [ \"field_name\" ] temp_data [( temp_data == 14 ) | ( temp_data == 10 )]","title":"Read data node"},{"location":"manuals/core/entities/data-node-mgt/#write-data-node","text":"To write some data on the data node, like the output of a task, you can use the DataNode.write()^ method. The method takes a data object (string, dictionary, lists, numpy arrays, pandas dataframes, etc.) as a parameter and writes it on the data node: Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import taipy as tp import my_config # Creating a scenario from a config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) # Retrieve a data node data_node = scenario . sales_history data = [{ \"product\" : \"a\" , \"qty\" : \"2\" }, { \"product\" : \"b\" , \"qty\" : \"4\" }] # Writes the dictionary on the data node data_node . write ( data ) # returns the new data stored on the data node data_retrieved = data_node . read () The next section shows the scheduling and job execution .","title":"Write data node"},{"location":"manuals/core/entities/pipeline-mgt/","text":"The Entities' creation section provided documentation on Pipeline^ creation. Now that we know how to create a new Pipeline^ , this section focuses on describing the pipeline's attributes and utility methods for using pipelines. In the following, it is assumed that my_config.py module contains a Taipy configuration already implemented. Pipeline attributes \u00b6 The pipeline creation method returns a Pipeline^ entity. It is identified by a unique identifier id that is generated by Taipy. A pipeline also holds various properties that are accessible as an attribute of the pipeline: config_id : The id of the pipeline configuration. subscribers : The list of callbacks representing the subscribers. properties : The complete dictionary of the pipeline properties. It includes a copy of the properties of the pipeline configuration, in addition to the properties provided at the creation and at runtime. tasks : The dictionary holding the various tasks of the pipeline. The key corresponds to the config_id of the task while the value is the task itself. parent_id : The identifier of the parent, which can be a pipeline, scenario, cycle or None. Each property of the properties dictionary is also directly exposed as an attribute. Each nested entity is also exposed as an attribute of the pipeline. the attribute name corresponds to the config_id of the nested entity. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import taipy as tp from datetime import datetime import my_config pipeline = tp . create_pipeline ( my_config . sales_pipeline_cfg , name = \"Pipeline for sales prediction\" ) # The config_id is an attribute of the pipeline and equals \"pipeline_configuration\" pipeline . config_id # There was no subscription, so subscribers is an empty list pipeline . subscribers # [] # The properties dictionary equals {\"name\": \"Pipeline for sales prediction\"}. It contains all the properties, # including the `name` provided at the creation pipeline . properties # {\"name\": \"Pipeline for sales prediction\"} # The `name` property is also exposed directly as an attribute. It equals \"Pipeline for sales prediction\" pipeline . name # The training task entity is exposed as an attribute of the pipeline training_task = pipeline . training # The predicting task entity as well predicting_task = pipeline . predicting # The data nodes are also exposed as attributes of the pipeline. current_month_data_node = pipeline . current_month Get pipeline by id \u00b6 The method to get a pipeline is from its id by using the taipy.get()^ method : 1 2 3 4 5 6 import taipy as tp import my_config pipeline = tp . create_pipeline ( my_config . sales_pipeline_cfg ) pipeline_retrieved = tp . get ( pipeline . id ) pipeline == pipeline_retrieved Here the two variables pipeline and pipeline_retrieved are equal. Get pipeline by config id \u00b6 A pipeline can also be retrieved from a scenario by accessing the pipeline's config_id of the scenario. 1 2 3 4 5 6 7 8 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) # Get the pipelines by config id sales_pipeline = scenario . sales production_pipeline = scenario . production Get all pipelines \u00b6 All the pipelines can be retrieved using the method taipy.get_pipelines()^ . This method returns the list of all existing pipelines. Delete a pipeline \u00b6 A pipeline can be deleted by using taipy.delete()^ which takes the pipeline id as a parameter. The deletion is also propagated to the nested tasks, data nodes, and jobs if they are not shared with any other pipeline. The next sections show the task management .","title":"Pipeline management"},{"location":"manuals/core/entities/pipeline-mgt/#pipeline-attributes","text":"The pipeline creation method returns a Pipeline^ entity. It is identified by a unique identifier id that is generated by Taipy. A pipeline also holds various properties that are accessible as an attribute of the pipeline: config_id : The id of the pipeline configuration. subscribers : The list of callbacks representing the subscribers. properties : The complete dictionary of the pipeline properties. It includes a copy of the properties of the pipeline configuration, in addition to the properties provided at the creation and at runtime. tasks : The dictionary holding the various tasks of the pipeline. The key corresponds to the config_id of the task while the value is the task itself. parent_id : The identifier of the parent, which can be a pipeline, scenario, cycle or None. Each property of the properties dictionary is also directly exposed as an attribute. Each nested entity is also exposed as an attribute of the pipeline. the attribute name corresponds to the config_id of the nested entity. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import taipy as tp from datetime import datetime import my_config pipeline = tp . create_pipeline ( my_config . sales_pipeline_cfg , name = \"Pipeline for sales prediction\" ) # The config_id is an attribute of the pipeline and equals \"pipeline_configuration\" pipeline . config_id # There was no subscription, so subscribers is an empty list pipeline . subscribers # [] # The properties dictionary equals {\"name\": \"Pipeline for sales prediction\"}. It contains all the properties, # including the `name` provided at the creation pipeline . properties # {\"name\": \"Pipeline for sales prediction\"} # The `name` property is also exposed directly as an attribute. It equals \"Pipeline for sales prediction\" pipeline . name # The training task entity is exposed as an attribute of the pipeline training_task = pipeline . training # The predicting task entity as well predicting_task = pipeline . predicting # The data nodes are also exposed as attributes of the pipeline. current_month_data_node = pipeline . current_month","title":"Pipeline attributes"},{"location":"manuals/core/entities/pipeline-mgt/#get-pipeline-by-id","text":"The method to get a pipeline is from its id by using the taipy.get()^ method : 1 2 3 4 5 6 import taipy as tp import my_config pipeline = tp . create_pipeline ( my_config . sales_pipeline_cfg ) pipeline_retrieved = tp . get ( pipeline . id ) pipeline == pipeline_retrieved Here the two variables pipeline and pipeline_retrieved are equal.","title":"Get pipeline by id"},{"location":"manuals/core/entities/pipeline-mgt/#get-pipeline-by-config-id","text":"A pipeline can also be retrieved from a scenario by accessing the pipeline's config_id of the scenario. 1 2 3 4 5 6 7 8 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) # Get the pipelines by config id sales_pipeline = scenario . sales production_pipeline = scenario . production","title":"Get pipeline by config id"},{"location":"manuals/core/entities/pipeline-mgt/#get-all-pipelines","text":"All the pipelines can be retrieved using the method taipy.get_pipelines()^ . This method returns the list of all existing pipelines.","title":"Get all pipelines"},{"location":"manuals/core/entities/pipeline-mgt/#delete-a-pipeline","text":"A pipeline can be deleted by using taipy.delete()^ which takes the pipeline id as a parameter. The deletion is also propagated to the nested tasks, data nodes, and jobs if they are not shared with any other pipeline. The next sections show the task management .","title":"Delete a pipeline"},{"location":"manuals/core/entities/scenario-creation/","text":"Scenario creation \u00b6 Scenarios are the most used entities in Taipy. The taipy.create_scenario()^ function can be used to create a new scenario. This function creates and returns a new scenario from the scenario configuration provided as a parameter. The scenario's creation also triggers the creation of the related entities that do not exist yet. Indeed, if the scenario has a frequency and there isn\u2019t any corresponding cycle, the cycle will be created. Similarly, the pipelines, tasks, and data nodes nested in the scenario are created if they do not exist yet. The simplest way of creating a scenario is to call the taipy.create_scenario()^ method providing the scenario configuration as a parameter: Simple scenario creation without optional parameters 1 2 3 4 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) my_config.py module Below is the python configuration imported in the example. my_config.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from datetime import datetime from my_functions import plan , predict , train from taipy import Config , Frequency , Scope # Configure all six data nodes sales_history_cfg = Config . configure_csv_data_node ( id = \"sales_history\" , scope = Scope . GLOBAL , path = \"my/file/path.csv\" ) trained_model_cfg = Config . configure_data_node ( id = \"trained_model\" , scope = Scope . CYCLE ) current_month_cfg = Config . configure_data_node ( id = \"current_month\" , scope = Scope . CYCLE , default_data = datetime ( 2020 , 1 , 1 )) sales_predictions_cfg = Config . configure_data_node ( id = \"sales_predictions\" , scope = Scope . CYCLE ) capacity_cfg = Config . configure_data_node ( id = \"capacity\" ) production_orders_cfg = Config . configure_sql_data_node ( id = \"production_orders\" , db_username = \"admin\" , db_password = \"ENV[PWD]\" , db_name = \"production_planning\" , db_engine = \"mssql\" , read_query = \"SELECT * from production_order\" , write_table = \"production_order\" ) # Configure the three tasks training_cfg = Config . configure_task ( \"training\" , train , sales_history_cfg , [ trained_model_cfg ]) predicting_cfg = Config . configure_task ( id = \"predicting\" , function = predict , input = [ trained_model_cfg , current_month_cfg ], output = sales_predictions_cfg ) planning_cfg = Config . configure_task ( id = \"planning\" , function = plan , input = [ sales_predictions_cfg , capacity_cfg ], output = [ production_orders_cfg ]) # Configure the two pipelines sales_pipeline_cfg = Config . configure_pipeline ( id = \"sales\" , task_configs = [ training_cfg , predicting_cfg ]) production_pipeline_cfg = Config . configure_pipeline ( id = \"production\" , task_configs = [ planning_cfg ]) # Configure the scenario monthly_scenario_cfg = Config . configure_scenario ( id = \"scenario_configuration\" , pipeline_configs = [ sales_pipeline_cfg , production_pipeline_cfg ], frequency = Frequency . MONTHLY ) Three parameters can be given to the scenario creation method : config is a mandatory parameter of type ScenarioConfig^ . It corresponds to a scenario configuration (created in the module my_config.py) creation_date is an optional parameter of type datetime.datetime. It corresponds to the creation date of the scenario. If the parameter is not provided, the current date-time is used by default. The name parameter is optional as well. Any string can be provided as a name . It can be used to display the scenario in a user interface. Example Scenario creation with parameters Using the my_config.py module, here is an example of how to create a scenario. 1 2 3 4 5 6 7 import taipy as tp import my_config from datetime import datetime scenario = tp . create_scenario ( config = my_config . monthly_scenario_cfg , creation_date = datetime ( 2022 , 1 , 1 ), name = \"Scenario for January\" ) In this small example, one scenario for January 2022 is instantiated. A creation_date and a name are provided. Note that the monthly_scenario_cfg has set the frequency to monthly. Therefore, scenario will be assigned to the cycle corresponding to its creation date (ie the month of January). Behind the scene, the other related entities are also created: The January cycle, since the monthly_scenario_cfg has set the frequency to MONTHLY. So scenario will be assigned to the cycle corresponding to its creation date (ie the month of January). Two sales and production pipelines, Three tasks (training, predicting, planning), And six data nodes (sales_history, trained_model, current_month, sales_predictions, capacity, production_orders). my_config.py module Below is the python configuration imported in the example. my_config.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from datetime import datetime from my_functions import plan , predict , train from taipy import Config , Frequency , Scope # Configure all six data nodes sales_history_cfg = Config . configure_csv_data_node ( id = \"sales_history\" , scope = Scope . GLOBAL , path = \"my/file/path.csv\" ) trained_model_cfg = Config . configure_data_node ( id = \"trained_model\" , scope = Scope . CYCLE ) current_month_cfg = Config . configure_data_node ( id = \"current_month\" , scope = Scope . CYCLE , default_data = datetime ( 2020 , 1 , 1 )) sales_predictions_cfg = Config . configure_data_node ( id = \"sales_predictions\" , scope = Scope . CYCLE ) capacity_cfg = Config . configure_data_node ( id = \"capacity\" ) production_orders_cfg = Config . configure_sql_data_node ( id = \"production_orders\" , db_username = \"admin\" , db_password = \"ENV[PWD]\" , db_name = \"production_planning\" , db_engine = \"mssql\" , read_query = \"SELECT * from production_order\" , write_table = \"production_order\" ) # Configure the three tasks training_cfg = Config . configure_task ( \"training\" , train , sales_history_cfg , [ trained_model_cfg ]) predicting_cfg = Config . configure_task ( id = \"predicting\" , function = predict , input = [ trained_model_cfg , current_month_cfg ], output = sales_predictions_cfg ) planning_cfg = Config . configure_task ( id = \"planning\" , function = plan , input = [ sales_predictions_cfg , capacity_cfg ], output = [ production_orders_cfg ]) # Configure the two pipelines sales_pipeline_cfg = Config . configure_pipeline ( id = \"sales\" , task_configs = [ training_cfg , predicting_cfg ]) production_pipeline_cfg = Config . configure_pipeline ( id = \"production\" , task_configs = [ planning_cfg ]) # Configure the scenario monthly_scenario_cfg = Config . configure_scenario ( id = \"scenario_configuration\" , pipeline_configs = [ sales_pipeline_cfg , production_pipeline_cfg ], frequency = Frequency . MONTHLY ) Pipeline creation \u00b6 Pipelines can be created separately from scenarios using taipy.create_pipeline()^ function. This function creates and returns a new pipeline from the pipeline configuration provided as a parameter. The pipeline's creation also triggers the creation of the related entities that do not exist yet. Indeed, tasks and data nodes nested in the pipeline are created if they do not exist yet. Simple pipeline creation 1 2 3 4 import taipy as tp import my_config pipeline = tp . create_pipeline ( my_config . sales_pipeline_cfg ) my_config.py module Below is the python configuration imported in the example. my_config.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from datetime import datetime from my_functions import plan , predict , train from taipy import Config , Frequency , Scope # Configure all six data nodes sales_history_cfg = Config . configure_csv_data_node ( id = \"sales_history\" , scope = Scope . GLOBAL , path = \"my/file/path.csv\" ) trained_model_cfg = Config . configure_data_node ( id = \"trained_model\" , scope = Scope . CYCLE ) current_month_cfg = Config . configure_data_node ( id = \"current_month\" , scope = Scope . CYCLE , default_data = datetime ( 2020 , 1 , 1 )) sales_predictions_cfg = Config . configure_data_node ( id = \"sales_predictions\" , scope = Scope . CYCLE ) capacity_cfg = Config . configure_data_node ( id = \"capacity\" ) production_orders_cfg = Config . configure_sql_data_node ( id = \"production_orders\" , db_username = \"admin\" , db_password = \"ENV[PWD]\" , db_name = \"production_planning\" , db_engine = \"mssql\" , read_query = \"SELECT * from production_order\" , write_table = \"production_order\" ) # Configure the three tasks training_cfg = Config . configure_task ( \"training\" , train , sales_history_cfg , [ trained_model_cfg ]) predicting_cfg = Config . configure_task ( id = \"predicting\" , function = predict , input = [ trained_model_cfg , current_month_cfg ], output = sales_predictions_cfg ) planning_cfg = Config . configure_task ( id = \"planning\" , function = plan , input = [ sales_predictions_cfg , capacity_cfg ], output = [ production_orders_cfg ]) # Configure the two pipelines sales_pipeline_cfg = Config . configure_pipeline ( id = \"sales\" , task_configs = [ training_cfg , predicting_cfg ]) production_pipeline_cfg = Config . configure_pipeline ( id = \"production\" , task_configs = [ planning_cfg ]) # Configure the scenario monthly_scenario_cfg = Config . configure_scenario ( id = \"scenario_configuration\" , pipeline_configs = [ sales_pipeline_cfg , production_pipeline_cfg ], frequency = Frequency . MONTHLY ) The next section presents the scenario and cycle management .","title":"Entities' creation"},{"location":"manuals/core/entities/scenario-creation/#scenario-creation","text":"Scenarios are the most used entities in Taipy. The taipy.create_scenario()^ function can be used to create a new scenario. This function creates and returns a new scenario from the scenario configuration provided as a parameter. The scenario's creation also triggers the creation of the related entities that do not exist yet. Indeed, if the scenario has a frequency and there isn\u2019t any corresponding cycle, the cycle will be created. Similarly, the pipelines, tasks, and data nodes nested in the scenario are created if they do not exist yet. The simplest way of creating a scenario is to call the taipy.create_scenario()^ method providing the scenario configuration as a parameter: Simple scenario creation without optional parameters 1 2 3 4 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) my_config.py module Below is the python configuration imported in the example. my_config.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from datetime import datetime from my_functions import plan , predict , train from taipy import Config , Frequency , Scope # Configure all six data nodes sales_history_cfg = Config . configure_csv_data_node ( id = \"sales_history\" , scope = Scope . GLOBAL , path = \"my/file/path.csv\" ) trained_model_cfg = Config . configure_data_node ( id = \"trained_model\" , scope = Scope . CYCLE ) current_month_cfg = Config . configure_data_node ( id = \"current_month\" , scope = Scope . CYCLE , default_data = datetime ( 2020 , 1 , 1 )) sales_predictions_cfg = Config . configure_data_node ( id = \"sales_predictions\" , scope = Scope . CYCLE ) capacity_cfg = Config . configure_data_node ( id = \"capacity\" ) production_orders_cfg = Config . configure_sql_data_node ( id = \"production_orders\" , db_username = \"admin\" , db_password = \"ENV[PWD]\" , db_name = \"production_planning\" , db_engine = \"mssql\" , read_query = \"SELECT * from production_order\" , write_table = \"production_order\" ) # Configure the three tasks training_cfg = Config . configure_task ( \"training\" , train , sales_history_cfg , [ trained_model_cfg ]) predicting_cfg = Config . configure_task ( id = \"predicting\" , function = predict , input = [ trained_model_cfg , current_month_cfg ], output = sales_predictions_cfg ) planning_cfg = Config . configure_task ( id = \"planning\" , function = plan , input = [ sales_predictions_cfg , capacity_cfg ], output = [ production_orders_cfg ]) # Configure the two pipelines sales_pipeline_cfg = Config . configure_pipeline ( id = \"sales\" , task_configs = [ training_cfg , predicting_cfg ]) production_pipeline_cfg = Config . configure_pipeline ( id = \"production\" , task_configs = [ planning_cfg ]) # Configure the scenario monthly_scenario_cfg = Config . configure_scenario ( id = \"scenario_configuration\" , pipeline_configs = [ sales_pipeline_cfg , production_pipeline_cfg ], frequency = Frequency . MONTHLY ) Three parameters can be given to the scenario creation method : config is a mandatory parameter of type ScenarioConfig^ . It corresponds to a scenario configuration (created in the module my_config.py) creation_date is an optional parameter of type datetime.datetime. It corresponds to the creation date of the scenario. If the parameter is not provided, the current date-time is used by default. The name parameter is optional as well. Any string can be provided as a name . It can be used to display the scenario in a user interface. Example Scenario creation with parameters Using the my_config.py module, here is an example of how to create a scenario. 1 2 3 4 5 6 7 import taipy as tp import my_config from datetime import datetime scenario = tp . create_scenario ( config = my_config . monthly_scenario_cfg , creation_date = datetime ( 2022 , 1 , 1 ), name = \"Scenario for January\" ) In this small example, one scenario for January 2022 is instantiated. A creation_date and a name are provided. Note that the monthly_scenario_cfg has set the frequency to monthly. Therefore, scenario will be assigned to the cycle corresponding to its creation date (ie the month of January). Behind the scene, the other related entities are also created: The January cycle, since the monthly_scenario_cfg has set the frequency to MONTHLY. So scenario will be assigned to the cycle corresponding to its creation date (ie the month of January). Two sales and production pipelines, Three tasks (training, predicting, planning), And six data nodes (sales_history, trained_model, current_month, sales_predictions, capacity, production_orders). my_config.py module Below is the python configuration imported in the example. my_config.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from datetime import datetime from my_functions import plan , predict , train from taipy import Config , Frequency , Scope # Configure all six data nodes sales_history_cfg = Config . configure_csv_data_node ( id = \"sales_history\" , scope = Scope . GLOBAL , path = \"my/file/path.csv\" ) trained_model_cfg = Config . configure_data_node ( id = \"trained_model\" , scope = Scope . CYCLE ) current_month_cfg = Config . configure_data_node ( id = \"current_month\" , scope = Scope . CYCLE , default_data = datetime ( 2020 , 1 , 1 )) sales_predictions_cfg = Config . configure_data_node ( id = \"sales_predictions\" , scope = Scope . CYCLE ) capacity_cfg = Config . configure_data_node ( id = \"capacity\" ) production_orders_cfg = Config . configure_sql_data_node ( id = \"production_orders\" , db_username = \"admin\" , db_password = \"ENV[PWD]\" , db_name = \"production_planning\" , db_engine = \"mssql\" , read_query = \"SELECT * from production_order\" , write_table = \"production_order\" ) # Configure the three tasks training_cfg = Config . configure_task ( \"training\" , train , sales_history_cfg , [ trained_model_cfg ]) predicting_cfg = Config . configure_task ( id = \"predicting\" , function = predict , input = [ trained_model_cfg , current_month_cfg ], output = sales_predictions_cfg ) planning_cfg = Config . configure_task ( id = \"planning\" , function = plan , input = [ sales_predictions_cfg , capacity_cfg ], output = [ production_orders_cfg ]) # Configure the two pipelines sales_pipeline_cfg = Config . configure_pipeline ( id = \"sales\" , task_configs = [ training_cfg , predicting_cfg ]) production_pipeline_cfg = Config . configure_pipeline ( id = \"production\" , task_configs = [ planning_cfg ]) # Configure the scenario monthly_scenario_cfg = Config . configure_scenario ( id = \"scenario_configuration\" , pipeline_configs = [ sales_pipeline_cfg , production_pipeline_cfg ], frequency = Frequency . MONTHLY )","title":"Scenario creation"},{"location":"manuals/core/entities/scenario-creation/#pipeline-creation","text":"Pipelines can be created separately from scenarios using taipy.create_pipeline()^ function. This function creates and returns a new pipeline from the pipeline configuration provided as a parameter. The pipeline's creation also triggers the creation of the related entities that do not exist yet. Indeed, tasks and data nodes nested in the pipeline are created if they do not exist yet. Simple pipeline creation 1 2 3 4 import taipy as tp import my_config pipeline = tp . create_pipeline ( my_config . sales_pipeline_cfg ) my_config.py module Below is the python configuration imported in the example. my_config.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from datetime import datetime from my_functions import plan , predict , train from taipy import Config , Frequency , Scope # Configure all six data nodes sales_history_cfg = Config . configure_csv_data_node ( id = \"sales_history\" , scope = Scope . GLOBAL , path = \"my/file/path.csv\" ) trained_model_cfg = Config . configure_data_node ( id = \"trained_model\" , scope = Scope . CYCLE ) current_month_cfg = Config . configure_data_node ( id = \"current_month\" , scope = Scope . CYCLE , default_data = datetime ( 2020 , 1 , 1 )) sales_predictions_cfg = Config . configure_data_node ( id = \"sales_predictions\" , scope = Scope . CYCLE ) capacity_cfg = Config . configure_data_node ( id = \"capacity\" ) production_orders_cfg = Config . configure_sql_data_node ( id = \"production_orders\" , db_username = \"admin\" , db_password = \"ENV[PWD]\" , db_name = \"production_planning\" , db_engine = \"mssql\" , read_query = \"SELECT * from production_order\" , write_table = \"production_order\" ) # Configure the three tasks training_cfg = Config . configure_task ( \"training\" , train , sales_history_cfg , [ trained_model_cfg ]) predicting_cfg = Config . configure_task ( id = \"predicting\" , function = predict , input = [ trained_model_cfg , current_month_cfg ], output = sales_predictions_cfg ) planning_cfg = Config . configure_task ( id = \"planning\" , function = plan , input = [ sales_predictions_cfg , capacity_cfg ], output = [ production_orders_cfg ]) # Configure the two pipelines sales_pipeline_cfg = Config . configure_pipeline ( id = \"sales\" , task_configs = [ training_cfg , predicting_cfg ]) production_pipeline_cfg = Config . configure_pipeline ( id = \"production\" , task_configs = [ planning_cfg ]) # Configure the scenario monthly_scenario_cfg = Config . configure_scenario ( id = \"scenario_configuration\" , pipeline_configs = [ sales_pipeline_cfg , production_pipeline_cfg ], frequency = Frequency . MONTHLY ) The next section presents the scenario and cycle management .","title":"Pipeline creation"},{"location":"manuals/core/entities/scenario-cycle-mgt/","text":"The previous section provided documentation on Scenario^ (and Pipeline^ ) creation. Now that we know how to create a new Scenario^ , this section will describe the scenario's attributes and the various utility methods. In the following, it is assumed that my_config.py module contains a Taipy configuration already implemented. Scenario attributes \u00b6 The scenario creation method returns a Scenario^ entity. It is identified by a unique identifier id that was generated by Taipy. A scenario also holds various properties, each accessible as an attribute of the scenario: config_id is the id of the scenario configuration. creation_date corresponds to the date-time provided at the creation. is_primary is True if it is a primary scenario. False otherwise. subscribers is the list of callbacks representing the subscribers. properties is the complete dictionary of the scenario properties. It includes a copy of the properties of the scenario configuration, in addition to the properties provided at the creation and at runtime. cycle is the cycle of the scenario. pipelines is a dictionary holding the various pipelines of the scenario. The key corresponds to the pipeline's config_id (while the value is the pipeline itself). Each property of the properties dictionary is also directly exposed as an attribute. Each nested entity is also exposed as an attribute of the scenario. The attribute name corresponds to the config_id of the nested entity. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import taipy as tp from datetime import datetime import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg , creation_date = datetime ( 2022 , 1 , 1 ), name = \"Scenario for January\" ) # the config_name is an attribute of the scenario and equals \"scenario_configuration\" scenario . config_name # The creation date is the date-time provided at the creation. It equals datetime(2022, 1, 1) scenario . creation_date # The is_primary property equals `True` since it is the only scenario of the cycle. scenario . is_primary # There was no subscription, so subscribers is an empty list scenario . subscribers # [] # The properties' dictionary equals {\"name\": \"Scenario for January\"}. It contains all the properties, # including the `name` provided at the creation scenario . properties # {\"name\": \"Scenario for January\"} # The `name` property is also exposed directly as an attribute. It equals \"Scenario for January\" scenario . name # the sales pipeline entity is exposed as an attribute of the scenario sales_pipeline = scenario . sales # the production pipeline entity as well production_pipeline = scenario . production # All the tasks are also exposed as attributes, including the training task entity training_task = scenario . training # The six data nodes are also exposed as attributes of the scenario. current_month_data_node = scenario . current_month Taipy exposes multiple methods to manage the various scenarios. Get a scenario by id \u00b6 The first method to get a scenario is from its id by using the taipy.get()^ method: 1 2 3 4 5 6 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) scenario_retrieved = tp . get ( scenario . id ) scenario == scenario_retrieved Here, the two variables scenario and scenario_retrieved are equal. Get all scenarios \u00b6 All the scenarios can be retrieved using the method taipy.get_scenarios()^ . This method returns the list of all existing scenarios. If an optional cycle is given as a parameter, the list contains all the existing scenarios of the cycle. If an optional tag is provided as a parameter, the list contains all the existing scenarios tagged with the tag provided. Get primary scenarios \u00b6 The taipy.get_primary()^ method returns the primary scenario of the cycle given as a parameter. taipy.get_primary_scenarios()^ returns the primary scenarios for all the existing cycles. Promote a scenario as primary \u00b6 To set a scenario as primary, the taipy.set_primary()^ method must be used. It promotes the scenario given as a parameter to the primary scenario of its cycle. If the cycle already had a primary scenario it will be demoted, and it will no longer be primary for the cycle. Delete a scenario \u00b6 A scenario can be deleted by using taipy.delete()^ which takes the scenario id as a parameter. The deletion is also propagated to the nested pipelines, tasks, data nodes, and jobs if they are not shared with any other scenarios. Tag or untag a scenario \u00b6 A scenario can have multiple tags. You can add a tag to a scenario using taipy.tag()^ . Alternatively, you can use the Scenario.add_tag()^ method. 1 2 3 4 5 6 7 import taipy as tp from my_config import * scenario = tp . create_scenario ( monthly_scenario_cfg ) tp . tag ( scenario , \"my_tag\" ) # or scenario . add_tag ( \"my_tag\" ) You can retrieve all scenarios that have a specific tag using taipy.get_scenarios()^ with the tag parameter. Two scenarios can not have the same tag in the same cycle. If an existing tag is set on another scenario from the same cycle, it will be removed from the current scenario having that tag. You can remove a tag of a scenario using taipy.untag()^ . Alternatively, you can use the Scenario.remove_tag()^ method. 1 2 3 4 5 6 7 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) tp . untag ( scenario , \"my_tag\" ) # or scenario . remove_tag ( \"my_tag\" ) You can define a list of authorized tags in the scenario configuration by specifying the value of authorized_tags . From the scenarios that are created from that configuration, if you add a tag that is not authorized, an exception will be raised. Cycle attributes \u00b6 As we saw in the previous chapter, the Cycle^ creation is indirectly triggered by the scenario creation method. A cycle is identified by a unique identifier id that was generated by Taipy. A cycle also holds various attributes and properties, each accessible as an attribute of the cycle: frequency corresponds to the cycle Frequency^ . It is populated at the cycle creation using the scenario frequency that triggered the cycle creation. creation_date corresponds to the date-time of the creation of this cycle. start_date corresponds to the date and time of the start of this cycle. end_date corresponds to the date and time of the end of this cycle. name corresponds to a user readable name of this cycle. Each property of the properties dictionary is also directly exposed as an attribute. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import taipy as tp from datetime import datetime import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg , creation_date = datetime ( 2022 , 1 , 3 )) cycle = scenario . cycle # the frequency is an attribute of the cycle. In the example, it equals Frequency.MONTHLY since # my_config.monthly_scenario_cfg is used has been used to instantiate scenario and cycle. cycle . frequency # The creation date is the date-time provided at the creation. It equals datetime(2022, 1, 3) cycle . creation_date # The start date is the date-time of the start of the cycle. It equals datetime(2022, 1, 1) cycle . start_date # The end date is the date-time of the end of the cycle. It equals datetime(2022, 1, 31) cycle . end_date # By default, the `name` is None. It can be set manually. cycle . name = \"January cycle\" Get a cycle by id \u00b6 The basic method to get a cycle is from its id by using the taipy.get()^ method: 1 2 3 4 5 6 7 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) cycle = scenario . cycle cycle_retrieved = tp . get ( cycle . id ) cycle == cycle_retrieved Here, the two variables cycle and cycle_retrieved are equal. Get all cycles \u00b6 All the cycles can be retrieved using the method taipy.get_cycles()^ . This method returns the list of all existing cycles. Delete a cycle \u00b6 A cycle can be deleted by using taipy.delete()^ which takes the cycle id as a parameter. The deletion is also propagated to the nested scenarios, pipelines, tasks, data nodes, and jobs if they are not shared with any other cycles. The next section presents the pipeline management .","title":"Scenario and cycle management"},{"location":"manuals/core/entities/scenario-cycle-mgt/#scenario-attributes","text":"The scenario creation method returns a Scenario^ entity. It is identified by a unique identifier id that was generated by Taipy. A scenario also holds various properties, each accessible as an attribute of the scenario: config_id is the id of the scenario configuration. creation_date corresponds to the date-time provided at the creation. is_primary is True if it is a primary scenario. False otherwise. subscribers is the list of callbacks representing the subscribers. properties is the complete dictionary of the scenario properties. It includes a copy of the properties of the scenario configuration, in addition to the properties provided at the creation and at runtime. cycle is the cycle of the scenario. pipelines is a dictionary holding the various pipelines of the scenario. The key corresponds to the pipeline's config_id (while the value is the pipeline itself). Each property of the properties dictionary is also directly exposed as an attribute. Each nested entity is also exposed as an attribute of the scenario. The attribute name corresponds to the config_id of the nested entity. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import taipy as tp from datetime import datetime import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg , creation_date = datetime ( 2022 , 1 , 1 ), name = \"Scenario for January\" ) # the config_name is an attribute of the scenario and equals \"scenario_configuration\" scenario . config_name # The creation date is the date-time provided at the creation. It equals datetime(2022, 1, 1) scenario . creation_date # The is_primary property equals `True` since it is the only scenario of the cycle. scenario . is_primary # There was no subscription, so subscribers is an empty list scenario . subscribers # [] # The properties' dictionary equals {\"name\": \"Scenario for January\"}. It contains all the properties, # including the `name` provided at the creation scenario . properties # {\"name\": \"Scenario for January\"} # The `name` property is also exposed directly as an attribute. It equals \"Scenario for January\" scenario . name # the sales pipeline entity is exposed as an attribute of the scenario sales_pipeline = scenario . sales # the production pipeline entity as well production_pipeline = scenario . production # All the tasks are also exposed as attributes, including the training task entity training_task = scenario . training # The six data nodes are also exposed as attributes of the scenario. current_month_data_node = scenario . current_month Taipy exposes multiple methods to manage the various scenarios.","title":"Scenario attributes"},{"location":"manuals/core/entities/scenario-cycle-mgt/#get-a-scenario-by-id","text":"The first method to get a scenario is from its id by using the taipy.get()^ method: 1 2 3 4 5 6 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) scenario_retrieved = tp . get ( scenario . id ) scenario == scenario_retrieved Here, the two variables scenario and scenario_retrieved are equal.","title":"Get a scenario by id"},{"location":"manuals/core/entities/scenario-cycle-mgt/#get-all-scenarios","text":"All the scenarios can be retrieved using the method taipy.get_scenarios()^ . This method returns the list of all existing scenarios. If an optional cycle is given as a parameter, the list contains all the existing scenarios of the cycle. If an optional tag is provided as a parameter, the list contains all the existing scenarios tagged with the tag provided.","title":"Get all scenarios"},{"location":"manuals/core/entities/scenario-cycle-mgt/#get-primary-scenarios","text":"The taipy.get_primary()^ method returns the primary scenario of the cycle given as a parameter. taipy.get_primary_scenarios()^ returns the primary scenarios for all the existing cycles.","title":"Get primary scenarios"},{"location":"manuals/core/entities/scenario-cycle-mgt/#promote-a-scenario-as-primary","text":"To set a scenario as primary, the taipy.set_primary()^ method must be used. It promotes the scenario given as a parameter to the primary scenario of its cycle. If the cycle already had a primary scenario it will be demoted, and it will no longer be primary for the cycle.","title":"Promote a scenario as primary"},{"location":"manuals/core/entities/scenario-cycle-mgt/#delete-a-scenario","text":"A scenario can be deleted by using taipy.delete()^ which takes the scenario id as a parameter. The deletion is also propagated to the nested pipelines, tasks, data nodes, and jobs if they are not shared with any other scenarios.","title":"Delete a scenario"},{"location":"manuals/core/entities/scenario-cycle-mgt/#tag-or-untag-a-scenario","text":"A scenario can have multiple tags. You can add a tag to a scenario using taipy.tag()^ . Alternatively, you can use the Scenario.add_tag()^ method. 1 2 3 4 5 6 7 import taipy as tp from my_config import * scenario = tp . create_scenario ( monthly_scenario_cfg ) tp . tag ( scenario , \"my_tag\" ) # or scenario . add_tag ( \"my_tag\" ) You can retrieve all scenarios that have a specific tag using taipy.get_scenarios()^ with the tag parameter. Two scenarios can not have the same tag in the same cycle. If an existing tag is set on another scenario from the same cycle, it will be removed from the current scenario having that tag. You can remove a tag of a scenario using taipy.untag()^ . Alternatively, you can use the Scenario.remove_tag()^ method. 1 2 3 4 5 6 7 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) tp . untag ( scenario , \"my_tag\" ) # or scenario . remove_tag ( \"my_tag\" ) You can define a list of authorized tags in the scenario configuration by specifying the value of authorized_tags . From the scenarios that are created from that configuration, if you add a tag that is not authorized, an exception will be raised.","title":"Tag or untag a scenario"},{"location":"manuals/core/entities/scenario-cycle-mgt/#cycle-attributes","text":"As we saw in the previous chapter, the Cycle^ creation is indirectly triggered by the scenario creation method. A cycle is identified by a unique identifier id that was generated by Taipy. A cycle also holds various attributes and properties, each accessible as an attribute of the cycle: frequency corresponds to the cycle Frequency^ . It is populated at the cycle creation using the scenario frequency that triggered the cycle creation. creation_date corresponds to the date-time of the creation of this cycle. start_date corresponds to the date and time of the start of this cycle. end_date corresponds to the date and time of the end of this cycle. name corresponds to a user readable name of this cycle. Each property of the properties dictionary is also directly exposed as an attribute. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import taipy as tp from datetime import datetime import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg , creation_date = datetime ( 2022 , 1 , 3 )) cycle = scenario . cycle # the frequency is an attribute of the cycle. In the example, it equals Frequency.MONTHLY since # my_config.monthly_scenario_cfg is used has been used to instantiate scenario and cycle. cycle . frequency # The creation date is the date-time provided at the creation. It equals datetime(2022, 1, 3) cycle . creation_date # The start date is the date-time of the start of the cycle. It equals datetime(2022, 1, 1) cycle . start_date # The end date is the date-time of the end of the cycle. It equals datetime(2022, 1, 31) cycle . end_date # By default, the `name` is None. It can be set manually. cycle . name = \"January cycle\"","title":"Cycle attributes"},{"location":"manuals/core/entities/scenario-cycle-mgt/#get-a-cycle-by-id","text":"The basic method to get a cycle is from its id by using the taipy.get()^ method: 1 2 3 4 5 6 7 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) cycle = scenario . cycle cycle_retrieved = tp . get ( cycle . id ) cycle == cycle_retrieved Here, the two variables cycle and cycle_retrieved are equal.","title":"Get a cycle by id"},{"location":"manuals/core/entities/scenario-cycle-mgt/#get-all-cycles","text":"All the cycles can be retrieved using the method taipy.get_cycles()^ . This method returns the list of all existing cycles.","title":"Get all cycles"},{"location":"manuals/core/entities/scenario-cycle-mgt/#delete-a-cycle","text":"A cycle can be deleted by using taipy.delete()^ which takes the cycle id as a parameter. The deletion is also propagated to the nested scenarios, pipelines, tasks, data nodes, and jobs if they are not shared with any other cycles. The next section presents the pipeline management .","title":"Delete a cycle"},{"location":"manuals/core/entities/scheduling-and-job-execution/","text":"Submit a scenario, pipeline or task. \u00b6 To execute a scenario, you need to call the taipy.submit()^ method: 1 2 3 4 5 6 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) tp . submit ( scenario ) In line 4, we create a new scenario from a scenario configuration and submit it for execution (line 6). The submit method triggers the submission of all the scenario's pipelines. Then each task of each pipeline will be submitted. Another syntax. To submit a scenario, you can also use the method Scenario.submit()^ : 1 2 3 4 5 6 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) scenario . submit () You can also submit just a single pipeline with the same taipy.submit()^ method: 1 2 3 4 5 6 7 import taipy as tp import my_config scenario = tp . create_scenario ( monthly_scenario_cfg ) pipeline = scenario . sales_pipeline tp . submit ( pipeline ) In line 5, we retrieve the pipeline named sales_pipeline from the created scenario. In line 7, we submit only this pipeline for execution. The taipy.submit()^ method triggers the submission of all the pipeline's tasks. Another syntax. To submit a pipeline, you can also use the method Pipeline.submit()^ : 1 2 3 4 5 6 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) pipeline = scenario . sales_pipeline pipeline . submit () You can also submit just a single task with the same taipy.submit()^ method: 1 2 3 4 5 6 7 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) task = scenario . predicting tp . submit ( task ) In line 5, we retrieve the task named predicting from the created scenario. In line 7, we submit only this task for execution. Another syntax. To submit a task, you can also use the method Task.submit()^ : 1 2 3 4 5 6 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) task = scenario . predicting task . submit () Job \u00b6 Each time a task is submitted (through a Scenario^ or a Pipeline^ submission), a new Job^ entity is instantiated. Job attributes \u00b6 Here is the list of the job's attributes: task : The Task^ of the job. force : The force attribute is True if the execution of the job has been forced. creation_date : The date of the creation of the job with the status SUBMITTED . status : The status of the job. stacktrace : The stacktrace of the exceptions handled during the execution of the jobs. Job Status \u00b6 SUBMITTED : The job is created but not enqueued for execution. BLOCKED : The job is blocked by inputs not ready. PENDING : The job is waiting for execution. RUNNING : The job is being executed. CANCELLED : The job was cancelled by the user. FAILED : The job failed due to timeout or execution error. COMPLETED : The job execution is done and outputs were written. SKIPPED : The job was and will not be executed. Get/Delete Job \u00b6 Jobs are created when a task is submitted. You can get all of them with taipy.get_jobs()^ . You can get the latest job of a Task with taipy.get_latest_job()^ . You can retrieve a job from its id by using the taipy.get()^ method. A Job can be deleted using the taipy.delete_job()^ method. You can also delete all jobs with taipy.delete_jobs()^ . Deleting a Job can raise an JobNotDeletedException^ if the Status^ of the Job is not SKIPPED , COMPLETED or FAILED . You can overcome this behaviour by forcing the deletion with the force parameter set to True: taipy.delete_job(job, force=True) . Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import taipy as tp def double ( nb ): return nb * 2 print ( f '(1) Number of job: { len ( tp . get_jobs ()) } .' ) # Create a scenario then submit it. input_data_node_config = tp . configure_data_node ( \"input\" , default_value = 21 ) output_data_node_config = tp . configure_data_node ( \"output\" ) task_config = tp . configure_task ( \"double_task\" , double ) scenario_config = tp . configure_scenario_from_tasks ( \"my_scenario\" , [ task_config ]) scenario = tp . create_scenario ( scenario_config ) tp . submit ( scenario ) # Retrieve all jobs. print ( f '(2) Number of job: { len ( tp . get_jobs ()) } .' ) # Get the latest created job of a Task. tp . get_latest_job ( scenario . double_task ) # Then delete it. tp . delete_job ( scenario . double_task ) print ( f '(3) Number of job: { len ( tp . get_jobs ()) } .' ) This example will produce the following output: (1) Number of job: 0. (2) Number of job: 1. (3) Number of job: 0. Subscribe to job execution \u00b6 After each Task^ execution, you can be notified by subscribing to a Pipeline^ or a Scenario^ . You will be notified for each scenario or pipeline by default, except if you specify one as a target. If you want a function named my_function to be called on each status change of each task execution of all scenarios, use taipy.subscribe_scenario(my_function) . You can use taipy.subscribe_pipeline(my_function) to work at the pipeline level. If you want your function my_function to be called for each task of a scenario called my_scenario , you should call taipy.subscribe_scenario(my_function, my_scenario) . It is similar in the context of pipelines: to be notified on a given pipeline stored in my_pipeline , you must call taipy.subscribe_pipeline(my_function, my_pipeline) . You can also unsubscribe to scenarios by using taipy.unsubscribe_scenario(function) or tp.unsubscribe_pipeline(function) for pipelines. Same as for subscription, the un-subscription can be global, or you can specify the scenario or pipeline by passing it as a parameter. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import taipy as tp def do_nothing (): ... def my_global_subscriber ( scenario , job ): print ( f \"Called from my_global_subscriber from scenario ' { scenario . config_id } ' and job for task ' { job . task . config_id } '.\" ) def my_subscriber ( scenario , job ): print ( f \"Called from my_subscriber from scenario ' { scenario . config_id } ' and job for task ' { job . task . config_id } '.\" ) task_1 = tp . configure_task ( \"my_task_1\" , do_nothing ) task_2 = tp . configure_task ( \"my_task_2\" , do_nothing ) scenario_1 = tp . configure_scenario_from_tasks ( \"my_scenario\" , [ task , task ]) scenario_2 = tp . configure_scenario_from_tasks ( \"my_scenario\" , [ task , task ]) tp . subscribe_scenario ( my_global_subscriber ) # Global subscription tp . subscribe_scenario ( my_subscriber , scenario_1 ) # Subscribe only on one scenario print ( 'Submit: scenario_1' ) tp . submit ( scenario_1 ) print ( 'Submit: scenario_2' ) print ( 'Unsubscribe to my_global_subscriber for scenario_1' ) tp . unsubscribe_scenario ( my_global_subscriber , scenario_1 ) print ( 'Submit: scenario_1) tp . submit ( scenario_1 ) This example will produce the following output: Submit: scenario_1 Called from my_global_subscriber from scenario 'my_scenario_1' and job for task 'my_task_1'. Called from my_subscriber from scenario 'my_scenario_1' and job for task 'my_task_1'. Called from my_subscriber from scenario 'my_scenario_1' and job for task 'my_task_2'. Submit: scenario_2 Called from my_global_subscriber from scenario 'my_scenario_2' and job for task 'my_task_1'. Unsubscribe to my_global_subscriber for scenario_1 Submit: scenario_1 Called from my_subscriber from scenario 'my_scenario_1' and job for task 'my_task_1'. Called from my_subscriber from scenario 'my_scenario_1' and job for task 'my_task_2'.","title":"Job execution"},{"location":"manuals/core/entities/scheduling-and-job-execution/#submit-a-scenario-pipeline-or-task","text":"To execute a scenario, you need to call the taipy.submit()^ method: 1 2 3 4 5 6 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) tp . submit ( scenario ) In line 4, we create a new scenario from a scenario configuration and submit it for execution (line 6). The submit method triggers the submission of all the scenario's pipelines. Then each task of each pipeline will be submitted. Another syntax. To submit a scenario, you can also use the method Scenario.submit()^ : 1 2 3 4 5 6 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) scenario . submit () You can also submit just a single pipeline with the same taipy.submit()^ method: 1 2 3 4 5 6 7 import taipy as tp import my_config scenario = tp . create_scenario ( monthly_scenario_cfg ) pipeline = scenario . sales_pipeline tp . submit ( pipeline ) In line 5, we retrieve the pipeline named sales_pipeline from the created scenario. In line 7, we submit only this pipeline for execution. The taipy.submit()^ method triggers the submission of all the pipeline's tasks. Another syntax. To submit a pipeline, you can also use the method Pipeline.submit()^ : 1 2 3 4 5 6 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) pipeline = scenario . sales_pipeline pipeline . submit () You can also submit just a single task with the same taipy.submit()^ method: 1 2 3 4 5 6 7 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) task = scenario . predicting tp . submit ( task ) In line 5, we retrieve the task named predicting from the created scenario. In line 7, we submit only this task for execution. Another syntax. To submit a task, you can also use the method Task.submit()^ : 1 2 3 4 5 6 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) task = scenario . predicting task . submit ()","title":"Submit a scenario, pipeline or task."},{"location":"manuals/core/entities/scheduling-and-job-execution/#job","text":"Each time a task is submitted (through a Scenario^ or a Pipeline^ submission), a new Job^ entity is instantiated.","title":"Job"},{"location":"manuals/core/entities/scheduling-and-job-execution/#job-attributes","text":"Here is the list of the job's attributes: task : The Task^ of the job. force : The force attribute is True if the execution of the job has been forced. creation_date : The date of the creation of the job with the status SUBMITTED . status : The status of the job. stacktrace : The stacktrace of the exceptions handled during the execution of the jobs.","title":"Job attributes"},{"location":"manuals/core/entities/scheduling-and-job-execution/#job-status","text":"SUBMITTED : The job is created but not enqueued for execution. BLOCKED : The job is blocked by inputs not ready. PENDING : The job is waiting for execution. RUNNING : The job is being executed. CANCELLED : The job was cancelled by the user. FAILED : The job failed due to timeout or execution error. COMPLETED : The job execution is done and outputs were written. SKIPPED : The job was and will not be executed.","title":"Job Status"},{"location":"manuals/core/entities/scheduling-and-job-execution/#getdelete-job","text":"Jobs are created when a task is submitted. You can get all of them with taipy.get_jobs()^ . You can get the latest job of a Task with taipy.get_latest_job()^ . You can retrieve a job from its id by using the taipy.get()^ method. A Job can be deleted using the taipy.delete_job()^ method. You can also delete all jobs with taipy.delete_jobs()^ . Deleting a Job can raise an JobNotDeletedException^ if the Status^ of the Job is not SKIPPED , COMPLETED or FAILED . You can overcome this behaviour by forcing the deletion with the force parameter set to True: taipy.delete_job(job, force=True) . Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import taipy as tp def double ( nb ): return nb * 2 print ( f '(1) Number of job: { len ( tp . get_jobs ()) } .' ) # Create a scenario then submit it. input_data_node_config = tp . configure_data_node ( \"input\" , default_value = 21 ) output_data_node_config = tp . configure_data_node ( \"output\" ) task_config = tp . configure_task ( \"double_task\" , double ) scenario_config = tp . configure_scenario_from_tasks ( \"my_scenario\" , [ task_config ]) scenario = tp . create_scenario ( scenario_config ) tp . submit ( scenario ) # Retrieve all jobs. print ( f '(2) Number of job: { len ( tp . get_jobs ()) } .' ) # Get the latest created job of a Task. tp . get_latest_job ( scenario . double_task ) # Then delete it. tp . delete_job ( scenario . double_task ) print ( f '(3) Number of job: { len ( tp . get_jobs ()) } .' ) This example will produce the following output: (1) Number of job: 0. (2) Number of job: 1. (3) Number of job: 0.","title":"Get/Delete Job"},{"location":"manuals/core/entities/scheduling-and-job-execution/#subscribe-to-job-execution","text":"After each Task^ execution, you can be notified by subscribing to a Pipeline^ or a Scenario^ . You will be notified for each scenario or pipeline by default, except if you specify one as a target. If you want a function named my_function to be called on each status change of each task execution of all scenarios, use taipy.subscribe_scenario(my_function) . You can use taipy.subscribe_pipeline(my_function) to work at the pipeline level. If you want your function my_function to be called for each task of a scenario called my_scenario , you should call taipy.subscribe_scenario(my_function, my_scenario) . It is similar in the context of pipelines: to be notified on a given pipeline stored in my_pipeline , you must call taipy.subscribe_pipeline(my_function, my_pipeline) . You can also unsubscribe to scenarios by using taipy.unsubscribe_scenario(function) or tp.unsubscribe_pipeline(function) for pipelines. Same as for subscription, the un-subscription can be global, or you can specify the scenario or pipeline by passing it as a parameter. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import taipy as tp def do_nothing (): ... def my_global_subscriber ( scenario , job ): print ( f \"Called from my_global_subscriber from scenario ' { scenario . config_id } ' and job for task ' { job . task . config_id } '.\" ) def my_subscriber ( scenario , job ): print ( f \"Called from my_subscriber from scenario ' { scenario . config_id } ' and job for task ' { job . task . config_id } '.\" ) task_1 = tp . configure_task ( \"my_task_1\" , do_nothing ) task_2 = tp . configure_task ( \"my_task_2\" , do_nothing ) scenario_1 = tp . configure_scenario_from_tasks ( \"my_scenario\" , [ task , task ]) scenario_2 = tp . configure_scenario_from_tasks ( \"my_scenario\" , [ task , task ]) tp . subscribe_scenario ( my_global_subscriber ) # Global subscription tp . subscribe_scenario ( my_subscriber , scenario_1 ) # Subscribe only on one scenario print ( 'Submit: scenario_1' ) tp . submit ( scenario_1 ) print ( 'Submit: scenario_2' ) print ( 'Unsubscribe to my_global_subscriber for scenario_1' ) tp . unsubscribe_scenario ( my_global_subscriber , scenario_1 ) print ( 'Submit: scenario_1) tp . submit ( scenario_1 ) This example will produce the following output: Submit: scenario_1 Called from my_global_subscriber from scenario 'my_scenario_1' and job for task 'my_task_1'. Called from my_subscriber from scenario 'my_scenario_1' and job for task 'my_task_1'. Called from my_subscriber from scenario 'my_scenario_1' and job for task 'my_task_2'. Submit: scenario_2 Called from my_global_subscriber from scenario 'my_scenario_2' and job for task 'my_task_1'. Unsubscribe to my_global_subscriber for scenario_1 Submit: scenario_1 Called from my_subscriber from scenario 'my_scenario_1' and job for task 'my_task_1'. Called from my_subscriber from scenario 'my_scenario_1' and job for task 'my_task_2'.","title":"Subscribe to job execution"},{"location":"manuals/core/entities/task-mgt/","text":"In this section, it is assumed that my_config.py module contains a Taipy configuration already implemented. Tasks get created when scenarios or pipelines are created. Please refer to the Entities' creation section for more details. Task attributes \u00b6 Now that we assume to know how to create a new Task^ , this section focuses on describing the task's attributes and utility methods for using tasks. A Task^ entity is identified by a unique identifier id that is generated by Taipy. A task also holds various properties accessible as an attribute of the task: config_id is the id of the scenario configuration. function is the function that will take data from input data nodes and return data that should go inside the output data nodes. input is the list of input data nodes. output is the list of output data nodes. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) task = scenario . predicting # the config_id is an attribute of the task and equals \"task_configuration\" task . config_id # the function which is going to be executed with input data nodes and return value on output data nodes. task . function # predict # input is the list of input data nodes of the task task . input # [trained_model_cfg, current_month_cfg] # output is the list of input data nodes of the task task . output # [trained_model_cfg] # the current_month data node entity is exposed as an attribute of the task current_month_data_node = task . current_month Taipy exposes multiple methods to manage the various tasks. Get Tasks \u00b6 The first method to get a job is from its id by using the taipy.get()^ method 1 2 3 4 5 6 7 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) task = scenario . training task_retrieved = tp . get ( task . id ) # task == task_retrieved Here, the two variables task and task_retrieved are equal. A task can also be retrieved from a scenario or a pipeline, by accessing the task config_id attribute. 1 2 3 4 task_1 = scenario . predicting pipeline = scenario . sales task_2 - pipeline . predicting # task_1 == task_2 All the jobs can be retrieved using the method taipy.get_tasks()^ . The next section shows the data node management .","title":"Task management"},{"location":"manuals/core/entities/task-mgt/#task-attributes","text":"Now that we assume to know how to create a new Task^ , this section focuses on describing the task's attributes and utility methods for using tasks. A Task^ entity is identified by a unique identifier id that is generated by Taipy. A task also holds various properties accessible as an attribute of the task: config_id is the id of the scenario configuration. function is the function that will take data from input data nodes and return data that should go inside the output data nodes. input is the list of input data nodes. output is the list of output data nodes. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) task = scenario . predicting # the config_id is an attribute of the task and equals \"task_configuration\" task . config_id # the function which is going to be executed with input data nodes and return value on output data nodes. task . function # predict # input is the list of input data nodes of the task task . input # [trained_model_cfg, current_month_cfg] # output is the list of input data nodes of the task task . output # [trained_model_cfg] # the current_month data node entity is exposed as an attribute of the task current_month_data_node = task . current_month Taipy exposes multiple methods to manage the various tasks.","title":"Task attributes"},{"location":"manuals/core/entities/task-mgt/#get-tasks","text":"The first method to get a job is from its id by using the taipy.get()^ method 1 2 3 4 5 6 7 import taipy as tp import my_config scenario = tp . create_scenario ( my_config . monthly_scenario_cfg ) task = scenario . training task_retrieved = tp . get ( task . id ) # task == task_retrieved Here, the two variables task and task_retrieved are equal. A task can also be retrieved from a scenario or a pipeline, by accessing the task config_id attribute. 1 2 3 4 task_1 = scenario . predicting pipeline = scenario . sales task_2 - pipeline . predicting # task_1 == task_2 All the jobs can be retrieved using the method taipy.get_tasks()^ . The next section shows the data node management .","title":"Get Tasks"},{"location":"manuals/deployment/docker/Dockerfile/","text":"FROM python:3.9 as taipy # Web port of the application EXPOSE 5000 # Install your application WORKDIR /opt/airflow COPY . . RUN pip install -r requirements.txt RUN pip install pip install 'apache-airflow==2.2.3' \\ --constraint \"https://raw.githubusercontent.com/apache/airflow/constraints-2.2.3/constraints-3.9.txt\" RUN mkdir -p /app/data && chmod -R 777 /app/data RUN useradd -ms /bin/bash airflow USER airflow CMD python demo_cli.py FROM apache/airflow:latest-python3.9 as airflow USER root RUN apt update -y RUN apt install -y git USER airflow COPY . . RUN pip install -r requirements.txt RUN pip install --upgrade numpy ENV PYTHONPATH=/opt/airflow","title":"Dockerfile"},{"location":"manuals/deployment/docker/airflow/","text":"Taipy application with Airflow \u00b6 Important This feature is limited to the Enterprise version only. For more information, contact us at taipy.io . Prerequisites \u00b6 Minimal knowledge of Docker. Docker should be installed. Check the official documentation for Docker installation. Docker-compose should be installed. Check the official documentation for docker-compose installation. Had done the Getting-Started Airflow and Taipy in the same container \u00b6 The simplest way to try your Taipy application with Airflow is to let Taipy start Airflow by itself. To do that, you must install the Airflow dependencies in the container itself. Replace your Dockerfile with the following: # Your Python version FROM python:3.9 # Web port of the application EXPOSE 5000 # Install your application WORKDIR /app COPY . /app RUN pip install -r requirements.txt RUN pip install pip install 'apache-airflow==2.2.3' \\ --constraint \"https://raw.githubusercontent.com/apache/airflow/constraints-2.2.3/constraints-3.9.txt\" # Startup command CMD python my-app.py Then you should specify Airflow as the scheduler in your configuration. [JOB] mode = \"airflow\" hostname = \"http://localhost:8080\" start_airflow = true Airflow and Taipy in different containers \u00b6 The Apache Airflow community provides an official docker-compose file . However, Taipy requires a custom version of this file, that should be downloaded from this link . Download this file and copy it next to your main application file. Docker-compose minimal version Make sure that the version is later than 1.29 . Custom image \u00b6 To run your application, you must provide to Airflow a custom image that contains all the Airflow dependencies. Everything is already packaged in this Dockerfile . Download it and copy it next to the main application source file. Update your configuration with the parameters below to allow communication between Airflow and Taipy. [TAIPY] storage_folder = \"/app/data\" [JOB] mode = \"airflow\" hostname = \"http://airflow-webserver:8080\" start_airflow = false airflow_api_retry = 100 airflow_dags_folder=\"/app/dags\" airflow_user=\"airflow\" airflow_password=\"airflow\" If you run on Linux You should first run the following commands ( For more information click here ): mkdir -p ./dags ./logs ./plugins echo -e \"AIRFLOW_UID=$(id -u)\" > .env Before you run your application, you must create the Airflow database using the following command: docker-compose up airflow-init Then, you can run your application by doing: docker-compose up -d --build You can access the Airflow server at http://0.0.0.0:8080/home . The default value for both the username and the password are airflow . Please note that in some instances the initialization of Airflow can be lengthy, the server URL may not be available for several minutes. If your application has a Taipy user interface, you can connect to it at http://0.0.0.0:5000 . You can clean all resources by doing: docker-compose down --volumes --remove-orphans","title":"Application running with Airflow on docker"},{"location":"manuals/deployment/docker/airflow/#taipy-application-with-airflow","text":"Important This feature is limited to the Enterprise version only. For more information, contact us at taipy.io .","title":"Taipy application with Airflow"},{"location":"manuals/deployment/docker/airflow/#prerequisites","text":"Minimal knowledge of Docker. Docker should be installed. Check the official documentation for Docker installation. Docker-compose should be installed. Check the official documentation for docker-compose installation. Had done the Getting-Started","title":"Prerequisites"},{"location":"manuals/deployment/docker/airflow/#airflow-and-taipy-in-the-same-container","text":"The simplest way to try your Taipy application with Airflow is to let Taipy start Airflow by itself. To do that, you must install the Airflow dependencies in the container itself. Replace your Dockerfile with the following: # Your Python version FROM python:3.9 # Web port of the application EXPOSE 5000 # Install your application WORKDIR /app COPY . /app RUN pip install -r requirements.txt RUN pip install pip install 'apache-airflow==2.2.3' \\ --constraint \"https://raw.githubusercontent.com/apache/airflow/constraints-2.2.3/constraints-3.9.txt\" # Startup command CMD python my-app.py Then you should specify Airflow as the scheduler in your configuration. [JOB] mode = \"airflow\" hostname = \"http://localhost:8080\" start_airflow = true","title":"Airflow and Taipy in the same container"},{"location":"manuals/deployment/docker/airflow/#airflow-and-taipy-in-different-containers","text":"The Apache Airflow community provides an official docker-compose file . However, Taipy requires a custom version of this file, that should be downloaded from this link . Download this file and copy it next to your main application file. Docker-compose minimal version Make sure that the version is later than 1.29 .","title":"Airflow and Taipy in different containers"},{"location":"manuals/deployment/docker/airflow/#custom-image","text":"To run your application, you must provide to Airflow a custom image that contains all the Airflow dependencies. Everything is already packaged in this Dockerfile . Download it and copy it next to the main application source file. Update your configuration with the parameters below to allow communication between Airflow and Taipy. [TAIPY] storage_folder = \"/app/data\" [JOB] mode = \"airflow\" hostname = \"http://airflow-webserver:8080\" start_airflow = false airflow_api_retry = 100 airflow_dags_folder=\"/app/dags\" airflow_user=\"airflow\" airflow_password=\"airflow\" If you run on Linux You should first run the following commands ( For more information click here ): mkdir -p ./dags ./logs ./plugins echo -e \"AIRFLOW_UID=$(id -u)\" > .env Before you run your application, you must create the Airflow database using the following command: docker-compose up airflow-init Then, you can run your application by doing: docker-compose up -d --build You can access the Airflow server at http://0.0.0.0:8080/home . The default value for both the username and the password are airflow . Please note that in some instances the initialization of Airflow can be lengthy, the server URL may not be available for several minutes. If your application has a Taipy user interface, you can connect to it at http://0.0.0.0:5000 . You can clean all resources by doing: docker-compose down --volumes --remove-orphans","title":"Custom image"},{"location":"manuals/deployment/docker/docker-compose.yml/","text":"# Licensed to the Apache Software Foundation (ASF) under one # or more contributor license agreements. See the NOTICE file # distributed with this work for additional information # regarding copyright ownership. The ASF licenses this file # to you under the Apache License, Version 2.0 (the # \"License\"); you may not use this file except in compliance # with the License. You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, # software distributed under the License is distributed on an # \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY # KIND, either express or implied. See the License for the # specific language governing permissions and limitations # under the License. # # Basic Airflow cluster configuration for CeleryExecutor with Redis and PostgreSQL. # # WARNING: This configuration is for local development. Do not use it in a production deployment. # # This configuration supports basic configuration using environment variables or an .env file # The following variables are supported: # # AIRFLOW_IMAGE_NAME - Docker image name used to run Airflow. # Default: apache/airflow:2.2.3 # AIRFLOW_UID - User ID in Airflow containers # Default: 50000 # Those configurations are useful mostly in case of standalone testing/running Airflow in test/try-out mode # # _AIRFLOW_WWW_USER_USERNAME - Username for the administrator account (if requested). # Default: airflow # _AIRFLOW_WWW_USER_PASSWORD - Password for the administrator account (if requested). # Default: airflow # _PIP_ADDITIONAL_REQUIREMENTS - Additional PIP requirements to add when starting all containers. # Default: '' # # Feel free to modify this file to suit your needs. --- version: '3' x-airflow-common: &airflow-common # In order to add custom dependencies or upgrade provider packages you can use your extended image. # Comment the image line, place your Dockerfile in the directory where you placed the docker-compose.yaml # and uncomment the \"build\" line below, Then run `docker-compose build` to build the images. #${AIRFLOW_IMAGE_NAME:-apache/airflow:2.2.3} image: custom-airflow build: context: . target: airflow environment: &airflow-common-env AIRFLOW__CORE__EXECUTOR: CeleryExecutor AIRFLOW__CORE__SQL_ALCHEMY_CONN: postgresql+psycopg2://airflow:airflow@postgres/airflow AIRFLOW__CELERY__RESULT_BACKEND: db+postgresql://airflow:airflow@postgres/airflow AIRFLOW__CELERY__BROKER_URL: redis://:@redis:6379/0 AIRFLOW__CORE__FERNET_KEY: '' AIRFLOW__CORE__DAGS_ARE_PAUSED_AT_CREATION: 'true' AIRFLOW__CORE__LOAD_EXAMPLES: 'true' AIRFLOW__API__AUTH_BACKEND: 'airflow.api.auth.backend.basic_auth' _PIP_ADDITIONAL_REQUIREMENTS: ${_PIP_ADDITIONAL_REQUIREMENTS:-} volumes: - ./dags:/opt/airflow/dags - ./logs:/opt/airflow/logs - ./plugins:/opt/airflow/plugins - application-data:/app/data user: \"${AIRFLOW_UID:-50000}:0\" depends_on: &airflow-common-depends-on redis: condition: service_healthy postgres: condition: service_healthy services: taipy: build: context: . target: taipy ports: - \"5000:5000\" volumes: - ./dags:/app/dags - application-data:/app/data user: \"${AIRFLOW_UID:-50000}:0\" depends_on: <<: *airflow-common-depends-on airflow-init: condition: service_completed_successfully postgres: image: postgres:13 environment: POSTGRES_USER: airflow POSTGRES_PASSWORD: airflow POSTGRES_DB: airflow volumes: - postgres-db-volume:/var/lib/postgresql/data healthcheck: test: [\"CMD\", \"pg_isready\", \"-U\", \"airflow\"] interval: 5s retries: 5 restart: always redis: image: redis:latest expose: - 6379 healthcheck: test: [\"CMD\", \"redis-cli\", \"ping\"] interval: 5s timeout: 30s retries: 50 restart: always airflow-webserver: <<: *airflow-common command: webserver ports: - 8080:8080 healthcheck: test: [\"CMD\", \"curl\", \"--fail\", \"http://localhost:8080/health\"] interval: 10s timeout: 10s retries: 5 restart: always depends_on: <<: *airflow-common-depends-on airflow-init: condition: service_completed_successfully airflow-scheduler: <<: *airflow-common command: scheduler healthcheck: test: [\"CMD-SHELL\", 'airflow jobs check --job-type SchedulerJob --hostname \"$${HOSTNAME}\"'] interval: 10s timeout: 10s retries: 5 restart: always depends_on: <<: *airflow-common-depends-on airflow-init: condition: service_completed_successfully airflow-worker: <<: *airflow-common command: celery worker healthcheck: test: - \"CMD-SHELL\" - 'celery --app airflow.executors.celery_executor.app inspect ping -d \"celery@$${HOSTNAME}\"' interval: 10s timeout: 10s retries: 5 environment: <<: *airflow-common-env # Required to handle warm shutdown of the Celery workers properly # See https://airflow.apache.org/docs/docker-stack/entrypoint.html#signal-propagation DUMB_INIT_SETSID: \"0\" restart: always depends_on: <<: *airflow-common-depends-on airflow-init: condition: service_completed_successfully airflow-triggerer: <<: *airflow-common command: triggerer healthcheck: test: [\"CMD-SHELL\", 'airflow jobs check --job-type TriggererJob --hostname \"$${HOSTNAME}\"'] interval: 10s timeout: 10s retries: 5 restart: always depends_on: <<: *airflow-common-depends-on airflow-init: condition: service_completed_successfully airflow-init: <<: *airflow-common entrypoint: /bin/bash # yamllint disable rule:line-length command: - -c - | function ver() { printf \"%04d%04d%04d%04d\" $${1//./ } } airflow_version=$$(gosu airflow airflow version) airflow_version_comparable=$$(ver $${airflow_version}) min_airflow_version=2.2.0 min_airflow_version_comparable=$$(ver $${min_airflow_version}) if (( airflow_version_comparable < min_airflow_version_comparable )); then echo echo -e \"\\033[1;31mERROR!!!: Too old Airflow version $${airflow_version}.\\e[0m\" echo \"The minimum Airflow version supported: $${min_airflow_version}. Only use this or higher!\" echo exit 1 fi if [[ -z \"${AIRFLOW_UID}\" ]]; then echo echo -e \"\\033[1;33mWARNING: AIRFLOW_UID not set!\\e[0m\" echo \"If you are on Linux, you must follow the instructions below to set \" echo \"AIRFLOW_UID environment variable, otherwise files will be owned by root.\" echo \"For other operating systems you can get rid of the warning with manually created .env file:\" echo \" See: https://airflow.apache.org/docs/apache-airflow/stable/start/docker.html#setting-the-right-airflow-user\" echo fi one_meg=1048576 mem_available=$$(($$(getconf _PHYS_PAGES) * $$(getconf PAGE_SIZE) / one_meg)) cpus_available=$$(grep -cE 'cpu[0-9]+' /proc/stat) disk_available=$$(df / | tail -1 | awk '{print $$4}') warning_resources=\"false\" if (( mem_available < 4000 )) ; then echo echo -e \"\\033[1;33mWARNING: Not enough memory available for Docker.\\e[0m\" echo \"At least 4GB of memory required. You have $$(numfmt --to iec $$((mem_available * one_meg)))\" echo warning_resources=\"true\" fi if (( cpus_available < 2 )); then echo echo -e \"\\033[1;33mWARNING: Not enough CPUS available for Docker.\\e[0m\" echo \"At least 2 CPUs recommended. You have $${cpus_available}\" echo warning_resources=\"true\" fi if (( disk_available < one_meg * 10 )); then echo echo -e \"\\033[1;33mWARNING: Not enough Disk space available for Docker.\\e[0m\" echo \"At least 10 GBs recommended. You have $$(numfmt --to iec $$((disk_available * 1024 )))\" echo warning_resources=\"true\" fi if [[ $${warning_resources} == \"true\" ]]; then echo echo -e \"\\033[1;33mWARNING: You have not enough resources to run Airflow (see above)!\\e[0m\" echo \"Please follow the instructions to increase the available resources:\" echo \" https://airflow.apache.org/docs/apache-airflow/stable/start/docker.html#before-you-begin\" echo fi mkdir -p /sources/logs /sources/dags /sources/plugins chown -R \"${AIRFLOW_UID}:0\" /sources/{logs,dags,plugins} exec /entrypoint airflow version # yamllint enable rule:line-length environment: <<: *airflow-common-env _AIRFLOW_DB_UPGRADE: 'true' _AIRFLOW_WWW_USER_CREATE: 'true' _AIRFLOW_WWW_USER_USERNAME: ${_AIRFLOW_WWW_USER_USERNAME:-airflow} _AIRFLOW_WWW_USER_PASSWORD: ${_AIRFLOW_WWW_USER_PASSWORD:-airflow} user: \"0:0\" volumes: - .:/sources airflow-cli: <<: *airflow-common profiles: - debug environment: <<: *airflow-common-env CONNECTION_CHECK_MAX_COUNT: \"0\" # Workaround for entrypoint issue. See: https://github.com/apache/airflow/issues/16252 command: - bash - -c - airflow flower: <<: *airflow-common command: celery flower ports: - 5555:5555 healthcheck: test: [\"CMD\", \"curl\", \"--fail\", \"http://localhost:5555/\"] interval: 10s timeout: 10s retries: 5 restart: always depends_on: <<: *airflow-common-depends-on airflow-init: condition: service_completed_successfully volumes: postgres-db-volume: application-data:","title":"Docker compose.yml"},{"location":"manuals/deployment/docker/standalone/","text":"Standalone Taipy application \u00b6 Prerequisites \u00b6 Minimal knowledge of Docker. Docker must be installed. Check the official documentation for docker installation. Docker-compose must be installed. Check the official documentation for docker-compose installation. Important information: The following setup is designed for development and testing. It does not target a production deployment. Basic Taipy Dockerfile \u00b6 The following example allows you to run your application inside a Docker container. # Your Python version FROM python:3.9 # Web port of the application EXPOSE 5000 # Install your application WORKDIR /app COPY . /app RUN pip install -r requirements.txt # Start up command CMD python my-app.py Build the container using the command: docker build -t my-taipy-app . When the container is ready, you can run it in the background with the command: docker run -p 5000:5000 -d --name my-taipy-app my-taipy-app Then go on http://localhost:5000 . Note that the -p option indicates the port number binding the container and the host. To stop the container, use the command: docker stop my-taipy-app You can remove the container from docker with the command: docker rm my-taipy-app Then you can delete the container imager with the command: docker rmi my-taipy-app Simplify build with docker-compose \u00b6 You can also wrap your build and run steps with docker-compose . Create a docker-compose.yml with the following content: version : \"3.9\" services : taipy : build : \"\" ports : - \"5000:5000\" You can build and run your application with: docker-compose up --build -d Then go on http://localhost:5000 . You can clean all resources by doing: docker-compose down --remove-orphans .","title":"Standalone Application on docker"},{"location":"manuals/deployment/docker/standalone/#standalone-taipy-application","text":"","title":"Standalone Taipy application"},{"location":"manuals/deployment/docker/standalone/#prerequisites","text":"Minimal knowledge of Docker. Docker must be installed. Check the official documentation for docker installation. Docker-compose must be installed. Check the official documentation for docker-compose installation. Important information: The following setup is designed for development and testing. It does not target a production deployment.","title":"Prerequisites"},{"location":"manuals/deployment/docker/standalone/#basic-taipy-dockerfile","text":"The following example allows you to run your application inside a Docker container. # Your Python version FROM python:3.9 # Web port of the application EXPOSE 5000 # Install your application WORKDIR /app COPY . /app RUN pip install -r requirements.txt # Start up command CMD python my-app.py Build the container using the command: docker build -t my-taipy-app . When the container is ready, you can run it in the background with the command: docker run -p 5000:5000 -d --name my-taipy-app my-taipy-app Then go on http://localhost:5000 . Note that the -p option indicates the port number binding the container and the host. To stop the container, use the command: docker stop my-taipy-app You can remove the container from docker with the command: docker rm my-taipy-app Then you can delete the container imager with the command: docker rmi my-taipy-app","title":"Basic Taipy Dockerfile"},{"location":"manuals/deployment/docker/standalone/#simplify-build-with-docker-compose","text":"You can also wrap your build and run steps with docker-compose . Create a docker-compose.yml with the following content: version : \"3.9\" services : taipy : build : \"\" ports : - \"5000:5000\" You can build and run your application with: docker-compose up --build -d Then go on http://localhost:5000 . You can clean all resources by doing: docker-compose down --remove-orphans .","title":"Simplify build with docker-compose"},{"location":"manuals/deployment/heroku/docker/","text":"Deploy a Dockerize Taipy application with Heroku \u00b6 Prerequisites \u00b6 Minimal knowledge of Docker. Docker should be installed. Check the official documentation for docker installation. Prepare your Taipy application Set up your Heroku environment 1. Create your Dockerfile \u00b6 Along with your application, you must create a Dockerfile that will allow Docker to build your container. Here is an example with main.py as the entry point of your application and requirements.txt file with all your dependencies (Taipy included): # Your Python version FROM python:3.9 # Install your application WORKDIR /app COPY . /app RUN pip install -r requirements.txt # Startup command CMD python demo8.py Note \u00b6 This Dockerfile is provided as an example and tested without security consideration, do not use it for a production environment. 2. Build and test your Docker \u00b6 At the same location as your Dockerfile, run the following command to create a Docker image named : docker build . -t <my-taipy-app> You can now run it with the command line: docker run -p 5000:5000 -d --name <my-taipy-app> <my-taipy-app> Open a browser and go to http://localhost:5000 -- there may be some startup latency --. 3. Deployment \u00b6 In our example, we use the name <my-taipy-app> for our application. On Heroku, this name should be unique. So you should replace it consistently with a custom value. heroku login heroku create <my-taipy-app> heroku container:login heroku container:push web -a <my-taipy-app> heroku config:set CLIENT_URL=\"https://<my-taipy-app>.herokuapp.com\" -a <my-taipy-app> heroku container:release web -a <my-taipy-app> 4. Check your deployment \u00b6 You can go to the url https://<my-taipy-app>.herokuapp.com with your browser or run heroku open -a <my-taipy-app> . Your application should be deployed correctly. 5. Clean up your resources \u00b6 Stop the local docker container: docker stop <my-taipy-app> Remove the local docker container: docker rm <my-taipy-app> Remove the local docker image: docker rmi <my-taipy-app> Remove the Heroku application: heroku apps:destroy <my-taipy-app> --confirm <my-taipy-app>","title":"Based on Docker"},{"location":"manuals/deployment/heroku/docker/#deploy-a-dockerize-taipy-application-with-heroku","text":"","title":"Deploy a Dockerize Taipy application with Heroku"},{"location":"manuals/deployment/heroku/docker/#prerequisites","text":"Minimal knowledge of Docker. Docker should be installed. Check the official documentation for docker installation. Prepare your Taipy application Set up your Heroku environment","title":"Prerequisites"},{"location":"manuals/deployment/heroku/docker/#1-create-your-dockerfile","text":"Along with your application, you must create a Dockerfile that will allow Docker to build your container. Here is an example with main.py as the entry point of your application and requirements.txt file with all your dependencies (Taipy included): # Your Python version FROM python:3.9 # Install your application WORKDIR /app COPY . /app RUN pip install -r requirements.txt # Startup command CMD python demo8.py","title":"1. Create your Dockerfile"},{"location":"manuals/deployment/heroku/docker/#note","text":"This Dockerfile is provided as an example and tested without security consideration, do not use it for a production environment.","title":"Note"},{"location":"manuals/deployment/heroku/docker/#2-build-and-test-your-docker","text":"At the same location as your Dockerfile, run the following command to create a Docker image named : docker build . -t <my-taipy-app> You can now run it with the command line: docker run -p 5000:5000 -d --name <my-taipy-app> <my-taipy-app> Open a browser and go to http://localhost:5000 -- there may be some startup latency --.","title":"2. Build and test your Docker"},{"location":"manuals/deployment/heroku/docker/#3-deployment","text":"In our example, we use the name <my-taipy-app> for our application. On Heroku, this name should be unique. So you should replace it consistently with a custom value. heroku login heroku create <my-taipy-app> heroku container:login heroku container:push web -a <my-taipy-app> heroku config:set CLIENT_URL=\"https://<my-taipy-app>.herokuapp.com\" -a <my-taipy-app> heroku container:release web -a <my-taipy-app>","title":"3. Deployment"},{"location":"manuals/deployment/heroku/docker/#4-check-your-deployment","text":"You can go to the url https://<my-taipy-app>.herokuapp.com with your browser or run heroku open -a <my-taipy-app> . Your application should be deployed correctly.","title":"4. Check your deployment"},{"location":"manuals/deployment/heroku/docker/#5-clean-up-your-resources","text":"Stop the local docker container: docker stop <my-taipy-app> Remove the local docker container: docker rm <my-taipy-app> Remove the local docker image: docker rmi <my-taipy-app> Remove the Heroku application: heroku apps:destroy <my-taipy-app> --confirm <my-taipy-app>","title":"5. Clean up your resources"},{"location":"manuals/deployment/heroku/getting-started/","text":"Deploy on Heroku \u00b6 Heroku is a Cloud provider that allows you to deploy dev and test apps for free. The following documentation allows quick deployments on this platform for sharing applications. Important note \u00b6 This documentation is made for test and dev only. We do not recommend deploying applications in a production environment or sensitive data using this documentation! Summary \u00b6 Prepare your application for deployment Set up your Heroku environment. Deploy your application with a deployment based on Git. Deploy your application with a deployment based on Docker.","title":"Getting started"},{"location":"manuals/deployment/heroku/getting-started/#deploy-on-heroku","text":"Heroku is a Cloud provider that allows you to deploy dev and test apps for free. The following documentation allows quick deployments on this platform for sharing applications.","title":"Deploy on Heroku"},{"location":"manuals/deployment/heroku/getting-started/#important-note","text":"This documentation is made for test and dev only. We do not recommend deploying applications in a production environment or sensitive data using this documentation!","title":"Important note"},{"location":"manuals/deployment/heroku/getting-started/#summary","text":"Prepare your application for deployment Set up your Heroku environment. Deploy your application with a deployment based on Git. Deploy your application with a deployment based on Docker.","title":"Summary"},{"location":"manuals/deployment/heroku/git/","text":"Deploy a Taipy application based on git with Heroku \u00b6 Prerequisites \u00b6 Minimal knowledge of Git. Git must be installed, otherwise check the official documentation . Prepare your Taipy application Set up your Heroku environment 1. Add version control to your application \u00b6 Note: This step is necessary only if your application doesn't already use Git. git init git config [--global] user.name \"Full Name\" git config [--global] user.email \"email@address.com\" git add . git commit -m \"My first commit\" 2. Prepare your stack \u00b6 To be able to run your app, Heroku will need the following files: runtime.txt : Contains the version of Python you want to use. You can find the list of available versions at Heroku supported versions of Python . In this example, your runtime.txt should contain: python-3.9.10 Now you should save this file in your git repository by doing: git add runtime.txt git commit -m \"Add Heroku runtime requirement\" Procfile : The command launched by Heroku to start your application. If your entrypoint file is main.py , put in your Procfile : web: python main.py Now you should save this file in your git repository by doing: git add Procfile git commit -m \"Add Heroku Procfile requirement\" requirements.txt : The dependency file. See Virtual environments for details. Note: If you already have a requirements.txt file up to date in your Git, you can ignore this step. You can create this file by dumping all your dependencies then commit the file by doing: pip freeze > requirements.txt git add requirements.txt git commit -m \"Add dependencies file\" 3. Deployment \u00b6 In our example, we use the name my-taipy-app for our application. On Heroku, this name must be unique. Replace it everywhere by a custom value. heroku login heroku create my-taipy-app heroku git:remote -a <my-taipy-app> heroku config:set CLIENT_URL=\"https://<my-taipy-app>.herokuapp.com\" -a <my-taipy-app> git push heroku main Note: This example works if you are working on the main branch. If you are working on another branch you should run git push heroku <your-branch-name>:main check the official Heroku doc . 4. Check your deployment \u00b6 You can go to the url https://<my-taipy-app>.herokuapp.com in your browser or run heroku open -a <my-taipy-app> . Your application should be deployed correctly. 5. Clean up your resources \u00b6 Remove the Heroku application: heroku apps:destroy <my-taipy-app> --confirm <my-taipy-app>","title":"Based on Git"},{"location":"manuals/deployment/heroku/git/#deploy-a-taipy-application-based-on-git-with-heroku","text":"","title":"Deploy a Taipy application based on git with Heroku"},{"location":"manuals/deployment/heroku/git/#prerequisites","text":"Minimal knowledge of Git. Git must be installed, otherwise check the official documentation . Prepare your Taipy application Set up your Heroku environment","title":"Prerequisites"},{"location":"manuals/deployment/heroku/git/#1-add-version-control-to-your-application","text":"Note: This step is necessary only if your application doesn't already use Git. git init git config [--global] user.name \"Full Name\" git config [--global] user.email \"email@address.com\" git add . git commit -m \"My first commit\"","title":"1. Add version control to your application"},{"location":"manuals/deployment/heroku/git/#2-prepare-your-stack","text":"To be able to run your app, Heroku will need the following files: runtime.txt : Contains the version of Python you want to use. You can find the list of available versions at Heroku supported versions of Python . In this example, your runtime.txt should contain: python-3.9.10 Now you should save this file in your git repository by doing: git add runtime.txt git commit -m \"Add Heroku runtime requirement\" Procfile : The command launched by Heroku to start your application. If your entrypoint file is main.py , put in your Procfile : web: python main.py Now you should save this file in your git repository by doing: git add Procfile git commit -m \"Add Heroku Procfile requirement\" requirements.txt : The dependency file. See Virtual environments for details. Note: If you already have a requirements.txt file up to date in your Git, you can ignore this step. You can create this file by dumping all your dependencies then commit the file by doing: pip freeze > requirements.txt git add requirements.txt git commit -m \"Add dependencies file\"","title":"2. Prepare your stack"},{"location":"manuals/deployment/heroku/git/#3-deployment","text":"In our example, we use the name my-taipy-app for our application. On Heroku, this name must be unique. Replace it everywhere by a custom value. heroku login heroku create my-taipy-app heroku git:remote -a <my-taipy-app> heroku config:set CLIENT_URL=\"https://<my-taipy-app>.herokuapp.com\" -a <my-taipy-app> git push heroku main Note: This example works if you are working on the main branch. If you are working on another branch you should run git push heroku <your-branch-name>:main check the official Heroku doc .","title":"3. Deployment"},{"location":"manuals/deployment/heroku/git/#4-check-your-deployment","text":"You can go to the url https://<my-taipy-app>.herokuapp.com in your browser or run heroku open -a <my-taipy-app> . Your application should be deployed correctly.","title":"4. Check your deployment"},{"location":"manuals/deployment/heroku/git/#5-clean-up-your-resources","text":"Remove the Heroku application: heroku apps:destroy <my-taipy-app> --confirm <my-taipy-app>","title":"5. Clean up your resources"},{"location":"manuals/deployment/heroku/prepare-taipy-for-deployment/","text":"Prepare your application for deployment \u00b6 To deploy a Taipy application you must specify some options for the Services ( Gui or Rest ). These options can be provided from the environment or hard-coded. Taipy is based on Flask and allows customer to access the Flask application so it can be customized. Options \u00b6 port : Binding port for your application. By default, Taipy uses the port 5000. host : IP address that the application listens to. By default, Taipy uses the localhost . Other Flask options: See the Flash configuration page. Example \u00b6 In your Taipy application, you should have something that looks like: import taipy as tp # # Your code # rest = tp . Rest () gui = tp . Gui ( ... ) tp . run ( rest , gui , title = \"Taipy Demo\" ) To run on an Heroku remote environment, you must add the host and port parameters to the (taipy.)run()^ function, as required by Heroku: import os import taipy as tp # # Your code # rest = tp . Rest () gui = tp . Gui ( ... ) tp . run ( title = \"Taipy Demo\" , host = '0.0.0.0' , port = os . environ . get ( 'PORT' , '5000' ), )","title":"Prepare your application for deployment"},{"location":"manuals/deployment/heroku/prepare-taipy-for-deployment/#prepare-your-application-for-deployment","text":"To deploy a Taipy application you must specify some options for the Services ( Gui or Rest ). These options can be provided from the environment or hard-coded. Taipy is based on Flask and allows customer to access the Flask application so it can be customized.","title":"Prepare your application for deployment"},{"location":"manuals/deployment/heroku/prepare-taipy-for-deployment/#options","text":"port : Binding port for your application. By default, Taipy uses the port 5000. host : IP address that the application listens to. By default, Taipy uses the localhost . Other Flask options: See the Flash configuration page.","title":"Options"},{"location":"manuals/deployment/heroku/prepare-taipy-for-deployment/#example","text":"In your Taipy application, you should have something that looks like: import taipy as tp # # Your code # rest = tp . Rest () gui = tp . Gui ( ... ) tp . run ( rest , gui , title = \"Taipy Demo\" ) To run on an Heroku remote environment, you must add the host and port parameters to the (taipy.)run()^ function, as required by Heroku: import os import taipy as tp # # Your code # rest = tp . Rest () gui = tp . Gui ( ... ) tp . run ( title = \"Taipy Demo\" , host = '0.0.0.0' , port = os . environ . get ( 'PORT' , '5000' ), )","title":"Example"},{"location":"manuals/deployment/heroku/setup/","text":"Heroku setup \u00b6 1. Create an account on Heroku \u00b6 Go on Heroku Signup to create an account on Heroku. 2. Install the Heroku CLI \u00b6 To run commands that will provision your infrastructure, you should install the Heroku CLI. The complete documentation is available on the Heroku CLI page.","title":"Setup"},{"location":"manuals/deployment/heroku/setup/#heroku-setup","text":"","title":"Heroku setup"},{"location":"manuals/deployment/heroku/setup/#1-create-an-account-on-heroku","text":"Go on Heroku Signup to create an account on Heroku.","title":"1. Create an account on Heroku"},{"location":"manuals/deployment/heroku/setup/#2-install-the-heroku-cli","text":"To run commands that will provision your infrastructure, you should install the Heroku CLI. The complete documentation is available on the Heroku CLI page.","title":"2. Install the Heroku CLI"},{"location":"manuals/deployment/linux/redhat/","text":"Deploy your application with uWSGI and Nginx on Red Hat Enterprise Linux \u00b6 Red Hat is an Open Source leader providing an GNU/Linux operating system named RHEL that can run the Web Application Server uWSGI and the Web Server Nginx . Upgrading Python \u00b6 Most RHEL are delivered with a Python version older than 3.8 which is the oldest Python version supported by Taipy. If you are in that case, please install at least Python 3.8: sudo dnf install -y gcc openssl-devel bzip2-devel libffi-devel make wget https://www.python.org/ftp/python/3.8.12/Python-3.8.12.tgz tar xzf Python-3.8.12.tgz rm -rf Python-3.8.12.tgz cd Python-3.8.12 sudo ./configure --enable-optimizations sudo make altinstall cd .. sudo rm -r Python-3.8.12 Info This tutorial specifies the Python version for each command. If your default version is different, you must replace python3.8 with python . Prepare your machine \u00b6 The following software should be installed on your target machine: pip : for installing Python3 packages. uwsgi and gevent : the Web application server and its workers that will run the Taipy application. nginx : the Web server for the Internet exposition. You can install all of these packages by running the following command: sudo dnf install -y nginx python3.8 -m pip install uwsgi gevent sudo mv `pwd`/.local/bin/uwsgi /usr/bin/uwsgi sudo restorecon /usr/bin/uwsgi Run the application locally \u00b6 If you want to deploy the following application: from taipy import Gui Gui(page=\"# Getting started with *Taipy*\").run() This would be placed in a file called app.py . You need to create a requirements.txt file that contains: taipy On your local machine, start the application by doing: $ python3.8 -m pip install -r requirements.txt Collecting taipy ... Successfully installed taipy $ python3.8 app.py * Server starting on http://127.0.0.1:5000 * Serving Flask app 'Taipy' (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: on ... The application is running locally, you can access it with the browser on the URL http://127.0.0.1:5000/ . Note The message: WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. Is provided by Flask because the way of exposing an application on the Internet and developping an application locally is not the same, mainly for security and reliability reasons. This message will disappear when using the Web server. Prepare the application for deployment \u00b6 Deploying your application on a remote environment needs a little bit of configuration. By default, Taipy applications run in Debug mode. Before deploying your application to the Internet, you should turn off the Debug mode by setting the debug parameter or the (Gui.)run()^ to False. You must also inform Taipy not to run the application server on its own but rather delegate the execution by setting the parameter run_server to False. The name of the variable where the Web application is stored is used in the uWSGI configuration: this allows the Web server to load the Web application: from taipy import Gui gui_service = Gui(page=\"# Getting started with *Taipy*\") web_app = gui_service.run(debug=False, run_server=False) In our example, we store this application in the variable web_app (see line 3) Make sure you upload this code on your targeted machine and install your dependencies with pip . Important The entry point filename and the app variable name are important for the proper configuration of the uWSGI Web application server. Please, keep them as is or adapt the configuration. uWSGI application server \u00b6 To expose your application over the Internet, you must use uWSGI instead of Flask as the application server. You would then leverage Nginx to expose the application. uWSGI can be started manually. But, generally, it's better to start the application automatically when the machine starts. To order to do that, you should use Systemd which is installed by default on Ubuntu . From the directory where app.py is located, run the following command to generate an adapted file for Systemd : echo \"\"\" [Unit] Description=App After=syslog.target [Service] ExecStart=uwsgi --http 127.0.0.1:5000 --gevent 1000 --http-websockets --module app:web_app WorkingDirectory=`pwd` Restart=always KillSignal=SIGQUIT Type=notify StandardError=syslog NotifyAccess=all User=`whoami` [Install] WantedBy=multi-user.target \"\"\" > app.uwsgi.service Then transfer this file to the correct folder by doing: sudo mv app.uwsgi.service /etc/systemd/system/app.uwsgi.service Now, you can start your application automatically on startup time of your machine by doing: sudo restorecon /etc/systemd/system/app.uwsgi.service sudo systemctl daemon-reload sudo systemctl start app.uwsgi.service sudo systemctl enable app.uwsgi.service The application is now running locally but is not accessible yet from the Internet. Exposing to the Internet \u00b6 To expose your application on the Internet, you should use Nginx . Replace the content of /etc/nginx/nginx.conf by the following or: sudo wget https://docs.taipy.io/manuals/deployment/linux/redhat/nginx.conf -O /etc/nginx/nginx.conf Allow the communication between Nginx and uWSGI : sudo setsebool -P httpd_can_network_connect 1 Then restart Nginx : sudo systemctl restart nginx Note This configuration is only for HTTP. If you need an HTTPS connection, please read the Nginx documentation . Open the firewall \u00b6 Your application is ready to receive traffic from the Internet, but your firewall still blocks the communication. Open the http port that is (i.e. port 80 ): sudo firewall-cmd --zone=public --add-port=80/tcp --permanent sudo firewall-cmd --reload Your application is now accessible over the Internet!","title":"RHEL"},{"location":"manuals/deployment/linux/redhat/#deploy-your-application-with-uwsgi-and-nginx-on-red-hat-enterprise-linux","text":"Red Hat is an Open Source leader providing an GNU/Linux operating system named RHEL that can run the Web Application Server uWSGI and the Web Server Nginx .","title":"Deploy your application with uWSGI and Nginx on Red Hat Enterprise Linux"},{"location":"manuals/deployment/linux/redhat/#upgrading-python","text":"Most RHEL are delivered with a Python version older than 3.8 which is the oldest Python version supported by Taipy. If you are in that case, please install at least Python 3.8: sudo dnf install -y gcc openssl-devel bzip2-devel libffi-devel make wget https://www.python.org/ftp/python/3.8.12/Python-3.8.12.tgz tar xzf Python-3.8.12.tgz rm -rf Python-3.8.12.tgz cd Python-3.8.12 sudo ./configure --enable-optimizations sudo make altinstall cd .. sudo rm -r Python-3.8.12 Info This tutorial specifies the Python version for each command. If your default version is different, you must replace python3.8 with python .","title":"Upgrading Python"},{"location":"manuals/deployment/linux/redhat/#prepare-your-machine","text":"The following software should be installed on your target machine: pip : for installing Python3 packages. uwsgi and gevent : the Web application server and its workers that will run the Taipy application. nginx : the Web server for the Internet exposition. You can install all of these packages by running the following command: sudo dnf install -y nginx python3.8 -m pip install uwsgi gevent sudo mv `pwd`/.local/bin/uwsgi /usr/bin/uwsgi sudo restorecon /usr/bin/uwsgi","title":"Prepare your machine"},{"location":"manuals/deployment/linux/redhat/#run-the-application-locally","text":"If you want to deploy the following application: from taipy import Gui Gui(page=\"# Getting started with *Taipy*\").run() This would be placed in a file called app.py . You need to create a requirements.txt file that contains: taipy On your local machine, start the application by doing: $ python3.8 -m pip install -r requirements.txt Collecting taipy ... Successfully installed taipy $ python3.8 app.py * Server starting on http://127.0.0.1:5000 * Serving Flask app 'Taipy' (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: on ... The application is running locally, you can access it with the browser on the URL http://127.0.0.1:5000/ . Note The message: WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. Is provided by Flask because the way of exposing an application on the Internet and developping an application locally is not the same, mainly for security and reliability reasons. This message will disappear when using the Web server.","title":"Run the application locally"},{"location":"manuals/deployment/linux/redhat/#prepare-the-application-for-deployment","text":"Deploying your application on a remote environment needs a little bit of configuration. By default, Taipy applications run in Debug mode. Before deploying your application to the Internet, you should turn off the Debug mode by setting the debug parameter or the (Gui.)run()^ to False. You must also inform Taipy not to run the application server on its own but rather delegate the execution by setting the parameter run_server to False. The name of the variable where the Web application is stored is used in the uWSGI configuration: this allows the Web server to load the Web application: from taipy import Gui gui_service = Gui(page=\"# Getting started with *Taipy*\") web_app = gui_service.run(debug=False, run_server=False) In our example, we store this application in the variable web_app (see line 3) Make sure you upload this code on your targeted machine and install your dependencies with pip . Important The entry point filename and the app variable name are important for the proper configuration of the uWSGI Web application server. Please, keep them as is or adapt the configuration.","title":"Prepare the application for deployment"},{"location":"manuals/deployment/linux/redhat/#uwsgi-application-server","text":"To expose your application over the Internet, you must use uWSGI instead of Flask as the application server. You would then leverage Nginx to expose the application. uWSGI can be started manually. But, generally, it's better to start the application automatically when the machine starts. To order to do that, you should use Systemd which is installed by default on Ubuntu . From the directory where app.py is located, run the following command to generate an adapted file for Systemd : echo \"\"\" [Unit] Description=App After=syslog.target [Service] ExecStart=uwsgi --http 127.0.0.1:5000 --gevent 1000 --http-websockets --module app:web_app WorkingDirectory=`pwd` Restart=always KillSignal=SIGQUIT Type=notify StandardError=syslog NotifyAccess=all User=`whoami` [Install] WantedBy=multi-user.target \"\"\" > app.uwsgi.service Then transfer this file to the correct folder by doing: sudo mv app.uwsgi.service /etc/systemd/system/app.uwsgi.service Now, you can start your application automatically on startup time of your machine by doing: sudo restorecon /etc/systemd/system/app.uwsgi.service sudo systemctl daemon-reload sudo systemctl start app.uwsgi.service sudo systemctl enable app.uwsgi.service The application is now running locally but is not accessible yet from the Internet.","title":"uWSGI application server"},{"location":"manuals/deployment/linux/redhat/#exposing-to-the-internet","text":"To expose your application on the Internet, you should use Nginx . Replace the content of /etc/nginx/nginx.conf by the following or: sudo wget https://docs.taipy.io/manuals/deployment/linux/redhat/nginx.conf -O /etc/nginx/nginx.conf Allow the communication between Nginx and uWSGI : sudo setsebool -P httpd_can_network_connect 1 Then restart Nginx : sudo systemctl restart nginx Note This configuration is only for HTTP. If you need an HTTPS connection, please read the Nginx documentation .","title":"Exposing to the Internet"},{"location":"manuals/deployment/linux/redhat/#open-the-firewall","text":"Your application is ready to receive traffic from the Internet, but your firewall still blocks the communication. Open the http port that is (i.e. port 80 ): sudo firewall-cmd --zone=public --add-port=80/tcp --permanent sudo firewall-cmd --reload Your application is now accessible over the Internet!","title":"Open the firewall"},{"location":"manuals/deployment/linux/ubuntu/","text":"Deploy your application with uWSGI and Nginx on Ubuntu \u00b6 Ubuntu is a GNU/Linux operating system that can run the Web Application Server uWSGI and the Web Server Nginx . For Ubuntu version before 20.04 \u00b6 Before Ubuntu 20.04 , the pre-installed Python version is older than Python3.8 which is the oldest Python version supported by Taipy. If you are in that case, please install at least Python3.8. Prepare your machine \u00b6 The following software should be installed on your target machine: pip : for installing Python3 packages. uwsgi and gevent : the Web application server and its workers that will run the Taipy application. nginx : the Web server for the Internet exposition. You can install all of these packages by running the following command: sudo apt update -y sudo apt install -y python3-pip nginx sudo pip install uwsgi gevent sudo ln -s `pwd`/.local/bin/uwsgi /usr/bin/uwsgi Run the application locally \u00b6 If you want to deploy the following application: from taipy import Gui Gui(page=\"# Getting started with *Taipy*\").run() This would be placed in a file called app.py . You need to create a requirements.txt file that contains: taipy On your local machine, start the application by doing: $ pip install -r requirements.txt Collecting taipy <-- Truncate --> Successfully installed taipy $ python app.py * Server starting on http://127.0.0.1:5000 * Serving Flask app 'Taipy' (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: on <-- Truncate --> The application is running locally, you can access it with the browser on the URL http://127.0.0.1:5000/ . Note The message: WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. Is provided by Flask because the way of exposing an application on the Internet and developping an application locally is not the same, mainly for security and reliability reasons. This message will disappear when using the Web server. Prepare the application for deployment \u00b6 Deploying your application to a remote environment needs a little bit of configuration. By default, Taipy applications run in Debug mode. Before deploying your application to the Internet, you should turn off the Debug mode by setting the debug parameter or the (Gui.)run()^ to False. You must also inform Taipy not to run the application server on its own but rather delegate the execution by setting the parameter run_server to False. The name of the variable where the Web application is stored is used in the uWSGI configuration: this allows the Web server to load the Web application: from taipy import Gui gui_service = Gui(page=\"# Getting started with *Taipy*\") web_app = gui_service.run(debug=False, run_server=False) In our example, we store this application in the variable web_app (see line 3) Make sure you upload this code on your targeted machine and install your dependencies with pip . Important The entry point filename and the app variable name are important for the proper configuration of the uWSGI Web application server. Please, keep them as is or adapt the configuration. uWSGI application server \u00b6 To expose your application over the Internet, you must use uWSGI instead of Flask as the application server. You would then leverage Nginx to expose the application. uWSGI can be started manually. But, generally, it's better to start the application automatically when the machine starts. To order to do that, you should use Systemd which is installed by default on Ubuntu . From the directory where app.py is located, run the following command to generate an adapted file for Systemd : echo \"\"\" [Unit] Description=App After=syslog.target [Service] ExecStart=uwsgi --http 127.0.0.1:5000 --gevent 1000 --http-websockets --module app:web_app WorkingDirectory=`pwd` Restart=always KillSignal=SIGQUIT Type=notify StandardError=syslog NotifyAccess=all User=`whoami` [Install] WantedBy=multi-user.target \"\"\" > app.uwsgi.service Then transfer this file in the correct folder by doing: sudo mv app.uwsgi.service /etc/systemd/system/app.uwsgi.service Now, you can start your application automatically on startup time of your machine by doing: sudo systemctl start app.uwsgi.service sudo systemctl enable app.uwsgi.service The application is now running locally but is not accessible yet from the Internet. Exposing to the Internet \u00b6 To expose your application on the Internet, you should use Nginx . Change the content of /etc/nginx/sites-enabled/default with the following: server { listen 80; location / { proxy_pass http://localhost:5000; proxy_set_header Upgrade $http_upgrade; proxy_set_header Host $host; } } Then restart Nginx : sudo systemctl restart nginx Your application is now accessible over the Internet! Note This configuration is only for HTTP. If you need an HTTPS connection, please read the Nginx documentation .","title":"Ubuntu"},{"location":"manuals/deployment/linux/ubuntu/#deploy-your-application-with-uwsgi-and-nginx-on-ubuntu","text":"Ubuntu is a GNU/Linux operating system that can run the Web Application Server uWSGI and the Web Server Nginx .","title":"Deploy your application with uWSGI and Nginx on Ubuntu"},{"location":"manuals/deployment/linux/ubuntu/#for-ubuntu-version-before-2004","text":"Before Ubuntu 20.04 , the pre-installed Python version is older than Python3.8 which is the oldest Python version supported by Taipy. If you are in that case, please install at least Python3.8.","title":"For Ubuntu version before 20.04"},{"location":"manuals/deployment/linux/ubuntu/#prepare-your-machine","text":"The following software should be installed on your target machine: pip : for installing Python3 packages. uwsgi and gevent : the Web application server and its workers that will run the Taipy application. nginx : the Web server for the Internet exposition. You can install all of these packages by running the following command: sudo apt update -y sudo apt install -y python3-pip nginx sudo pip install uwsgi gevent sudo ln -s `pwd`/.local/bin/uwsgi /usr/bin/uwsgi","title":"Prepare your machine"},{"location":"manuals/deployment/linux/ubuntu/#run-the-application-locally","text":"If you want to deploy the following application: from taipy import Gui Gui(page=\"# Getting started with *Taipy*\").run() This would be placed in a file called app.py . You need to create a requirements.txt file that contains: taipy On your local machine, start the application by doing: $ pip install -r requirements.txt Collecting taipy <-- Truncate --> Successfully installed taipy $ python app.py * Server starting on http://127.0.0.1:5000 * Serving Flask app 'Taipy' (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: on <-- Truncate --> The application is running locally, you can access it with the browser on the URL http://127.0.0.1:5000/ . Note The message: WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. Is provided by Flask because the way of exposing an application on the Internet and developping an application locally is not the same, mainly for security and reliability reasons. This message will disappear when using the Web server.","title":"Run the application locally"},{"location":"manuals/deployment/linux/ubuntu/#prepare-the-application-for-deployment","text":"Deploying your application to a remote environment needs a little bit of configuration. By default, Taipy applications run in Debug mode. Before deploying your application to the Internet, you should turn off the Debug mode by setting the debug parameter or the (Gui.)run()^ to False. You must also inform Taipy not to run the application server on its own but rather delegate the execution by setting the parameter run_server to False. The name of the variable where the Web application is stored is used in the uWSGI configuration: this allows the Web server to load the Web application: from taipy import Gui gui_service = Gui(page=\"# Getting started with *Taipy*\") web_app = gui_service.run(debug=False, run_server=False) In our example, we store this application in the variable web_app (see line 3) Make sure you upload this code on your targeted machine and install your dependencies with pip . Important The entry point filename and the app variable name are important for the proper configuration of the uWSGI Web application server. Please, keep them as is or adapt the configuration.","title":"Prepare the application for deployment"},{"location":"manuals/deployment/linux/ubuntu/#uwsgi-application-server","text":"To expose your application over the Internet, you must use uWSGI instead of Flask as the application server. You would then leverage Nginx to expose the application. uWSGI can be started manually. But, generally, it's better to start the application automatically when the machine starts. To order to do that, you should use Systemd which is installed by default on Ubuntu . From the directory where app.py is located, run the following command to generate an adapted file for Systemd : echo \"\"\" [Unit] Description=App After=syslog.target [Service] ExecStart=uwsgi --http 127.0.0.1:5000 --gevent 1000 --http-websockets --module app:web_app WorkingDirectory=`pwd` Restart=always KillSignal=SIGQUIT Type=notify StandardError=syslog NotifyAccess=all User=`whoami` [Install] WantedBy=multi-user.target \"\"\" > app.uwsgi.service Then transfer this file in the correct folder by doing: sudo mv app.uwsgi.service /etc/systemd/system/app.uwsgi.service Now, you can start your application automatically on startup time of your machine by doing: sudo systemctl start app.uwsgi.service sudo systemctl enable app.uwsgi.service The application is now running locally but is not accessible yet from the Internet.","title":"uWSGI application server"},{"location":"manuals/deployment/linux/ubuntu/#exposing-to-the-internet","text":"To expose your application on the Internet, you should use Nginx . Change the content of /etc/nginx/sites-enabled/default with the following: server { listen 80; location / { proxy_pass http://localhost:5000; proxy_set_header Upgrade $http_upgrade; proxy_set_header Host $host; } } Then restart Nginx : sudo systemctl restart nginx Your application is now accessible over the Internet! Note This configuration is only for HTTP. If you need an HTTPS connection, please read the Nginx documentation .","title":"Exposing to the Internet"},{"location":"manuals/gui/","text":"Taipy's User Interface \u00b6 The Taipy GUI library provides Python classes that make it easy to create powerful Web apps in minutes. What is a graphical user interface? \u00b6 A graphical user interface (or GUI) displays and organizes graphic elements on the user's device. These elements represent application data and allow users to interact with the application code. There are mechanisms in place to install communication between the server, running at the heart of the application, and the graphical interface presented to end-users. Main concepts \u00b6 In Taipy, GUIs are made of generated Web pages served by a Web server hosted by the Taipy application itself (or on which the Taipy application relies). Taipy provides the class Gui^ that handles this server and its settings. The Gui^ class holds any number of pages , where text and graphical elements can be placed. These elements can reflect the state of your application variables so the end-user can be presented with relevant information. Users can also interact with some of those elements to trigger application code that can change the displayed information, produce more data to visualize or move to a completely different page. The generated Web pages are built from a set of template text files that you provide, where you would have planted placeholders that will display application data. The application end users can then see and interact with the application. We call these representative and interactive objects: visual elements . To describe the content of pages, Taipy comes the support for two template formats, handled by the classes Markdown^ and Html^ . The basic principle is that you create pages as you need them, give them a name so you can indicate to your browser how to access these pages, and provide these pages to the Gui^ instance used in your application. When you invoke the (Gui.)run()^ method of the Gui^ , a Web server is started and allows Web clients to connect to it then request pages. This is when Taipy transforms the page you had created into some HTML content sent back to the client so the user can see the application interface and start using it. You can find more information on how pages are created and used in Taipy application in the Pages section.","title":"Taipy's User Interface"},{"location":"manuals/gui/#taipys-user-interface","text":"The Taipy GUI library provides Python classes that make it easy to create powerful Web apps in minutes.","title":"Taipy's User Interface"},{"location":"manuals/gui/#what-is-a-graphical-user-interface","text":"A graphical user interface (or GUI) displays and organizes graphic elements on the user's device. These elements represent application data and allow users to interact with the application code. There are mechanisms in place to install communication between the server, running at the heart of the application, and the graphical interface presented to end-users.","title":"What is a graphical user interface?"},{"location":"manuals/gui/#main-concepts","text":"In Taipy, GUIs are made of generated Web pages served by a Web server hosted by the Taipy application itself (or on which the Taipy application relies). Taipy provides the class Gui^ that handles this server and its settings. The Gui^ class holds any number of pages , where text and graphical elements can be placed. These elements can reflect the state of your application variables so the end-user can be presented with relevant information. Users can also interact with some of those elements to trigger application code that can change the displayed information, produce more data to visualize or move to a completely different page. The generated Web pages are built from a set of template text files that you provide, where you would have planted placeholders that will display application data. The application end users can then see and interact with the application. We call these representative and interactive objects: visual elements . To describe the content of pages, Taipy comes the support for two template formats, handled by the classes Markdown^ and Html^ . The basic principle is that you create pages as you need them, give them a name so you can indicate to your browser how to access these pages, and provide these pages to the Gui^ instance used in your application. When you invoke the (Gui.)run()^ method of the Gui^ , a Web server is started and allows Web clients to connect to it then request pages. This is when Taipy transforms the page you had created into some HTML content sent back to the client so the user can see the application interface and start using it. You can find more information on how pages are created and used in Taipy application in the Pages section.","title":"Main concepts"},{"location":"manuals/gui/binding/","text":"Binding variables \u00b6 It will often be useful to display information from the application. To achieve this goal, Taipy allows visual elements to relate directly to application variables, display their values, and change those variable values. Consider the following application: 1 2 3 4 5 6 7 8 9 from taipy import Gui x = 1234 Gui ( page = \"\"\" # Hello Taipy The variable `x` contains the value <| {x} |>. \"\"\" ) . run () When this program runs (and a Web browser is directed to the running server), the root page displays the value of the variable x , as it was defined in your code. Expressions \u00b6 Values that you can use in controls and blocks can be more than raw variable values. You can create complete expressions, just like you would use in the f-string feature (available since Python 3). In the code above, you could replace <|{x}|> by <|{x*2}|> , and the double of x will be displayed on your page. Arbitrary expressions You can create complex expressions such as |{x} and {y}| to concatenate two variable values, or whatever your imagination and application requirements are. Formatting F-string formatting is also available in property value expressions: If you have declared pi = 3.141592653597 , then <|Pi is {pi:.4f}|> will display the text: Pi is 3.1416 . If you have v = 64177 , then <|dec:{v}, oct:{v:08o}, hex:{v:X}|> will result in displaying the text: dec:64177, oct:00175261, hex:FAB1 . Note that since HTML text eliminates non-significant white space, the right-justification format ( {string:>n} ) does not impact the resulting display. List of values \u00b6 Some controls (such as selector or tree ) represent one or several values stored in a list of values (or LoV , for short). This notion is a way of describing a set of values that controls can show and select. Each item in a list of values can hold: An identifier: an optional string that uniquely identifies an item in the entire list; A label: a string that is used when displaying the specific item; An image: an optional Icon^ that can be used to display the item as a small image. Note that icons can also hold a descriptive string. A LoV can have different types, depending on the use case: List of strings: if your items are just a series of strings, you can create a LoV as a List[str] or a single string, where item labels are separated by a semicolon (';'); List with identifier: in situations where items labels may appear several times in the same LoV , you will need a unique identifier to specify which item is represented. In this situation, the LoV will be a list of tuples where each tuple will contain: A unique identifier as the first item; A label as the second item. Therefore, the Python type of such a LoV is List[Tuple[str, str]]. List with images: if you need to represent items with images, you will create a LoV that is a list of tuples where each tuple will contain: A unique identifier as the first item; An Icon^ as the second item. The Python type of such a _lov is: List[Tuple[str, Icon^ ]]. The \"selected\" value in controls that use LoV_s are handled in their _value property. This will be the original value of the selection in the LoV unless your control has set the property value_by_id to True, then the selected value will be the unique identifier of the value in the LoV . Custom LoVs \u00b6 You can create a LoV from any series of objects. In this situation, you will provide the control with your list of objects in the property lov , and an adapter function that transforms each item of the list into a tuple that the control can use as a 'regular' LoV . An adapter is a Python function that receives each object of a LoV and that must return a tuple similar to the ones used in 'regular' _LoV_s. Example Suppose you want to display a control representing versions of the Python programming language. You want to display this list in selector and let users select a given version. The list of values is an ordered list of descriptors: python_versions = [ { \"name\" : \"0.9.0\" , \"date\" : 1991 }, { \"name\" : \"1.0\" , \"date\" : 1994 }, { \"name\" : \"1.1\" , \"date\" : 1994 }, { \"name\" : \"1.6\" , \"date\" : 2000 }, { \"name\" : \"2.0\" , \"date\" : 2000 }, { \"name\" : \"2.2\" , \"date\" : 2001 }, { \"name\" : \"2.3\" , \"date\" : 2003 }, { \"name\" : \"2.7\" , \"date\" : 2010 }, { \"name\" : \"3.0\" , \"date\" : 2008 }, { \"name\" : \"3.4\" , \"date\" : 2014 }, { \"name\" : \"3.8\" , \"date\" : 2019 }, { \"name\" : \"3.9\" , \"date\" : 2020 }, { \"name\" : \"3.10\" , \"date\" : 2021 } ] You need to represent each item as: \"Version <version name> (<version date>)\". The identifier for each version will be its name, which is unique. The adapter you need to write would look like this: def python_version_adapter ( version ): return ( version [ \"name\" ], f \"Version { version [ \"name\" ] } ( { version [ \"date\" ] } )\" ) LoV for trees \u00b6 The tree control needs an additional item in each value of the LoV : each element of the LoV represents a node in the tree, and the additional element in each node's tuple must hold the child nodes as another LoV , or None if it does not have any. Here is an example of how a LoV for trees can be created. We want to provide a control that allows the selection of a musical instrument from a tree control where instruments are classified: selected_intrument = None intruments = [ ( \"c1\" , \"Idiophones\" , [ ( \"t1-1\" , \"Concussion\" , [ \"Claves\" , \"Spoons\" ]), ( \"t1-2\" , \"Percussion\" , [ \"Triangle\" , \"Marimba\" , \"Xylophone\" ]), ( \"t1-3\" , \"Plucked\" , [ \"Pizzicato \" ]) ]), ( \"c2\" , \"Membranophones\" , [ ( \"t2-1\" , \"Cylindrical drums\" , [ \"Bass drum\" , \"Dohol\" ]), ( \"t2-2\" , \"Conical drum\" , [ \"Timbal\" ]), ( \"t2-3\" , \"Barrel drum\" , [ \"Dholak\" , \"Glong thad\" ]) ]), ( \"c3\" , \"Chordophones\" , [ ( \"t3-1\" , \"Plucked\" , [ \"Guitar\" , \"Harp\" , \"Mandolin\" ]), ( \"t3-2\" , \"Bowed\" , [ \"Violin\" , \"Cello\" , \"Jinghu\" ]) ]), ( \"c4\" , \"Aerophones\" , [ ( \"t4-1\" , \"Flute\" , [ \"Piccolo\" , \"Bansuri\" , \"Transverse flute\" ]), ( \"t4-2\" , \"Reed\" , [ \"Bassoon\" , \"Oboe\" , \"Clarinet\" ]), ( \"t4-3\" , \"Brass\" , [ \"Trombone\" , \"Trumpet\" , \"Cornett\" ]) ]) ] The tree items are stored in the variable instruments , and selected_instrument will be bound to the tree selection. The Markdown fragment that would be used in a page would look like this: <|{selected_intrument}|tree|lov={intruments}|> Tabular values \u00b6 The chart and table controls represent tabular data. This data can be provided as a Pandas DataFrame , a list, a NumPy array , or a dictionary. When a variable containing such tabular data is bound to a control, it is internally transformed into a Pandas DataFrame so one can specify which series of data should be used by a control bound to that data: for a table, you can indicate which data a column displays. In a chart, you can have different traces for different series in the same graph. Note that the Python list comprehension syntax (i.e. expressions such as [x for x in range(0, 10)] ) is appropriately handled, as long as the returned type is one of the supported types. Such expressions can even be inlined directly in the definition of the properties of your control. This is how Taipy internally stores the tabular data: If the data is a dictionary, Taipy creates a DataFrame directly from it. If the data is a list of scalar values, Taipy creates a DataFrame with a single column called '0'. If the data is a list of lists: If all the lists have the same length, then Taipy creates a DataFrame with one column for each list, in the order of the list data. The column names are the list index. If the lengths of the lists differ, Taipy creates an internal list of DataFrames, that each has one single column. The name of the DataFrame column is <index>/0, where <index> is the index of the list in the original data list. List of lists in charts To display several traces within the same chart control, you must use a list of tabular values. Column names When dealing with a list of tabular data, you need to access the name of the data columns to provide them to the controls that use them. To select a column for a control, you must provide the name of this column, prefixed with the index of the data and a slash character. For example, suppose your data set is defined with the following Python code: dataframe_1 = pd . DataFrame ({ 'x' : [ i for i in range ( 10 )], 'y' : [ i for i in range ( 10 )]} ) dataframe_2 = pd . DataFrame ({ 'x' : [ i for i in range ( 10 )], 'y' : [ i * i for i in range ( 10 )]}) data = [ dataframe_1 , dataframe_2 ] In controls that are bound to data , the name of the 'y' column of the second DataFrame must be the string \"1/y\" . Lambda expressions \u00b6 Some control properties can be assigned lambda expressions to simplify the code. You can, for example, bind a lambda function to the on_action property of a control. Here is how you can do this with Markdown: <|Action|button|on_action={lambda state: ...}|> The lambda expression receives the same parameters as the regular on_action callback function. Because Python prevents any assignment from being performed in the body of a lambda expression, you cannot update the state object directly. However, the State^ class exposes the method (State.)assign()^ that allows working around that limitation. Here is how you can change the value of the variable toggle directly from the Markdown definition of your page, within the body of the definition of a button: <|Toggle|button|on_action={lambda state: s.assign(\"toggle\", not state.toggle)}|> Pressing the button will toggle the value of the toggle variable.","title":"Binding variables"},{"location":"manuals/gui/binding/#binding-variables","text":"It will often be useful to display information from the application. To achieve this goal, Taipy allows visual elements to relate directly to application variables, display their values, and change those variable values. Consider the following application: 1 2 3 4 5 6 7 8 9 from taipy import Gui x = 1234 Gui ( page = \"\"\" # Hello Taipy The variable `x` contains the value <| {x} |>. \"\"\" ) . run () When this program runs (and a Web browser is directed to the running server), the root page displays the value of the variable x , as it was defined in your code.","title":"Binding variables"},{"location":"manuals/gui/binding/#expressions","text":"Values that you can use in controls and blocks can be more than raw variable values. You can create complete expressions, just like you would use in the f-string feature (available since Python 3). In the code above, you could replace <|{x}|> by <|{x*2}|> , and the double of x will be displayed on your page. Arbitrary expressions You can create complex expressions such as |{x} and {y}| to concatenate two variable values, or whatever your imagination and application requirements are. Formatting F-string formatting is also available in property value expressions: If you have declared pi = 3.141592653597 , then <|Pi is {pi:.4f}|> will display the text: Pi is 3.1416 . If you have v = 64177 , then <|dec:{v}, oct:{v:08o}, hex:{v:X}|> will result in displaying the text: dec:64177, oct:00175261, hex:FAB1 . Note that since HTML text eliminates non-significant white space, the right-justification format ( {string:>n} ) does not impact the resulting display.","title":"Expressions"},{"location":"manuals/gui/binding/#list-of-values","text":"Some controls (such as selector or tree ) represent one or several values stored in a list of values (or LoV , for short). This notion is a way of describing a set of values that controls can show and select. Each item in a list of values can hold: An identifier: an optional string that uniquely identifies an item in the entire list; A label: a string that is used when displaying the specific item; An image: an optional Icon^ that can be used to display the item as a small image. Note that icons can also hold a descriptive string. A LoV can have different types, depending on the use case: List of strings: if your items are just a series of strings, you can create a LoV as a List[str] or a single string, where item labels are separated by a semicolon (';'); List with identifier: in situations where items labels may appear several times in the same LoV , you will need a unique identifier to specify which item is represented. In this situation, the LoV will be a list of tuples where each tuple will contain: A unique identifier as the first item; A label as the second item. Therefore, the Python type of such a LoV is List[Tuple[str, str]]. List with images: if you need to represent items with images, you will create a LoV that is a list of tuples where each tuple will contain: A unique identifier as the first item; An Icon^ as the second item. The Python type of such a _lov is: List[Tuple[str, Icon^ ]]. The \"selected\" value in controls that use LoV_s are handled in their _value property. This will be the original value of the selection in the LoV unless your control has set the property value_by_id to True, then the selected value will be the unique identifier of the value in the LoV .","title":"List of values"},{"location":"manuals/gui/binding/#custom-lovs","text":"You can create a LoV from any series of objects. In this situation, you will provide the control with your list of objects in the property lov , and an adapter function that transforms each item of the list into a tuple that the control can use as a 'regular' LoV . An adapter is a Python function that receives each object of a LoV and that must return a tuple similar to the ones used in 'regular' _LoV_s. Example Suppose you want to display a control representing versions of the Python programming language. You want to display this list in selector and let users select a given version. The list of values is an ordered list of descriptors: python_versions = [ { \"name\" : \"0.9.0\" , \"date\" : 1991 }, { \"name\" : \"1.0\" , \"date\" : 1994 }, { \"name\" : \"1.1\" , \"date\" : 1994 }, { \"name\" : \"1.6\" , \"date\" : 2000 }, { \"name\" : \"2.0\" , \"date\" : 2000 }, { \"name\" : \"2.2\" , \"date\" : 2001 }, { \"name\" : \"2.3\" , \"date\" : 2003 }, { \"name\" : \"2.7\" , \"date\" : 2010 }, { \"name\" : \"3.0\" , \"date\" : 2008 }, { \"name\" : \"3.4\" , \"date\" : 2014 }, { \"name\" : \"3.8\" , \"date\" : 2019 }, { \"name\" : \"3.9\" , \"date\" : 2020 }, { \"name\" : \"3.10\" , \"date\" : 2021 } ] You need to represent each item as: \"Version <version name> (<version date>)\". The identifier for each version will be its name, which is unique. The adapter you need to write would look like this: def python_version_adapter ( version ): return ( version [ \"name\" ], f \"Version { version [ \"name\" ] } ( { version [ \"date\" ] } )\" )","title":"Custom LoVs"},{"location":"manuals/gui/binding/#lov-for-trees","text":"The tree control needs an additional item in each value of the LoV : each element of the LoV represents a node in the tree, and the additional element in each node's tuple must hold the child nodes as another LoV , or None if it does not have any. Here is an example of how a LoV for trees can be created. We want to provide a control that allows the selection of a musical instrument from a tree control where instruments are classified: selected_intrument = None intruments = [ ( \"c1\" , \"Idiophones\" , [ ( \"t1-1\" , \"Concussion\" , [ \"Claves\" , \"Spoons\" ]), ( \"t1-2\" , \"Percussion\" , [ \"Triangle\" , \"Marimba\" , \"Xylophone\" ]), ( \"t1-3\" , \"Plucked\" , [ \"Pizzicato \" ]) ]), ( \"c2\" , \"Membranophones\" , [ ( \"t2-1\" , \"Cylindrical drums\" , [ \"Bass drum\" , \"Dohol\" ]), ( \"t2-2\" , \"Conical drum\" , [ \"Timbal\" ]), ( \"t2-3\" , \"Barrel drum\" , [ \"Dholak\" , \"Glong thad\" ]) ]), ( \"c3\" , \"Chordophones\" , [ ( \"t3-1\" , \"Plucked\" , [ \"Guitar\" , \"Harp\" , \"Mandolin\" ]), ( \"t3-2\" , \"Bowed\" , [ \"Violin\" , \"Cello\" , \"Jinghu\" ]) ]), ( \"c4\" , \"Aerophones\" , [ ( \"t4-1\" , \"Flute\" , [ \"Piccolo\" , \"Bansuri\" , \"Transverse flute\" ]), ( \"t4-2\" , \"Reed\" , [ \"Bassoon\" , \"Oboe\" , \"Clarinet\" ]), ( \"t4-3\" , \"Brass\" , [ \"Trombone\" , \"Trumpet\" , \"Cornett\" ]) ]) ] The tree items are stored in the variable instruments , and selected_instrument will be bound to the tree selection. The Markdown fragment that would be used in a page would look like this: <|{selected_intrument}|tree|lov={intruments}|>","title":"LoV for trees"},{"location":"manuals/gui/binding/#tabular-values","text":"The chart and table controls represent tabular data. This data can be provided as a Pandas DataFrame , a list, a NumPy array , or a dictionary. When a variable containing such tabular data is bound to a control, it is internally transformed into a Pandas DataFrame so one can specify which series of data should be used by a control bound to that data: for a table, you can indicate which data a column displays. In a chart, you can have different traces for different series in the same graph. Note that the Python list comprehension syntax (i.e. expressions such as [x for x in range(0, 10)] ) is appropriately handled, as long as the returned type is one of the supported types. Such expressions can even be inlined directly in the definition of the properties of your control. This is how Taipy internally stores the tabular data: If the data is a dictionary, Taipy creates a DataFrame directly from it. If the data is a list of scalar values, Taipy creates a DataFrame with a single column called '0'. If the data is a list of lists: If all the lists have the same length, then Taipy creates a DataFrame with one column for each list, in the order of the list data. The column names are the list index. If the lengths of the lists differ, Taipy creates an internal list of DataFrames, that each has one single column. The name of the DataFrame column is <index>/0, where <index> is the index of the list in the original data list. List of lists in charts To display several traces within the same chart control, you must use a list of tabular values. Column names When dealing with a list of tabular data, you need to access the name of the data columns to provide them to the controls that use them. To select a column for a control, you must provide the name of this column, prefixed with the index of the data and a slash character. For example, suppose your data set is defined with the following Python code: dataframe_1 = pd . DataFrame ({ 'x' : [ i for i in range ( 10 )], 'y' : [ i for i in range ( 10 )]} ) dataframe_2 = pd . DataFrame ({ 'x' : [ i for i in range ( 10 )], 'y' : [ i * i for i in range ( 10 )]}) data = [ dataframe_1 , dataframe_2 ] In controls that are bound to data , the name of the 'y' column of the second DataFrame must be the string \"1/y\" .","title":"Tabular values"},{"location":"manuals/gui/binding/#lambda-expressions","text":"Some control properties can be assigned lambda expressions to simplify the code. You can, for example, bind a lambda function to the on_action property of a control. Here is how you can do this with Markdown: <|Action|button|on_action={lambda state: ...}|> The lambda expression receives the same parameters as the regular on_action callback function. Because Python prevents any assignment from being performed in the body of a lambda expression, you cannot update the state object directly. However, the State^ class exposes the method (State.)assign()^ that allows working around that limitation. Here is how you can change the value of the variable toggle directly from the Markdown definition of your page, within the body of the definition of a button: <|Toggle|button|on_action={lambda state: s.assign(\"toggle\", not state.toggle)}|> Pressing the button will toggle the value of the toggle variable.","title":"Lambda expressions"},{"location":"manuals/gui/blocks/","text":"Blocks \u00b6 Blocks are visual elements that allow for grouping user interface elements. Blocks list \u00b6 Here is the list of all available block elements in Taipy: part Displays its children in a block. expandable Displays its child elements in a collapsable area. layout Organizes its children into cells in a regular grid. pane A side pane.","title":"Blocks"},{"location":"manuals/gui/blocks/#blocks","text":"Blocks are visual elements that allow for grouping user interface elements.","title":"Blocks"},{"location":"manuals/gui/blocks/#blocks-list","text":"Here is the list of all available block elements in Taipy: part Displays its children in a block. expandable Displays its child elements in a collapsable area. layout Organizes its children into cells in a regular grid. pane A side pane.","title":"Blocks list"},{"location":"manuals/gui/callbacks/","text":"Callbacks \u00b6 Callbacks are functions that are created in the application that are invoked in response to user actions in generated pages or other events that the Web browser requires that the application handles. Every callback function receives a State^ object as its first parameter. This object reflects the state of the application variables, for a given end-user: your application may be used simultaneously by different users connected to the same Web server (note that setting the single_client configuration parameter to False - as explained in the Configuration section - prevents multiple users from connecting to your application simultaneously, but you still rely on the State^ object to access the application variables that are represented in your user interfaces). When visual elements use application variables (see the Binding section), the State class is provided an accessor to these variables, both for reading and writing. Variable value change \u00b6 Some controls (such as input or slider ) let the user modify the value they hold. In order to control what that new value is and decide whether to use it as such, a callback function is called in the application when the user activates the control in order to change its value. Example from taipy.gui import Gui md = \"\"\" # Hello Taipy The variable `x` is here: <| {x} |slider|>. \"\"\" x = 50 def on_change ( state , var , val ): if var == \"x\" : print ( f \"'x' was changed to: { val } \" ) Gui ( page = md ) . run () In the function body, you can check the new value of the variable and decide what to do with it: potentially triggering some other code to propagate the side effects of the new variable value. In order to reset the value displayed at this point, one can simply change the variable value, using the state variable (or any other variable name that the State instance has been set to) prefix when referring to that variable. In our example, that would be state.x . Control-specific on_change callback All the controls that allow users to impact the variables they rely on let you specify a specific on_change callback. This is done using the on_change property of each control. That makes it easier to organize your application code in situations where there are many controls to handle, where a single on_change function would become very large. In the code above, you could isolate the on_change function for the slider control using its on_change property: ... md = \"\"\" # Hello Taipy The variable `x` is here: <| {x} |slider|on_change=on_slider_change|>. \"\"\" ... def on_slider_change ( state ): print ( f \"'x' was changed to: { state . x } \" ) ... You would not have to check the variable name anymore (although the callback function still receives it) since you know that on_slider_change , in this case, will be invoked only when the user interacts with the slider. Actions \u00b6 Controls like buttons don't notify of any value change. Instead, they use callbacks to notify the application that the user has activated those controls somehow. Example from taipy import Gui md = \"\"\" # Hello Taipy Press <|THIS|button|> button. \"\"\" def on_action ( state , id , action ): print ( \"The button was pressed!\" ) Gui ( page = md ) . run () The default behavior for these controls is to call the on_action function within your code, if there is one.","title":"Callbacks"},{"location":"manuals/gui/callbacks/#callbacks","text":"Callbacks are functions that are created in the application that are invoked in response to user actions in generated pages or other events that the Web browser requires that the application handles. Every callback function receives a State^ object as its first parameter. This object reflects the state of the application variables, for a given end-user: your application may be used simultaneously by different users connected to the same Web server (note that setting the single_client configuration parameter to False - as explained in the Configuration section - prevents multiple users from connecting to your application simultaneously, but you still rely on the State^ object to access the application variables that are represented in your user interfaces). When visual elements use application variables (see the Binding section), the State class is provided an accessor to these variables, both for reading and writing.","title":"Callbacks"},{"location":"manuals/gui/callbacks/#variable-value-change","text":"Some controls (such as input or slider ) let the user modify the value they hold. In order to control what that new value is and decide whether to use it as such, a callback function is called in the application when the user activates the control in order to change its value. Example from taipy.gui import Gui md = \"\"\" # Hello Taipy The variable `x` is here: <| {x} |slider|>. \"\"\" x = 50 def on_change ( state , var , val ): if var == \"x\" : print ( f \"'x' was changed to: { val } \" ) Gui ( page = md ) . run () In the function body, you can check the new value of the variable and decide what to do with it: potentially triggering some other code to propagate the side effects of the new variable value. In order to reset the value displayed at this point, one can simply change the variable value, using the state variable (or any other variable name that the State instance has been set to) prefix when referring to that variable. In our example, that would be state.x . Control-specific on_change callback All the controls that allow users to impact the variables they rely on let you specify a specific on_change callback. This is done using the on_change property of each control. That makes it easier to organize your application code in situations where there are many controls to handle, where a single on_change function would become very large. In the code above, you could isolate the on_change function for the slider control using its on_change property: ... md = \"\"\" # Hello Taipy The variable `x` is here: <| {x} |slider|on_change=on_slider_change|>. \"\"\" ... def on_slider_change ( state ): print ( f \"'x' was changed to: { state . x } \" ) ... You would not have to check the variable name anymore (although the callback function still receives it) since you know that on_slider_change , in this case, will be invoked only when the user interacts with the slider.","title":"Variable value change"},{"location":"manuals/gui/callbacks/#actions","text":"Controls like buttons don't notify of any value change. Instead, they use callbacks to notify the application that the user has activated those controls somehow. Example from taipy import Gui md = \"\"\" # Hello Taipy Press <|THIS|button|> button. \"\"\" def on_action ( state , id , action ): print ( \"The button was pressed!\" ) Gui ( page = md ) . run () The default behavior for these controls is to call the on_action function within your code, if there is one.","title":"Actions"},{"location":"manuals/gui/configuration/","text":"User Interface Configuration \u00b6 Applications created using the taipy.gui package can be configured for different use cases or environments. This section describes how to configure an application and explains different deployment scenarios. Configuring the Gui instance \u00b6 The Gui^ instance of your application has many parameters that you can modify to accommodate your environment (such as development or deployment context) or tune the user experience. Configuration parameters can be specified in the call to the (Gui.)run()^ method of your Gui instance using the kwargs parameter. Configuring with an .env file All parameters can also be set to any values and stored as a list of key-value pairs in a text file for your Gui instance to consume. The name of this file is the one provided as the env_filename parameter to the Gui constructor . If you have such a configuration file, then the value associated with a configuration parameter will override the one provided in the (Gui.)run()^ method of your Gui instance. Script options The Python script that you launch to run your application can be provided with command-line options that Taipy can use to ultimately override configuration settings. Not all configuration parameters can be overridden with option but when they can, the option is describe in the specific configuration parameter entry below. To see a list of all predefined Taipy options, you can run any Taipy script that runs a Gui instance with the -h option. Here is the list of the configuration parameters you can use in Gui.run()^ or as an environment setting: host (str, default: 127.0.0.1): the hostname of the server. This parameter can be overridden using the -H or --host option when launching your application: -H,--host <hostname> port (int, default: 5000): the port that the server uses. This parameter can be overridden using the -P or --port option when launching your application: -P,--port <port> title (str or None, default: \"Taipy App\"): the string displayed in the browser page title bar when navigating your Taipy application. favicon (str or None, default is the Avaiga logo): the path to an image file used as the page's icon when navigating your Taipy application. dark_mode (bool, default: True): whether the application shows in Dark mode (True) or Light mode (False). margin (str or None, default: \"1em\"): a CSS dimension value that indicates how far from the border of the windows should your interface be. The default value avoids elements getting glued to the window borders, improving appearance. system_notification (bool, default: True): if True, notifications will be sent by the system as well as the browser, should the system_notification parameter in the call to (notify()^) be set to None. If False, the default behavior is to not use system notifications. See the section on Notifications for details. notification_duration (int, default: 3000): the time, in milliseconds, that notifications should remain visible (see Notifications for details). debug (bool, default: True): set to True if you want to be provided with detailed debugging information messages from the server. You can force the debug mode using the --debug option when launching your application. Or you can force not to use the debug mode using the --no_debug option when launching your application. flask_log (bool, default: False): if set to True, you can get a full, real-time log from the Flask server. This may be useful when trying the find the reason why a request does not behave as expected. use_reloader (bool, default: True): If True, the application watches its Python source file while running, and reloads the entire script should the file be modified. If False, there is no such watch in place. You can force the use_reloader mode using the --use-reloader option when launching your application. Or you can force not to use the use_reloader mode using the --no-reloader option when launching your application. single_client (bool, default: False): set to True if only a single client can connect. False indicates that multiple clients can connect to the server. propagate (bool, default: True): the default value that will be used for every propagate property value, for all controls. Please look at the section on the propagate property for details). time_zone (str, default: \"client\"): indicates how date and time values should be interpreted. You can use a TZ database name (as listed in Time zones list on Wikipedia ) or one of the following values: \"client\" indicates that the time zone to be used is the Web client's. \"server\" indicates that the time zone to be used is the Web server's. theme (t.Union[t.Dict[str, t.Any], None]): A dictionary that lets you customize the theme of your application. See the Themes section for details. light_theme (t.Union[t.Dict[str, t.Any], None]): Similar to the theme setting, but applies to the light theme only. theme[dark] (t.Union[t.Dict[str, t.Any], None]): Similar to the theme setting, but applies to the dark theme only. use_arrow (bool, default: False): indicates whether or not to use the Apache Arrow technology to serialize data to Taipy clients. This allows for better performance in some situations. upload_folder (str or None, default: None): the local path where files are uploaded, when using the file_selector control. The default value is the temp directory on the system where the application runs. data_url_max_size (int or None): the size below which the upload of file content is performed as inline data. If a file content exceeds that size, it will actually create a physical file on the server for your application to use. This upload mechanism is used by the file_selector control. The default is 50 kB. ngrok_token (str, default: \"\"): an authtoken, if you need to use Ngrok to expose your application to the Internet. See the section on Accessing your app from the Web for details. Using an external Web server \u00b6 Taipy user interfaces can be served by external servers. This happens in situations where you already have a Web app running, and you want to add the GUI capabilities of Taipy to it. What you need to do in this case is use the flask parameter of the Gui^ constructor, setting it to the instance of the Flask server you are using. Here is a short code sample that should make this straightforward: 1 2 3 4 5 6 7 8 9 10 11 from flask import Flask from taipy import Gui flask_app = Flask ( __name__ ) @flask_app . route ( \"/home\" ) def home_page (): return \"The home page.\" gui = Gui ( page = \"# Taipy application\" , flask = flask_app ) gui . run () The Flask server is created in line 4. Routes and such would be declared as usual (like in lines 6 to 8). Note how we use the Flask instance to use it in the Gui^ constructor in line 10. When gui is run (in line 11), Taipy will not create a server of its own. Instead, it will serve your GUI pages using the flask_app server created in line 4. Accessing your app from the Web \u00b6 Ngrok provides a way to expose your local application to the public Internet. That allows anyone to access your application before deploying it in your production environment. If you want to expose your application using Ngrok, you can follow these steps: Install the pyngrok package in your Python environment: pip install pyngrok Create an account on the Ngrok Web site . That will drive you to a page where you can install the ngrok executable on your machine. Behind the scene, Ngrok will also send you a confirmation email providing a link that you must click to validate your registration and connect to your new account. Connecting to your account will provide you the Ngrok authtoken . Add the NGrok authtoken to the call to (Gui.)run()^ : ... gui=Gui(...) ... gui.run(ngrok_token=\"<ngrok_authtoken>\") ... When you run your Taipy script, the console will print out the public URL that allows users to connect to it. This has the form http://<id>.ngrok.io . Your Flask server, running locally will accept and serve connections from all around the world.","title":"Configuration"},{"location":"manuals/gui/configuration/#user-interface-configuration","text":"Applications created using the taipy.gui package can be configured for different use cases or environments. This section describes how to configure an application and explains different deployment scenarios.","title":"User Interface Configuration"},{"location":"manuals/gui/configuration/#configuring-the-gui-instance","text":"The Gui^ instance of your application has many parameters that you can modify to accommodate your environment (such as development or deployment context) or tune the user experience. Configuration parameters can be specified in the call to the (Gui.)run()^ method of your Gui instance using the kwargs parameter. Configuring with an .env file All parameters can also be set to any values and stored as a list of key-value pairs in a text file for your Gui instance to consume. The name of this file is the one provided as the env_filename parameter to the Gui constructor . If you have such a configuration file, then the value associated with a configuration parameter will override the one provided in the (Gui.)run()^ method of your Gui instance. Script options The Python script that you launch to run your application can be provided with command-line options that Taipy can use to ultimately override configuration settings. Not all configuration parameters can be overridden with option but when they can, the option is describe in the specific configuration parameter entry below. To see a list of all predefined Taipy options, you can run any Taipy script that runs a Gui instance with the -h option. Here is the list of the configuration parameters you can use in Gui.run()^ or as an environment setting: host (str, default: 127.0.0.1): the hostname of the server. This parameter can be overridden using the -H or --host option when launching your application: -H,--host <hostname> port (int, default: 5000): the port that the server uses. This parameter can be overridden using the -P or --port option when launching your application: -P,--port <port> title (str or None, default: \"Taipy App\"): the string displayed in the browser page title bar when navigating your Taipy application. favicon (str or None, default is the Avaiga logo): the path to an image file used as the page's icon when navigating your Taipy application. dark_mode (bool, default: True): whether the application shows in Dark mode (True) or Light mode (False). margin (str or None, default: \"1em\"): a CSS dimension value that indicates how far from the border of the windows should your interface be. The default value avoids elements getting glued to the window borders, improving appearance. system_notification (bool, default: True): if True, notifications will be sent by the system as well as the browser, should the system_notification parameter in the call to (notify()^) be set to None. If False, the default behavior is to not use system notifications. See the section on Notifications for details. notification_duration (int, default: 3000): the time, in milliseconds, that notifications should remain visible (see Notifications for details). debug (bool, default: True): set to True if you want to be provided with detailed debugging information messages from the server. You can force the debug mode using the --debug option when launching your application. Or you can force not to use the debug mode using the --no_debug option when launching your application. flask_log (bool, default: False): if set to True, you can get a full, real-time log from the Flask server. This may be useful when trying the find the reason why a request does not behave as expected. use_reloader (bool, default: True): If True, the application watches its Python source file while running, and reloads the entire script should the file be modified. If False, there is no such watch in place. You can force the use_reloader mode using the --use-reloader option when launching your application. Or you can force not to use the use_reloader mode using the --no-reloader option when launching your application. single_client (bool, default: False): set to True if only a single client can connect. False indicates that multiple clients can connect to the server. propagate (bool, default: True): the default value that will be used for every propagate property value, for all controls. Please look at the section on the propagate property for details). time_zone (str, default: \"client\"): indicates how date and time values should be interpreted. You can use a TZ database name (as listed in Time zones list on Wikipedia ) or one of the following values: \"client\" indicates that the time zone to be used is the Web client's. \"server\" indicates that the time zone to be used is the Web server's. theme (t.Union[t.Dict[str, t.Any], None]): A dictionary that lets you customize the theme of your application. See the Themes section for details. light_theme (t.Union[t.Dict[str, t.Any], None]): Similar to the theme setting, but applies to the light theme only. theme[dark] (t.Union[t.Dict[str, t.Any], None]): Similar to the theme setting, but applies to the dark theme only. use_arrow (bool, default: False): indicates whether or not to use the Apache Arrow technology to serialize data to Taipy clients. This allows for better performance in some situations. upload_folder (str or None, default: None): the local path where files are uploaded, when using the file_selector control. The default value is the temp directory on the system where the application runs. data_url_max_size (int or None): the size below which the upload of file content is performed as inline data. If a file content exceeds that size, it will actually create a physical file on the server for your application to use. This upload mechanism is used by the file_selector control. The default is 50 kB. ngrok_token (str, default: \"\"): an authtoken, if you need to use Ngrok to expose your application to the Internet. See the section on Accessing your app from the Web for details.","title":"Configuring the Gui instance"},{"location":"manuals/gui/configuration/#using-an-external-web-server","text":"Taipy user interfaces can be served by external servers. This happens in situations where you already have a Web app running, and you want to add the GUI capabilities of Taipy to it. What you need to do in this case is use the flask parameter of the Gui^ constructor, setting it to the instance of the Flask server you are using. Here is a short code sample that should make this straightforward: 1 2 3 4 5 6 7 8 9 10 11 from flask import Flask from taipy import Gui flask_app = Flask ( __name__ ) @flask_app . route ( \"/home\" ) def home_page (): return \"The home page.\" gui = Gui ( page = \"# Taipy application\" , flask = flask_app ) gui . run () The Flask server is created in line 4. Routes and such would be declared as usual (like in lines 6 to 8). Note how we use the Flask instance to use it in the Gui^ constructor in line 10. When gui is run (in line 11), Taipy will not create a server of its own. Instead, it will serve your GUI pages using the flask_app server created in line 4.","title":"Using an external Web server"},{"location":"manuals/gui/configuration/#accessing-your-app-from-the-web","text":"Ngrok provides a way to expose your local application to the public Internet. That allows anyone to access your application before deploying it in your production environment. If you want to expose your application using Ngrok, you can follow these steps: Install the pyngrok package in your Python environment: pip install pyngrok Create an account on the Ngrok Web site . That will drive you to a page where you can install the ngrok executable on your machine. Behind the scene, Ngrok will also send you a confirmation email providing a link that you must click to validate your registration and connect to your new account. Connecting to your account will provide you the Ngrok authtoken . Add the NGrok authtoken to the call to (Gui.)run()^ : ... gui=Gui(...) ... gui.run(ngrok_token=\"<ngrok_authtoken>\") ... When you run your Taipy script, the console will print out the public URL that allows users to connect to it. This has the form http://<id>.ngrok.io . Your Flask server, running locally will accept and serve connections from all around the world.","title":"Accessing your app from the Web"},{"location":"manuals/gui/controls/","text":"Controls \u00b6 Controls are user interface objects that represent data. Controls list \u00b6 Here is the list of all available controls in Taipy: text Displays a value as a static text. button A control that can trigger a function when pressed. input A control that displays some text that can potentially be edited. number A kind of [`input`](input.md) that handles numbers. slider Displays and allows the user to set a value within a range. toggle A series of toggle buttons that the user can select. date A control that can display and specified a formatted date, with or without time. chart Displays data sets in a chart or a group of charts. file_download Allows downloading of a file content. file_selector Allows uploading a file content. image A control that can display an image. indicator Displays a label on a red to green scale at a specific position. menu Shows a left-side menu. navbar A navigation bar control. selector A control that allows for selecting items from a list of choices. status Displays a status or a list of statuses. table Displays a data set as tabular data. dialog A modal dialog. tree A control that allows for selecting items from a hierarchical view of items.","title":"Controls"},{"location":"manuals/gui/controls/#controls","text":"Controls are user interface objects that represent data.","title":"Controls"},{"location":"manuals/gui/controls/#controls-list","text":"Here is the list of all available controls in Taipy: text Displays a value as a static text. button A control that can trigger a function when pressed. input A control that displays some text that can potentially be edited. number A kind of [`input`](input.md) that handles numbers. slider Displays and allows the user to set a value within a range. toggle A series of toggle buttons that the user can select. date A control that can display and specified a formatted date, with or without time. chart Displays data sets in a chart or a group of charts. file_download Allows downloading of a file content. file_selector Allows uploading a file content. image A control that can display an image. indicator Displays a label on a red to green scale at a specific position. menu Shows a left-side menu. navbar A navigation bar control. selector A control that allows for selecting items from a list of choices. status Displays a status or a list of statuses. table Displays a data set as tabular data. dialog A modal dialog. tree A control that allows for selecting items from a hierarchical view of items.","title":"Controls list"},{"location":"manuals/gui/notebooks/","text":"Running in Notebooks \u00b6 You can create and run a Taipy Graphical User Interface from a Jupyter Notebook. In this situation, the Web server that Taipy relies on will run on a separate thread, so the Notebook works as expected. Creating a Taipy GUI application in a new Notebook \u00b6 Here is a step-by-step approach on hosting a Taipy GUI within your Notebook and interacting with it. You will start your Jupyter server the usual way: jupyter notebook Your browser should open a new window, connected to the Jupyter server, where you can create and manipulate Notebooks. Example code You may want to load the Notebook source file directly within Jupyter and move from cell to cell instead of entering the code in the following steps. Create a new Notebook by selecting the New > Python 3 (ipykernel) option located in the upper right corner of the Jupyter interface. Then start creating the Notebook content. Enter the following code into the first Notebook cell: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from taipy.gui import Gui , Markdown page = Markdown ( \"\"\" # Taipy in a Notebook Value: <| {value} |> Set: <| {value} |slider|> \"\"\" ) value = 10 gui = Gui ( page ) gui . run () As you can see, we create and run our Gui^ instance in lines 13 and 14. Note that we use the Markdown^ class explicitly (in line 3). That is because later in our code, we will want to modify the content of the page. Run the cell. The output shows that a server was started (usually on http://127.0.0.1:5000 ), hosting the 'Taipy' Flask app. A new window is created in your browser, displaying the small interface we have just created. Note that the text control automatically displays value when you move the slider thumb. That shows that Taipy has successfully bound the variable value to both the text and the slider controls. You can witness the user interface update when you change a variable on the fly. In the context of Notebooks, you can directly access the variables that are bound to the user interface: Updating variables \u00b6 The point of using Notebooks (besides making it possible to provide explanatory text along with the code in a single document) is to allow for changing variables on the fly and see the impact of these changes immediately. Let's see how we can use that feature with Taipy. Enter the following line into a new cell: gui . state . value = 50 When you run this cell, the new value is reflected both in the text and the slider. The gui.state property This property is provided only in the context of Notebooks, where there is a single connection to the server, allowing to access a single ' state '. Updating pages \u00b6 Pages can also be updated on-the-fly. In another cell, enter the following text: import math xrange = range ( 0 , 720 ) def compute_data ( a ): return [ a * math . cos ( 2 * math . pi * x / 100 ) + ( 100 - a ) * math . sin ( 2 * math . pi * x / 50 ) for x in xrange ] data = compute_data ( value ) After running this cell, the variable data holds an array of floating-point values representing some fancy trigonometric function (computed in compute_data() ) based on some parameter. If we want to display these values in a chart, we need to change our page to add a chart control to it. You can update the page content on the fly by creating a new cell with the following content: page . set_content ( \"\"\" # Taipy in a Notebook Value: <| {value} |> Set: <| {value} |slider|> <| {data} |chart|> \"\"\" ) If you refresh the page where the interface is displayed, you will see that the chart control appears just like you expected. A final step we can take is to add some interaction to this application. We want the data recomputed when the sider value is modified and witness the chart reflect that change. Create a final cell and enter the following: def on_change ( state , var_name , var_value ): if var_name == \"value\" : state . data = compute_data ( state . value ) The code in this cell updates the data displayed in the user interface when the variable value changes (that is, when the user moves the slider thumb). However, the Gui object was initially created without knowing this function that it must bind controls to. To reset the Taipy server and connect to on_change() , you must run the final cell: gui . stop () gui . run () Go to the Taipy interface page and refresh. The slider now controls the chart that is automatically updated when a new value is set.","title":"Using Notebooks"},{"location":"manuals/gui/notebooks/#running-in-notebooks","text":"You can create and run a Taipy Graphical User Interface from a Jupyter Notebook. In this situation, the Web server that Taipy relies on will run on a separate thread, so the Notebook works as expected.","title":"Running in Notebooks"},{"location":"manuals/gui/notebooks/#creating-a-taipy-gui-application-in-a-new-notebook","text":"Here is a step-by-step approach on hosting a Taipy GUI within your Notebook and interacting with it. You will start your Jupyter server the usual way: jupyter notebook Your browser should open a new window, connected to the Jupyter server, where you can create and manipulate Notebooks. Example code You may want to load the Notebook source file directly within Jupyter and move from cell to cell instead of entering the code in the following steps. Create a new Notebook by selecting the New > Python 3 (ipykernel) option located in the upper right corner of the Jupyter interface. Then start creating the Notebook content. Enter the following code into the first Notebook cell: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from taipy.gui import Gui , Markdown page = Markdown ( \"\"\" # Taipy in a Notebook Value: <| {value} |> Set: <| {value} |slider|> \"\"\" ) value = 10 gui = Gui ( page ) gui . run () As you can see, we create and run our Gui^ instance in lines 13 and 14. Note that we use the Markdown^ class explicitly (in line 3). That is because later in our code, we will want to modify the content of the page. Run the cell. The output shows that a server was started (usually on http://127.0.0.1:5000 ), hosting the 'Taipy' Flask app. A new window is created in your browser, displaying the small interface we have just created. Note that the text control automatically displays value when you move the slider thumb. That shows that Taipy has successfully bound the variable value to both the text and the slider controls. You can witness the user interface update when you change a variable on the fly. In the context of Notebooks, you can directly access the variables that are bound to the user interface:","title":"Creating a Taipy GUI application in a new Notebook"},{"location":"manuals/gui/notebooks/#updating-variables","text":"The point of using Notebooks (besides making it possible to provide explanatory text along with the code in a single document) is to allow for changing variables on the fly and see the impact of these changes immediately. Let's see how we can use that feature with Taipy. Enter the following line into a new cell: gui . state . value = 50 When you run this cell, the new value is reflected both in the text and the slider. The gui.state property This property is provided only in the context of Notebooks, where there is a single connection to the server, allowing to access a single ' state '.","title":"Updating variables"},{"location":"manuals/gui/notebooks/#updating-pages","text":"Pages can also be updated on-the-fly. In another cell, enter the following text: import math xrange = range ( 0 , 720 ) def compute_data ( a ): return [ a * math . cos ( 2 * math . pi * x / 100 ) + ( 100 - a ) * math . sin ( 2 * math . pi * x / 50 ) for x in xrange ] data = compute_data ( value ) After running this cell, the variable data holds an array of floating-point values representing some fancy trigonometric function (computed in compute_data() ) based on some parameter. If we want to display these values in a chart, we need to change our page to add a chart control to it. You can update the page content on the fly by creating a new cell with the following content: page . set_content ( \"\"\" # Taipy in a Notebook Value: <| {value} |> Set: <| {value} |slider|> <| {data} |chart|> \"\"\" ) If you refresh the page where the interface is displayed, you will see that the chart control appears just like you expected. A final step we can take is to add some interaction to this application. We want the data recomputed when the sider value is modified and witness the chart reflect that change. Create a final cell and enter the following: def on_change ( state , var_name , var_value ): if var_name == \"value\" : state . data = compute_data ( state . value ) The code in this cell updates the data displayed in the user interface when the variable value changes (that is, when the user moves the slider thumb). However, the Gui object was initially created without knowing this function that it must bind controls to. To reset the Taipy server and connect to on_change() , you must run the final cell: gui . stop () gui . run () Go to the Taipy interface page and refresh. The slider now controls the chart that is automatically updated when a new value is set.","title":"Updating pages"},{"location":"manuals/gui/notifications/","text":"Notifications \u00b6 Taipy provides a way to inform users that some action is taking place as an informative message that does not impact the user interaction. Notifications can be triggered at any time to send a temporary message to the user, using the notify()^ function. One can specify how long the message remains visible on the screen. A notification is a short message that appears in a small popup window. The level of urgency of the message is reflected in the color of that window. If permission is given to the browser, notifications can also appear directly on the desktop of the user's machine.","title":"Notifications"},{"location":"manuals/gui/notifications/#notifications","text":"Taipy provides a way to inform users that some action is taking place as an informative message that does not impact the user interaction. Notifications can be triggered at any time to send a temporary message to the user, using the notify()^ function. One can specify how long the message remains visible on the screen. A notification is a short message that appears in a small popup window. The level of urgency of the message is reflected in the color of that window. If permission is given to the browser, notifications can also appear directly on the desktop of the user's machine.","title":"Notifications"},{"location":"manuals/gui/pages/","text":"Pages \u00b6 Pages are the basis for the user interface. Pages hold text, images, or controls that display information that the application needs to publish and interact with the application data through visual elements. Defining pages \u00b6 Taipy lets you create as many pages as you want, with whatever content you need. Pages are created using sub-classes of the (Page^) class which convert some text (inside the application code or from an external file) into HTML content sent and rendered on the client device. Converting text into page content is done according to these steps: The text is parsed to locate the Taipy-specific constructs. These constructs let you insert visual elements that can be controls or blocks . Visual Elements result in the creation of potentially complex HTML components; Visual element properties are read, and Taipy binds the application variables that are used, if any; Potentially, callbacks are located and connected from the rendered page back to the Python code in order to watch user events (the notion of callbacks is detailed in the section Callbacks ). Defining the page content \u00b6 Page content is defined by a regular string, containing text in one of two syntaxes: Markdown: a lightweight markup language widely used for creating documentation pages. This would be the ideal format if you are not familiar with Web page definition, and would like to create a good visual rendering quickly. Taipy has an augmented version of Markdown that makes it simple to organize the page content in sections or grids. HTML: if you are more experienced in developing Web user interfaces, you may prefer to use raw HTML content, so you have all the power of the HTML grammar to organize your page content. Using Markdown \u00b6 One of the page description formats is the Markdown markup language. Taipy uses Python Markdown to translate Markdown text to Web pages. Many language extensions are used to make it easier to create nice looking pages that users can enjoy. Specifically, Taipy uses the following Markdown extensions : Admonition , Attribute Lists , Fenced Code Blocks , Meta-Data , Markdown in HTML , Sane Lists and Tables . Please refer to the Python Markdown package documentation to get information on how to use these. Creating a page that display HTML content is straightforward: from taipy.gui import Markdown md_page = Markdown ( \"\"\" # Page title Any [_Markdown_](https://en.wikipedia.org/wiki/Markdown) content can be used here. \"\"\" ) You then have, in the md_page variable, the definition of a page whose content is defined by Markdown text. Markdown link syntax You can use Markdown's native link syntax to easily create links from one page to another. If, for example, your application has two pages (see below how to create such an application, where pages would be called \"page1\" and \"page2\"), you can create a link to \"page2\" from \"page1\" by adding the following Markdown fragment in the definition of \"page1\": ... Go to [Second Page](/page2) for more information. ... Besides the extensions listed above, Taipy adds its own extension that can parse Taipy-specific constructs that allow for defining visual elements (and all the properties they need). The details on how visual elements are located and interpreted with Markdown content can be found in the Markdown Syntax section about Visual Elements definition. Using HTML \u00b6 HTML can also be used as the text grammar for creating pages. You don't need to create the header and body part: Taipy takes care of this for you. Creating a page that displays HTML content is straightforward: from taipy.gui import Html html_page = Html ( \"\"\" <h1>Page title</h1> Any <a href=\"https://en.wikipedia.org/wiki/HTML\"><i>HTML</i></a> content can be used here. \"\"\" ) You then have, in the html_page variable, the definition of a page whose content is defined from HTML text. Taipy identifies visual element definitions by finding tags that belong to the taipy namespace. You can find details on how to create visual elements using HTML in the HTML Syntax section about Visual Elements definition. Registering the page \u00b6 Once you have created an instance of a page renderer for a specific piece of text, you can register that page to the Gui^ instance used by your application. The Gui^ constructor can accept the raw content of a page as Markdown text and creates a new page for you. That would be the easier way to create applications that have a single page. Here is how you can create and register a page in a Taipy application: from taipy import Gui Gui ( \"# This is my page title\" ) If you run this Python script and connect a browser to the Web server address (usually localhost:5000 ), you can see your title displayed in a blank page. Of course, the text can be stored in a Python variable and used in the Gui^ constructor: ... md = \"# This is my page title\" Gui ( md ) If your application has several pages, you add your pages one by one using Gui.add_page()^ . To add multiple pages in a single call, you will use Gui.add_pages()^ or create the Gui^ instance using the pages argument. In those situations, you have to create a Python dictionary that associates a page with its name: ... pages = { 'page1': Markdown(\"# My first page\"), 'page2': Markdown(\"# My second page\") } Gui(pages=pages) In this situation, to see the pages in your browser, the address you will use will be localhost:5000/page1 or localhost:5000/page2 . Viewing the page \u00b6 When the user browser connects to the Web server, requesting the indicated page, the rendering takes place (involving the retrieval of the application variable values), so you can see your application's state and interact with it. Root page \u00b6 The Root page is the page located at the top of the Web application. The name of this page is \"/\" . If your application uses only one page, this is typically where it would be created: Gui ( page = \"# Page Content\" ) creates a page from the Markdown content that you provide and adds this page to the new Gui instance with the name \"/\" . This makes it straightforward to watch your application run by pointing a Web browser to the root of the Web server address (by default, that would be http://127.0.0.1:5000/ ). Single-page applications \u00b6 If your application has several pages, you would usually create them with different names, so the user can navigate from page to page (using the navigate()^ function or the navbar control). However, you can still have a root page for your application (with the name: \"/\" ). In this situation, Taipy creates a single-page application (SPA) for you. Modern Web applications use this SPA technique: instead of reloading the entire page, some processing is performed behind the scene to generate the page that should be displayed, transforming the currently shown page. This allows for smoother transitions from page to page and feels like the application was natively developed for your runtime environment. Although technically, every Taipy Web application is a SPA, this notion makes sense only when using several pages. If your Taipy application has defined a root page, then the content of this page is generated before the content of the page you need to display. This makes it very easy to design an application with the same header (such as a banner and a navigation bar) for all its pages. Example Here is an example of a Taipy application that holds several pages: from taipy import Gui root_md = \"# Multi-page application\" page1_md = \"## This is page 1\" page2_md = \"## This is page 2\" pages = { \"/\" : root_md , \"page1\" : page1_md , \"page2\" : page2_md } Gui ( pages = pages ) . run () When you run this application and display the page at http://127.0.0.1:5000/ , you will notice that the browser navigates to the page /page1 , and that the final result is a page that contains the content of the root page, followed by what is defined in the page \"page1\" . In this example, you will see both the main title ('Multi-page application') and the sub-title ('This is page 1'). If you navigate to '/page2', the main title remains on the page, and the sub-title is replaced by the text 'This is page 2' The <|content|> pseudo-control \u00b6 Your application may also need to hold a footer on all the pages it uses. You can use the pseudo-control <|content|> to achieve the expected result: this visual element is not really a control: It is a placeholder for page content, used in the root page of your application, and is replaced by the target page content when the application runs. Example from taipy import Gui root_md = \"\"\" # Multi-page application <|content|> This application was created with [Taipy](http://taipy.avaiga.com). \"\"\" page1_md = \"## This is page 1\" page2_md = \"## This is page 2\" pages = { \"/\" : root_md , \"page1\" : page1_md , \"page2\" : page2_md } Gui ( pages = pages ) . run () This application does the same as in the previous example, except that you now have the footer line ( 'This application was created...' ) in all the pages of your application. Dialogs \u00b6 Applications sometimes need to prompt the user to indicate a situation or request input of some sort. Dialogs are forms that can be displayed on top of the page the user is looking at, prompting for some input. To create a dialog, you will use a dialog control in your page. The dialog holds a page content or a Partial (see Partials ). You can control whether the dialog is visible or not, and what to do when the end-user presses the Validate or Cancel button, so your application can deal with the user's response. Example Here is an example of how you would create a dialog, directly in your Markdown content: ... page = \"\"\" ... <| {dialog_is_visible} |dialog| Enter a name: <| {name} |input|> |> ... \"\"\" Gui ( page ) . run () Please refer to the documentation page on the dialog control for more details and examples. Partials \u00b6 There are page fragments that you may want to repeat on different pages. In that situation, you will want to use the Partial concept: a Partial is similar to a page (and built in a very similar way) that can be used multiple times in different visual elements. This prevents you from having to repeat yourself when creating your user interfaces. To create a Partial , you must call the method (Gui.)add_partial()^ on the Gui instance of your application. You must give this function a page definition (a string or an instance of Markdown^ or Html^ ), and it returns an instance of Partial^ that can be used in visual elements that use them. Example Here is an example of how you would create a Partial^ , in the situation where the dialog created in the example above would be needed in different pages: ... gui = Gui () prompt_user = gui . add_partial ( \"\"\" Enter a name: <|{name}|input|> \"\"\" ) gui . run () You can take a look at the documentation of the dialog or pane to see how these Partials can be used in pages. Panes \u00b6 Modern user interfaces also provide small pages that pop out and be removed for temporary use, such as providing specific parameters for the application. Taipy lets you create such elements using the pane block. A pane can appear from any border of your page, next to or on top of the page, and disappears when the user clicks outside its area. A pane can be defined using the Partial^ class, or directly in the page definition. Local resources \u00b6 Pages sometimes need to access local resources from a page. That is the case for example if an image needs to be inserted: the path to the image must be provided. You can indicate, using the parameter path_mapping of the Gui constructor , where those resources are located on the file system.","title":"Pages"},{"location":"manuals/gui/pages/#pages","text":"Pages are the basis for the user interface. Pages hold text, images, or controls that display information that the application needs to publish and interact with the application data through visual elements.","title":"Pages"},{"location":"manuals/gui/pages/#defining-pages","text":"Taipy lets you create as many pages as you want, with whatever content you need. Pages are created using sub-classes of the (Page^) class which convert some text (inside the application code or from an external file) into HTML content sent and rendered on the client device. Converting text into page content is done according to these steps: The text is parsed to locate the Taipy-specific constructs. These constructs let you insert visual elements that can be controls or blocks . Visual Elements result in the creation of potentially complex HTML components; Visual element properties are read, and Taipy binds the application variables that are used, if any; Potentially, callbacks are located and connected from the rendered page back to the Python code in order to watch user events (the notion of callbacks is detailed in the section Callbacks ).","title":"Defining pages"},{"location":"manuals/gui/pages/#defining-the-page-content","text":"Page content is defined by a regular string, containing text in one of two syntaxes: Markdown: a lightweight markup language widely used for creating documentation pages. This would be the ideal format if you are not familiar with Web page definition, and would like to create a good visual rendering quickly. Taipy has an augmented version of Markdown that makes it simple to organize the page content in sections or grids. HTML: if you are more experienced in developing Web user interfaces, you may prefer to use raw HTML content, so you have all the power of the HTML grammar to organize your page content.","title":"Defining the page content"},{"location":"manuals/gui/pages/#using-markdown","text":"One of the page description formats is the Markdown markup language. Taipy uses Python Markdown to translate Markdown text to Web pages. Many language extensions are used to make it easier to create nice looking pages that users can enjoy. Specifically, Taipy uses the following Markdown extensions : Admonition , Attribute Lists , Fenced Code Blocks , Meta-Data , Markdown in HTML , Sane Lists and Tables . Please refer to the Python Markdown package documentation to get information on how to use these. Creating a page that display HTML content is straightforward: from taipy.gui import Markdown md_page = Markdown ( \"\"\" # Page title Any [_Markdown_](https://en.wikipedia.org/wiki/Markdown) content can be used here. \"\"\" ) You then have, in the md_page variable, the definition of a page whose content is defined by Markdown text. Markdown link syntax You can use Markdown's native link syntax to easily create links from one page to another. If, for example, your application has two pages (see below how to create such an application, where pages would be called \"page1\" and \"page2\"), you can create a link to \"page2\" from \"page1\" by adding the following Markdown fragment in the definition of \"page1\": ... Go to [Second Page](/page2) for more information. ... Besides the extensions listed above, Taipy adds its own extension that can parse Taipy-specific constructs that allow for defining visual elements (and all the properties they need). The details on how visual elements are located and interpreted with Markdown content can be found in the Markdown Syntax section about Visual Elements definition.","title":"Using Markdown"},{"location":"manuals/gui/pages/#using-html","text":"HTML can also be used as the text grammar for creating pages. You don't need to create the header and body part: Taipy takes care of this for you. Creating a page that displays HTML content is straightforward: from taipy.gui import Html html_page = Html ( \"\"\" <h1>Page title</h1> Any <a href=\"https://en.wikipedia.org/wiki/HTML\"><i>HTML</i></a> content can be used here. \"\"\" ) You then have, in the html_page variable, the definition of a page whose content is defined from HTML text. Taipy identifies visual element definitions by finding tags that belong to the taipy namespace. You can find details on how to create visual elements using HTML in the HTML Syntax section about Visual Elements definition.","title":"Using HTML"},{"location":"manuals/gui/pages/#registering-the-page","text":"Once you have created an instance of a page renderer for a specific piece of text, you can register that page to the Gui^ instance used by your application. The Gui^ constructor can accept the raw content of a page as Markdown text and creates a new page for you. That would be the easier way to create applications that have a single page. Here is how you can create and register a page in a Taipy application: from taipy import Gui Gui ( \"# This is my page title\" ) If you run this Python script and connect a browser to the Web server address (usually localhost:5000 ), you can see your title displayed in a blank page. Of course, the text can be stored in a Python variable and used in the Gui^ constructor: ... md = \"# This is my page title\" Gui ( md ) If your application has several pages, you add your pages one by one using Gui.add_page()^ . To add multiple pages in a single call, you will use Gui.add_pages()^ or create the Gui^ instance using the pages argument. In those situations, you have to create a Python dictionary that associates a page with its name: ... pages = { 'page1': Markdown(\"# My first page\"), 'page2': Markdown(\"# My second page\") } Gui(pages=pages) In this situation, to see the pages in your browser, the address you will use will be localhost:5000/page1 or localhost:5000/page2 .","title":"Registering the page"},{"location":"manuals/gui/pages/#viewing-the-page","text":"When the user browser connects to the Web server, requesting the indicated page, the rendering takes place (involving the retrieval of the application variable values), so you can see your application's state and interact with it.","title":"Viewing the page"},{"location":"manuals/gui/pages/#root-page","text":"The Root page is the page located at the top of the Web application. The name of this page is \"/\" . If your application uses only one page, this is typically where it would be created: Gui ( page = \"# Page Content\" ) creates a page from the Markdown content that you provide and adds this page to the new Gui instance with the name \"/\" . This makes it straightforward to watch your application run by pointing a Web browser to the root of the Web server address (by default, that would be http://127.0.0.1:5000/ ).","title":"Root page"},{"location":"manuals/gui/pages/#single-page-applications","text":"If your application has several pages, you would usually create them with different names, so the user can navigate from page to page (using the navigate()^ function or the navbar control). However, you can still have a root page for your application (with the name: \"/\" ). In this situation, Taipy creates a single-page application (SPA) for you. Modern Web applications use this SPA technique: instead of reloading the entire page, some processing is performed behind the scene to generate the page that should be displayed, transforming the currently shown page. This allows for smoother transitions from page to page and feels like the application was natively developed for your runtime environment. Although technically, every Taipy Web application is a SPA, this notion makes sense only when using several pages. If your Taipy application has defined a root page, then the content of this page is generated before the content of the page you need to display. This makes it very easy to design an application with the same header (such as a banner and a navigation bar) for all its pages. Example Here is an example of a Taipy application that holds several pages: from taipy import Gui root_md = \"# Multi-page application\" page1_md = \"## This is page 1\" page2_md = \"## This is page 2\" pages = { \"/\" : root_md , \"page1\" : page1_md , \"page2\" : page2_md } Gui ( pages = pages ) . run () When you run this application and display the page at http://127.0.0.1:5000/ , you will notice that the browser navigates to the page /page1 , and that the final result is a page that contains the content of the root page, followed by what is defined in the page \"page1\" . In this example, you will see both the main title ('Multi-page application') and the sub-title ('This is page 1'). If you navigate to '/page2', the main title remains on the page, and the sub-title is replaced by the text 'This is page 2'","title":"Single-page applications"},{"location":"manuals/gui/pages/#the--pseudo-control","text":"Your application may also need to hold a footer on all the pages it uses. You can use the pseudo-control <|content|> to achieve the expected result: this visual element is not really a control: It is a placeholder for page content, used in the root page of your application, and is replaced by the target page content when the application runs. Example from taipy import Gui root_md = \"\"\" # Multi-page application <|content|> This application was created with [Taipy](http://taipy.avaiga.com). \"\"\" page1_md = \"## This is page 1\" page2_md = \"## This is page 2\" pages = { \"/\" : root_md , \"page1\" : page1_md , \"page2\" : page2_md } Gui ( pages = pages ) . run () This application does the same as in the previous example, except that you now have the footer line ( 'This application was created...' ) in all the pages of your application.","title":"The &lt;|content|&gt; pseudo-control"},{"location":"manuals/gui/pages/#dialogs","text":"Applications sometimes need to prompt the user to indicate a situation or request input of some sort. Dialogs are forms that can be displayed on top of the page the user is looking at, prompting for some input. To create a dialog, you will use a dialog control in your page. The dialog holds a page content or a Partial (see Partials ). You can control whether the dialog is visible or not, and what to do when the end-user presses the Validate or Cancel button, so your application can deal with the user's response. Example Here is an example of how you would create a dialog, directly in your Markdown content: ... page = \"\"\" ... <| {dialog_is_visible} |dialog| Enter a name: <| {name} |input|> |> ... \"\"\" Gui ( page ) . run () Please refer to the documentation page on the dialog control for more details and examples.","title":"Dialogs"},{"location":"manuals/gui/pages/#partials","text":"There are page fragments that you may want to repeat on different pages. In that situation, you will want to use the Partial concept: a Partial is similar to a page (and built in a very similar way) that can be used multiple times in different visual elements. This prevents you from having to repeat yourself when creating your user interfaces. To create a Partial , you must call the method (Gui.)add_partial()^ on the Gui instance of your application. You must give this function a page definition (a string or an instance of Markdown^ or Html^ ), and it returns an instance of Partial^ that can be used in visual elements that use them. Example Here is an example of how you would create a Partial^ , in the situation where the dialog created in the example above would be needed in different pages: ... gui = Gui () prompt_user = gui . add_partial ( \"\"\" Enter a name: <|{name}|input|> \"\"\" ) gui . run () You can take a look at the documentation of the dialog or pane to see how these Partials can be used in pages.","title":"Partials"},{"location":"manuals/gui/pages/#panes","text":"Modern user interfaces also provide small pages that pop out and be removed for temporary use, such as providing specific parameters for the application. Taipy lets you create such elements using the pane block. A pane can appear from any border of your page, next to or on top of the page, and disappears when the user clicks outside its area. A pane can be defined using the Partial^ class, or directly in the page definition.","title":"Panes"},{"location":"manuals/gui/pages/#local-resources","text":"Pages sometimes need to access local resources from a page. That is the case for example if an image needs to be inserted: the path to the image must be provided. You can indicate, using the parameter path_mapping of the Gui constructor , where those resources are located on the file system.","title":"Local resources"},{"location":"manuals/gui/styling/","text":"Styling \u00b6 As mentioned several times, page content is parsed and converted to be sent to the user's browser. The final page content actually is pure HTML that one can apply some style to, providing the best user experience. Styling involves some knowledge of Cascading Style Sheets . This section describes what sort of styling you may want to apply, in different situations. Style sheets \u00b6 There are two ways you can apply a stylesheet to your application: Global style sheet. The css_file parameter of the Gui constructor lets you specify a CSS file that your application will use for every page. The default value for this parameter is a file located next to your main Python script, with the same name except for the extension that must be '.css'. Page-specific style. The method Gui.add_page()^ has a style parameter that can be set to CSS content. This additional style is applied to the page and only this page. Beside explicit style sheets, you can also modify the global theme, as described in the section on Themes . Applying style \u00b6 Once the style sheets are set for the application, you can start learning about how styles can be expressed to pages. Global styles \u00b6 As in any Web application, the root element ( :root ) is available for global style settings. For example, if you want to make your application bigger, enlarging the font size, you could write: : root { font-size : 2 rem ; } And all pages will appear twice as big. Markdown styles \u00b6 Thanks to the Attribute Lists extension, the Markdown text can hold attributes used for styling. If, for example, your Markdown content is the following: ... This line should be displayed in blue. { .blue-line } ... and a style sheet used by the application indicates: . blue-line { color : blue ; } then the text line is displayed in blue. Please check the documentation for the Attribute Lists extension to find more information. div vs. p Instead of generating <p> HTML tags for lines of text, Taipy uses <div> tags. This allows more complex structures in pages, such as elements within elements. Main page style \u00b6 The top-most element of the generated page is a <div> element with the 'id' attribute set to \"root\". If you need to reference the top-most element of your page, you can select it in your CSS stylesheets using the selector: div#root . Visual elements-specific styles \u00b6 You can apply some style to any visual element you have added to your pages. Using CSS classes \u00b6 Every visual element is assigned a CSS class that depends on the type of the element. The default associated class name is made of the string \"taipy-\" followed by the type of element: all Taipy buttons, for example, have the CSS class name: \"taipy-button\" . You can therefore create a weird-looking button displayed in an oval by setting a style sheet that contains: . taipy-button { border-radius : 50 % ; } Now all the buttons of your application will look the same, with an oval shape instead of a rectangle with rounded corners. If your Markdown page contains the following control: <|Click me|button|> The CSS rule above will impact your display this way: Regular button Rounded button You can also add CSS class names of your choice using the classname property of all visual elements. If you need to assign more than one class to an element, you can separate each individual class name with a space character: <|Click me|button|classname=\"option testing\"|> This Markdown fragment gets converted into an HTML element with three CSS classes assigned: taipy-button , option , and testing . Using the HTML 'id' attribute \u00b6 You can use the id property of all visual elements to generate an HTML id that can be used by CSS styling. For example, if your Markdown page contains the following control: <|Click me|button|id=\"my_button\"|> You can change the style of that button using a CSS selector that relies on the id of the button: # my_button { text-transform : none ; } Now the button shows the text 'Click me' instead of 'CLICK ME': the default in Material UI (which is the components library Taipy GUI relies on) is to capitalize the text of buttons. Regular button Uncapitalized button Themes \u00b6 The visual elements that Taipy GUI generates are extensions of Material UI components. This components library has great support for theming, so you can customize how things will look across all components. Material UI exposes the full API for handling themes, which you can find on the MUI Theming page. To change the theme of your application, you must use the theme configuration parameter (for example in the Gui.run() method) as explained in the Configuration section. You could also impact only the light or the dark theme using the light_theme or dark_theme configuration settings. Here is how you would change the general theme if you wanted the background color to be a neutral gray color (#808080 in CSS) and make the primary color an orange-looking color instead of the default blue color. In your Python code, you would create a theme dictionary and provide it as the value of the theme parameter of the method Gui.run() : ... my_theme = { \"palette\" : { \"background\" : { \"default\" : \"#808080\" }, \"primary\" : { \"main\" : \"#a25221\" } } } ... gui . run ( theme = my_theme ) See the impact of setting this custom theme: Regular button Themed button","title":"Styling"},{"location":"manuals/gui/styling/#styling","text":"As mentioned several times, page content is parsed and converted to be sent to the user's browser. The final page content actually is pure HTML that one can apply some style to, providing the best user experience. Styling involves some knowledge of Cascading Style Sheets . This section describes what sort of styling you may want to apply, in different situations.","title":"Styling"},{"location":"manuals/gui/styling/#style-sheets","text":"There are two ways you can apply a stylesheet to your application: Global style sheet. The css_file parameter of the Gui constructor lets you specify a CSS file that your application will use for every page. The default value for this parameter is a file located next to your main Python script, with the same name except for the extension that must be '.css'. Page-specific style. The method Gui.add_page()^ has a style parameter that can be set to CSS content. This additional style is applied to the page and only this page. Beside explicit style sheets, you can also modify the global theme, as described in the section on Themes .","title":"Style sheets"},{"location":"manuals/gui/styling/#applying-style","text":"Once the style sheets are set for the application, you can start learning about how styles can be expressed to pages.","title":"Applying style"},{"location":"manuals/gui/styling/#global-styles","text":"As in any Web application, the root element ( :root ) is available for global style settings. For example, if you want to make your application bigger, enlarging the font size, you could write: : root { font-size : 2 rem ; } And all pages will appear twice as big.","title":"Global styles"},{"location":"manuals/gui/styling/#markdown-styles","text":"Thanks to the Attribute Lists extension, the Markdown text can hold attributes used for styling. If, for example, your Markdown content is the following: ... This line should be displayed in blue. { .blue-line } ... and a style sheet used by the application indicates: . blue-line { color : blue ; } then the text line is displayed in blue. Please check the documentation for the Attribute Lists extension to find more information. div vs. p Instead of generating <p> HTML tags for lines of text, Taipy uses <div> tags. This allows more complex structures in pages, such as elements within elements.","title":"Markdown styles"},{"location":"manuals/gui/styling/#main-page-style","text":"The top-most element of the generated page is a <div> element with the 'id' attribute set to \"root\". If you need to reference the top-most element of your page, you can select it in your CSS stylesheets using the selector: div#root .","title":"Main page style"},{"location":"manuals/gui/styling/#visual-elements-specific-styles","text":"You can apply some style to any visual element you have added to your pages.","title":"Visual elements-specific styles"},{"location":"manuals/gui/styling/#using-css-classes","text":"Every visual element is assigned a CSS class that depends on the type of the element. The default associated class name is made of the string \"taipy-\" followed by the type of element: all Taipy buttons, for example, have the CSS class name: \"taipy-button\" . You can therefore create a weird-looking button displayed in an oval by setting a style sheet that contains: . taipy-button { border-radius : 50 % ; } Now all the buttons of your application will look the same, with an oval shape instead of a rectangle with rounded corners. If your Markdown page contains the following control: <|Click me|button|> The CSS rule above will impact your display this way: Regular button Rounded button You can also add CSS class names of your choice using the classname property of all visual elements. If you need to assign more than one class to an element, you can separate each individual class name with a space character: <|Click me|button|classname=\"option testing\"|> This Markdown fragment gets converted into an HTML element with three CSS classes assigned: taipy-button , option , and testing .","title":"Using CSS classes"},{"location":"manuals/gui/styling/#using-the-html-id-attribute","text":"You can use the id property of all visual elements to generate an HTML id that can be used by CSS styling. For example, if your Markdown page contains the following control: <|Click me|button|id=\"my_button\"|> You can change the style of that button using a CSS selector that relies on the id of the button: # my_button { text-transform : none ; } Now the button shows the text 'Click me' instead of 'CLICK ME': the default in Material UI (which is the components library Taipy GUI relies on) is to capitalize the text of buttons. Regular button Uncapitalized button","title":"Using the HTML 'id' attribute"},{"location":"manuals/gui/styling/#themes","text":"The visual elements that Taipy GUI generates are extensions of Material UI components. This components library has great support for theming, so you can customize how things will look across all components. Material UI exposes the full API for handling themes, which you can find on the MUI Theming page. To change the theme of your application, you must use the theme configuration parameter (for example in the Gui.run() method) as explained in the Configuration section. You could also impact only the light or the dark theme using the light_theme or dark_theme configuration settings. Here is how you would change the general theme if you wanted the background color to be a neutral gray color (#808080 in CSS) and make the primary color an orange-looking color instead of the default blue color. In your Python code, you would create a theme dictionary and provide it as the value of the theme parameter of the method Gui.run() : ... my_theme = { \"palette\" : { \"background\" : { \"default\" : \"#808080\" }, \"primary\" : { \"main\" : \"#a25221\" } } } ... gui . run ( theme = my_theme ) See the impact of setting this custom theme: Regular button Themed button","title":"Themes"},{"location":"manuals/gui/viselements/","text":"Introduction to Visual Elements \u00b6 Visual Elements are user interface objects displayed on a given page. Visual elements reflect some application data or give the page some structuring or layout information. Most visual elements allow users to interact with the page content. There are two types of Visual Elements : Controls typically represent user data that the user can interact with; Blocks let you organize controls (or blocks) in pages to provide the best possible user experience. If you are familiar with what Visual Elements are and how they are declared, you may want to jump directly to the list of the available visual elements: List of available controls List of available blocks Properties \u00b6 Each visual element has a type and a set of properties. To add a visual component to a page, appropriate syntax must be used, indicating the type of visual element and the properties of the element. Property name \u00b6 Every element type has a default property name that holds its 'main' representation: a string for a text element, an array for a selector, or a numerical value for a slider. To set the value for this property, the short version of the visual element syntax can be used. Property value \u00b6 Every property value can be set to a value that depends on the property type or a formatted string literal, also known as an f-string . This string may reference variable names defined in the code, and the value of the property is set to the evaluated string. Dynamic properties When a property is listed as dynamic , changing the value of any variable in the expression will update visual element that uses it. Syntax \u00b6 You create visual elements using either a specific Markdown syntax (see the Markdown^ class) or specific HTML tags (see the Html^ class). Markdown \u00b6 The basic syntax for creating Taipy constructs in Markdown is: <|...|...|> (opening with a less than character followed by a vertical bar character \u2014 sometimes called pipe \u2014 followed by a potentially empty series of vertical bar-separated fragments and closing with a vertical bar character immediately followed by the greater than character). Taipy interprets any text between the <| and the |> markers and tries to create visual elements to be inserted in the resulting page. The most common use of this construct is to create controls. Taipy expects the control type name to appear between the two first vertical bar characters (as in <|control|...}> . Important If the first fragment text is not the name of a control type, Taipy will consider this fragment to be the default value for the default property of the control, whose type name must then appear as the second element. <|visual_element_type|default_property_name=default_property_value|> Is equivalent to <|default_property_value|visual_element_type|> Every visual element has a default property, and using the default property syntax (where the default property value appears as the first || fragment) underscore, but placing it first, the most important property value for this visual element: it would be the content of a text control, the label of a button , or the data set displayed by a chart , for example. Every following |-separated fragment is interpreted as a property name-property value pair using the syntax: property_name=property_value (note that all space characters are significative). So creating a visual element in Markdown text is just a matter of inserting a text fragment similar to: <|visual_element_type|property_name=property_value|...|> Note You can have as many property name-property value pairs as needed, and all of the space characters of the property value part are significant: The fragment <|Content |text|> will be displayed as the string \"Content\" followed by a space character, because it is part of the property value (in this case, the default property value, which is the property called value for the text control) Shortcut for Boolean properties Should the =property_value fragment be missing, the property value is interpreted as the Boolean value True . Furthermore, if the property name is preceded by the text \" no\u2423 \", \" not\u2423 \", \" don't\u2423 \" or \" dont\u2423 \" (including the trailing space character), then no property value is expected, and the property value is set to False . Unknown properties If you set a property that a visual element does not recognize, it is ignored without any warning. Some examples \u00b6 Multiple properties You can have several properties defined in the same control fragment: <|button|label=Do something|active=False|> The default property rule The default property name for the control type button is label . In Taipy, the Markdown text <|button|label=Some text|> Is exactly equivalent to <|Some text|button|> which is slightly shorter. The missing Boolean property value rules <|button|active=True|> is equivalent to <|button|active|> And <|button|active=False|> is equivalent to <|button|not active|> There are very few exceptions to the <|control_type|...|> syntax, which are described in their respective documentation section. The most obvious exception is the text control, which can be created without even mentioning its type. HTML \u00b6 If you choose to embed Taipy visual elements into existing HTML pages, you can use the following syntax: < taipy:visual_element_type property_name = \"property_value\" ... > </ taipy:visual_element_type > The text element of the visual element tag can be used to indicate the default property value for this visual element: < taipy:visual_element_type default_property_name = \"default_property_value\" ... /> is equivalent to < taipy:visual_element_type > default_property_value </ taipy:visual_element_type > HTML syntax extensions The HTML text that is given to the Html^ page renderer is not parsed as pure HTML. Rather, the page is transformed before it is rendered to HTML and delivered to the client. Therefore, Taipy was able to introduce a few changes to the pure HTML syntax that make it easier to use in the context of describing Taipy pages. Attribute names that be array elements. Some visual elements (such as the chart control) need indexed properties. An attribute name such as y[1] is valid in the Taipy context, where it would not be in the raw HTML grammar. Empty attribute value. In the HTML used by Taipy, you can mention an attribute with no value. It would be equivalent to setting it to True . Generic properties \u00b6 Every visual element type has the following properties: id : The identifier of the element. This identifier is generated in the HTML component and can be used for styling . class_name : An additional CSS class that is added to the generated HTML component. Note that all visual elements are generated with the \"taipy- visual_element_type \" CSS class set (e.g. the button control generates an HTML element that has the taipy-button CSS class). properties : The name of a variable that holds a dictionary where all property name/value pairs will be used by a given visual element declaration. All or most Taipy visual elements expose similar properties that can be used generically across your pages. The id property \u00b6 You can specify an identifier for a specific visual element. This identifier is used as the id attribute of the generated HTML component so you can use it in your CSS selectors. Note This identifier is also sent to the on_action callback if this visual element can trigger actions (see Actions for details). The properties property \u00b6 There are situations where your visual element may need a lot of different properties. This is typically the case for complex visual elements like the chart or the table controls. When an element needs many properties and property values, the content may become difficult to read. Something you can do about this is create a Python dictionary that contains all the key-value pairs for your properties (name and value), then use the name of the variable that holds that dictionary as the value of the properties property. Example Say your Markdown content needs the following control: <|dialog|title=Select an item in the list|open={show_dialog}|labels=Cancel;Validate|page_id=page|close_label=Cancel|> As this syntax can be cumbersome, you might prefer to define a simple Python dictionary: 1 2 3 4 5 6 dialog_props = { \"title\" : \"Select an item in the list\" , \"labels\" : \"Cancel;Validate\" , \"page_id\" : \"page\" , \"close_label\" : \"Cancel\" } Then shorten your Markdown text with the following syntax: <{show_dialog}|dialog|properties=dialog_props|> The propagate property \u00b6 There are situations where you don't want a variable bound to a control value (such as the knob location of a slider) to be updated immediately then the user manipulates the control. You may for example want to check the received value in the on_change callback and decide to use this new value or not. This is the purpose of the propagate property. When the propagate property is set to True, then the application variable bound to a control is updated when the user modifies the value represented by the control. Info Note that if there is a function called on_change accessible to the Gui instance (see the section on Variable Value Change for details), it will be invoked no matter what the propagate value is. The variable value that this function receives is the new requested value, but this value is not set to the variable bound to the control. Besides those common properties, every visual element type has a specific set of properties that you can use, listed in the documentation page for each visual element.","title":"Visual Elements"},{"location":"manuals/gui/viselements/#introduction-to-visual-elements","text":"Visual Elements are user interface objects displayed on a given page. Visual elements reflect some application data or give the page some structuring or layout information. Most visual elements allow users to interact with the page content. There are two types of Visual Elements : Controls typically represent user data that the user can interact with; Blocks let you organize controls (or blocks) in pages to provide the best possible user experience. If you are familiar with what Visual Elements are and how they are declared, you may want to jump directly to the list of the available visual elements: List of available controls List of available blocks","title":"Introduction to Visual Elements"},{"location":"manuals/gui/viselements/#properties","text":"Each visual element has a type and a set of properties. To add a visual component to a page, appropriate syntax must be used, indicating the type of visual element and the properties of the element.","title":"Properties"},{"location":"manuals/gui/viselements/#property-name","text":"Every element type has a default property name that holds its 'main' representation: a string for a text element, an array for a selector, or a numerical value for a slider. To set the value for this property, the short version of the visual element syntax can be used.","title":"Property name"},{"location":"manuals/gui/viselements/#property-value","text":"Every property value can be set to a value that depends on the property type or a formatted string literal, also known as an f-string . This string may reference variable names defined in the code, and the value of the property is set to the evaluated string. Dynamic properties When a property is listed as dynamic , changing the value of any variable in the expression will update visual element that uses it.","title":"Property value"},{"location":"manuals/gui/viselements/#syntax","text":"You create visual elements using either a specific Markdown syntax (see the Markdown^ class) or specific HTML tags (see the Html^ class).","title":"Syntax"},{"location":"manuals/gui/viselements/#markdown","text":"The basic syntax for creating Taipy constructs in Markdown is: <|...|...|> (opening with a less than character followed by a vertical bar character \u2014 sometimes called pipe \u2014 followed by a potentially empty series of vertical bar-separated fragments and closing with a vertical bar character immediately followed by the greater than character). Taipy interprets any text between the <| and the |> markers and tries to create visual elements to be inserted in the resulting page. The most common use of this construct is to create controls. Taipy expects the control type name to appear between the two first vertical bar characters (as in <|control|...}> . Important If the first fragment text is not the name of a control type, Taipy will consider this fragment to be the default value for the default property of the control, whose type name must then appear as the second element. <|visual_element_type|default_property_name=default_property_value|> Is equivalent to <|default_property_value|visual_element_type|> Every visual element has a default property, and using the default property syntax (where the default property value appears as the first || fragment) underscore, but placing it first, the most important property value for this visual element: it would be the content of a text control, the label of a button , or the data set displayed by a chart , for example. Every following |-separated fragment is interpreted as a property name-property value pair using the syntax: property_name=property_value (note that all space characters are significative). So creating a visual element in Markdown text is just a matter of inserting a text fragment similar to: <|visual_element_type|property_name=property_value|...|> Note You can have as many property name-property value pairs as needed, and all of the space characters of the property value part are significant: The fragment <|Content |text|> will be displayed as the string \"Content\" followed by a space character, because it is part of the property value (in this case, the default property value, which is the property called value for the text control) Shortcut for Boolean properties Should the =property_value fragment be missing, the property value is interpreted as the Boolean value True . Furthermore, if the property name is preceded by the text \" no\u2423 \", \" not\u2423 \", \" don't\u2423 \" or \" dont\u2423 \" (including the trailing space character), then no property value is expected, and the property value is set to False . Unknown properties If you set a property that a visual element does not recognize, it is ignored without any warning.","title":"Markdown"},{"location":"manuals/gui/viselements/#some-examples","text":"Multiple properties You can have several properties defined in the same control fragment: <|button|label=Do something|active=False|> The default property rule The default property name for the control type button is label . In Taipy, the Markdown text <|button|label=Some text|> Is exactly equivalent to <|Some text|button|> which is slightly shorter. The missing Boolean property value rules <|button|active=True|> is equivalent to <|button|active|> And <|button|active=False|> is equivalent to <|button|not active|> There are very few exceptions to the <|control_type|...|> syntax, which are described in their respective documentation section. The most obvious exception is the text control, which can be created without even mentioning its type.","title":"Some examples"},{"location":"manuals/gui/viselements/#html","text":"If you choose to embed Taipy visual elements into existing HTML pages, you can use the following syntax: < taipy:visual_element_type property_name = \"property_value\" ... > </ taipy:visual_element_type > The text element of the visual element tag can be used to indicate the default property value for this visual element: < taipy:visual_element_type default_property_name = \"default_property_value\" ... /> is equivalent to < taipy:visual_element_type > default_property_value </ taipy:visual_element_type > HTML syntax extensions The HTML text that is given to the Html^ page renderer is not parsed as pure HTML. Rather, the page is transformed before it is rendered to HTML and delivered to the client. Therefore, Taipy was able to introduce a few changes to the pure HTML syntax that make it easier to use in the context of describing Taipy pages. Attribute names that be array elements. Some visual elements (such as the chart control) need indexed properties. An attribute name such as y[1] is valid in the Taipy context, where it would not be in the raw HTML grammar. Empty attribute value. In the HTML used by Taipy, you can mention an attribute with no value. It would be equivalent to setting it to True .","title":"HTML"},{"location":"manuals/gui/viselements/#generic-properties","text":"Every visual element type has the following properties: id : The identifier of the element. This identifier is generated in the HTML component and can be used for styling . class_name : An additional CSS class that is added to the generated HTML component. Note that all visual elements are generated with the \"taipy- visual_element_type \" CSS class set (e.g. the button control generates an HTML element that has the taipy-button CSS class). properties : The name of a variable that holds a dictionary where all property name/value pairs will be used by a given visual element declaration. All or most Taipy visual elements expose similar properties that can be used generically across your pages.","title":"Generic properties"},{"location":"manuals/gui/viselements/#the-id-property","text":"You can specify an identifier for a specific visual element. This identifier is used as the id attribute of the generated HTML component so you can use it in your CSS selectors. Note This identifier is also sent to the on_action callback if this visual element can trigger actions (see Actions for details).","title":"The id property"},{"location":"manuals/gui/viselements/#the-properties-property","text":"There are situations where your visual element may need a lot of different properties. This is typically the case for complex visual elements like the chart or the table controls. When an element needs many properties and property values, the content may become difficult to read. Something you can do about this is create a Python dictionary that contains all the key-value pairs for your properties (name and value), then use the name of the variable that holds that dictionary as the value of the properties property. Example Say your Markdown content needs the following control: <|dialog|title=Select an item in the list|open={show_dialog}|labels=Cancel;Validate|page_id=page|close_label=Cancel|> As this syntax can be cumbersome, you might prefer to define a simple Python dictionary: 1 2 3 4 5 6 dialog_props = { \"title\" : \"Select an item in the list\" , \"labels\" : \"Cancel;Validate\" , \"page_id\" : \"page\" , \"close_label\" : \"Cancel\" } Then shorten your Markdown text with the following syntax: <{show_dialog}|dialog|properties=dialog_props|>","title":"The properties property"},{"location":"manuals/gui/viselements/#the-propagate-property","text":"There are situations where you don't want a variable bound to a control value (such as the knob location of a slider) to be updated immediately then the user manipulates the control. You may for example want to check the received value in the on_change callback and decide to use this new value or not. This is the purpose of the propagate property. When the propagate property is set to True, then the application variable bound to a control is updated when the user modifies the value represented by the control. Info Note that if there is a function called on_change accessible to the Gui instance (see the section on Variable Value Change for details), it will be invoked no matter what the propagate value is. The variable value that this function receives is the new requested value, but this value is not set to the variable bound to the control. Besides those common properties, every visual element type has a specific set of properties that you can use, listed in the documentation page for each visual element.","title":"The propagate property"},{"location":"manuals/gui/viselements/button/","text":"button \u00b6 A control that can trigger a function when pressed. Properties \u00b6 Name Type Default Description label (\u2605) dynamic(str|Icon) \"\" The label displayed in the button. on_action Callback The name of a function that is triggered when the button is pressed. The parameters of that function are all optional: state (State^): state instance. id (optional[str]): the identifier of the button. action (optional[str]): the name of the action that provoked the change. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) label is the default property for this visual element. Usage \u00b6 Simple text \u00b6 The button label, which is the button control's default property, is simply displayed as the button text. Page content Markdown <|Button Label|button|> HTML < taipy:button > Button Label </ taipy:button > Specific action callback \u00b6 Button can specify a callback function to be invoked when the button is pressed. Page content Markdown <|Button Label|button|on_action=button_action_function_name|> HTML < taipy:button on_action = \"button_action_function_name\" > Button Label </ taipy:button >","title":"<tt>button</tt>"},{"location":"manuals/gui/viselements/button/#button","text":"A control that can trigger a function when pressed.","title":"button"},{"location":"manuals/gui/viselements/button/#properties","text":"Name Type Default Description label (\u2605) dynamic(str|Icon) \"\" The label displayed in the button. on_action Callback The name of a function that is triggered when the button is pressed. The parameters of that function are all optional: state (State^): state instance. id (optional[str]): the identifier of the button. action (optional[str]): the name of the action that provoked the change. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) label is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/button/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/button/#simple-text","text":"The button label, which is the button control's default property, is simply displayed as the button text. Page content Markdown <|Button Label|button|> HTML < taipy:button > Button Label </ taipy:button >","title":"Simple text"},{"location":"manuals/gui/viselements/button/#specific-action-callback","text":"Button can specify a callback function to be invoked when the button is pressed. Page content Markdown <|Button Label|button|on_action=button_action_function_name|> HTML < taipy:button on_action = \"button_action_function_name\" > Button Label </ taipy:button >","title":"Specific action callback"},{"location":"manuals/gui/viselements/chart/","text":"chart \u00b6 Displays data sets in a chart or a group of charts. The chart control is based on the plotly.js graphs library. A chart control can hold several traces, that can display individual data sets. To indicate properties for a given trace, you will use the indexed properties (using the property_name[index] syntax, with the indices starting at index 1) to specify which trace you target. Indexed properties can have a default value (using the property_name syntax with no index) which is overridden by any specified indexed property. The data property supported types are: pandas Dataframe list of lists numpy series list of pandas dataframes Properties \u00b6 Name Type Default Description data (\u2605) any Mandatory The data object bound to this chart control. type indexed(str) scatter Chart type. See the Plotly chart type documentation for details. mode indexed(str) lines+markers Chart mode. See the Plotly chart mode documentation for details. x indexed(str) Column name for the x axis. y indexed(str) Column name for the y axis. z indexed(str) Column name for the z axis. text indexed(str) Column name for the text associated to the point for the indicated trace. This is meaningful only when _mode_ has the text option. title str The title of this chart control. render bool True If True, this chart is visible on the page. on_range_change Callback Callback function called when the visible part of the x axis changes. The function receives three parameters: state (State^): state instance. id (optional[str]): the identifier of the chart control. action (optional[str]): the name of the action that provoked the change. payload (dict[str, any]): all the event information, as emitted by plotly . columns str|List[str]|dict[str, dict[str, str]] _All columns_ List of column names str: ;-separated list of column names List[str]: list of names dict: {\"col_name\": {format: \"format\", index: 1}} if index is specified, it represents the display order of the columns. If not, the list order defines the index label indexed(str) The label for the indicated trace. This is used when the mouse hovers over a trace. name indexed(str) The name of the indicated trace. selected dynamic(list[int]|str) List of the selected point indices. color indexed(str) The color of the indicated trace. selected_color indexed(str) The color of the selected points for the indicated trace. marker indexed(dict[str, any]) The type of markers used for the indicated trace. See marker for details. line indexed(str|dict[str, any]) The configuration of the line used for the indicated trace. See line for details. if str then dash?? selected_marker indexed(dict[str, any]) The type of markers used for selected points in the indicated trace. See selected marker for details. layout dict[str, any] The plotly.js compatible layout object . plot_config dict[str, any] The plotly.js compatible configuration options object . options indexed(dict[str, any]) The plotly.js compatible data object where dynamic data will be overridden. . orientation indexed(str) The orientation of the indicated trace. text_anchor indexed(str) Position of the text relative to the point. Valid values are: top , bottom , left , and right . xaxis indexed(str) The x axis identifier for the indicated trace. yaxis indexed(str) The y axis identifier for the indicated trace. width str|int|float 100% The width, in CSS units, of this element. height str|int|float The height, in CSS units, of this element. on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. propagate bool App config Allows the control's main value to be automatically propagated. The default value is defined at the application configuration level. If True , any change to the control's value is immediately reflected in the bound application variable. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) data is the default property for this visual element. Usage \u00b6 Because the chart control is so flexible, we have split the different use cases into separate sections. Basic concepts Line charts Bar charts Scatter charts Other features","title":"<tt>chart</tt>"},{"location":"manuals/gui/viselements/chart/#chart","text":"Displays data sets in a chart or a group of charts. The chart control is based on the plotly.js graphs library. A chart control can hold several traces, that can display individual data sets. To indicate properties for a given trace, you will use the indexed properties (using the property_name[index] syntax, with the indices starting at index 1) to specify which trace you target. Indexed properties can have a default value (using the property_name syntax with no index) which is overridden by any specified indexed property. The data property supported types are: pandas Dataframe list of lists numpy series list of pandas dataframes","title":"chart"},{"location":"manuals/gui/viselements/chart/#properties","text":"Name Type Default Description data (\u2605) any Mandatory The data object bound to this chart control. type indexed(str) scatter Chart type. See the Plotly chart type documentation for details. mode indexed(str) lines+markers Chart mode. See the Plotly chart mode documentation for details. x indexed(str) Column name for the x axis. y indexed(str) Column name for the y axis. z indexed(str) Column name for the z axis. text indexed(str) Column name for the text associated to the point for the indicated trace. This is meaningful only when _mode_ has the text option. title str The title of this chart control. render bool True If True, this chart is visible on the page. on_range_change Callback Callback function called when the visible part of the x axis changes. The function receives three parameters: state (State^): state instance. id (optional[str]): the identifier of the chart control. action (optional[str]): the name of the action that provoked the change. payload (dict[str, any]): all the event information, as emitted by plotly . columns str|List[str]|dict[str, dict[str, str]] _All columns_ List of column names str: ;-separated list of column names List[str]: list of names dict: {\"col_name\": {format: \"format\", index: 1}} if index is specified, it represents the display order of the columns. If not, the list order defines the index label indexed(str) The label for the indicated trace. This is used when the mouse hovers over a trace. name indexed(str) The name of the indicated trace. selected dynamic(list[int]|str) List of the selected point indices. color indexed(str) The color of the indicated trace. selected_color indexed(str) The color of the selected points for the indicated trace. marker indexed(dict[str, any]) The type of markers used for the indicated trace. See marker for details. line indexed(str|dict[str, any]) The configuration of the line used for the indicated trace. See line for details. if str then dash?? selected_marker indexed(dict[str, any]) The type of markers used for selected points in the indicated trace. See selected marker for details. layout dict[str, any] The plotly.js compatible layout object . plot_config dict[str, any] The plotly.js compatible configuration options object . options indexed(dict[str, any]) The plotly.js compatible data object where dynamic data will be overridden. . orientation indexed(str) The orientation of the indicated trace. text_anchor indexed(str) Position of the text relative to the point. Valid values are: top , bottom , left , and right . xaxis indexed(str) The x axis identifier for the indicated trace. yaxis indexed(str) The y axis identifier for the indicated trace. width str|int|float 100% The width, in CSS units, of this element. height str|int|float The height, in CSS units, of this element. on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. propagate bool App config Allows the control's main value to be automatically propagated. The default value is defined at the application configuration level. If True , any change to the control's value is immediately reflected in the bound application variable. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) data is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/chart/#usage","text":"Because the chart control is so flexible, we have split the different use cases into separate sections. Basic concepts Line charts Bar charts Scatter charts Other features","title":"Usage"},{"location":"manuals/gui/viselements/date/","text":"date \u00b6 A control that can display and specified a formatted date, with or without time. Properties \u00b6 Name Type Default Description date (\u2605) dynamic(datetime) The date that this control represents and can modify. It is typically bound to a datetime object. with_time bool False Whether or not to show the time part of the date. format str The format to apply to the value. See below. editable dynamic(bool) True Shows the date as a formatted string if not editable. on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. propagate bool App config Allows the control's main value to be automatically propagated. The default value is defined at the application configuration level. If True , any change to the control's value is immediately reflected in the bound application variable. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) date is the default property for this visual element. Usage \u00b6 Using the full date and time \u00b6 Assuming a variable dt contains a Python datetime object, you can create a date selector that represents it: Page content Markdown <|{dt}|date|> HTML < taipy:date > {dt} </ taipy:date > Using only the date \u00b6 If you don't need to use the date, you can do so: Page content Markdown <|{dt}|date|not with_time|> HTML < taipy:date with_time = \"false\" > {dt} </ taipy:date >","title":"<tt>date</tt>"},{"location":"manuals/gui/viselements/date/#date","text":"A control that can display and specified a formatted date, with or without time.","title":"date"},{"location":"manuals/gui/viselements/date/#properties","text":"Name Type Default Description date (\u2605) dynamic(datetime) The date that this control represents and can modify. It is typically bound to a datetime object. with_time bool False Whether or not to show the time part of the date. format str The format to apply to the value. See below. editable dynamic(bool) True Shows the date as a formatted string if not editable. on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. propagate bool App config Allows the control's main value to be automatically propagated. The default value is defined at the application configuration level. If True , any change to the control's value is immediately reflected in the bound application variable. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) date is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/date/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/date/#using-the-full-date-and-time","text":"Assuming a variable dt contains a Python datetime object, you can create a date selector that represents it: Page content Markdown <|{dt}|date|> HTML < taipy:date > {dt} </ taipy:date >","title":"Using the full date and time"},{"location":"manuals/gui/viselements/date/#using-only-the-date","text":"If you don't need to use the date, you can do so: Page content Markdown <|{dt}|date|not with_time|> HTML < taipy:date with_time = \"false\" > {dt} </ taipy:date >","title":"Using only the date"},{"location":"manuals/gui/viselements/dialog/","text":"dialog \u00b6 A modal dialog. Dialog allows showing some content over the current page. The dialog is closed when the user presses the Cancel or Validate buttons, or clicks outside the area of the dialog (triggering a Cancel action). Properties \u00b6 Name Type Default Description open (\u2605) bool False If True , the dialog is visible. If False , it is hidden. on_action Callback Name of a function that is triggered when a button is pressed. The parameters of that function are all optional: state (State^): state instance. id (optional[str]): the identifier of the dialog. action (optional[str]): the name of the action that provoked the change. payload args: List where the first element contains the index of the selected label. close_label str \"Close\" The tooltip of the top-right close icon button. In the on_action function, args will hold -1. labels str|list[str] A list of labels to show in a row of buttons at the bottom of the dialog. The index of the button in the list is reported as args in the on_action function (-1 for the close icon). partial Partial A Partial object that holds the content of the dialog. This should not be defined if page is set. page str The page name to show as the content of the dialog. This should not be defined if partial is set. width str|int|float The width, in CSS units, of this dialog. (CSS property) height str|int|float The height, in CSS units, of this dialog. (CSS property) active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) open is the default property for this visual element. Usage \u00b6 Showing or hiding a dialog \u00b6 The default property, open , indicates whether the dialog is visible or not: Page content Markdown <|{show_dialog}|dialog|on_action={lambda s: s.assign(\"show_dialog\", False)}|> HTML < taipy:dialog on_action = \"on_action={lambda s: s.assign('show_dialog', False)}\" > {show_dialog} </ taipy:dialog > With another action that would have previously shown the dialog with: def button_action ( state , id , action ): state . show_dialog = True Specifying labels and actions \u00b6 Several properties let you specify the buttons to show, and the action (callback functions) triggered when buttons are pressed: Page content Markdown <|dialog|title=Dialog Title|open={show_dialog}|page_id=page1|on_action=dialog_action|labels=Validate;Cancel|> HTML < taipy:dialog title = \"Dialog Title\" page_id = \"page1\" labels = \"Validate;Cancel\" on_action = \"dialog_action\" > {show_dialog} </ taipy:dialog > The implementation of the dialog callback could be: def dialog_action ( state , id , action , payload ): with state as st : ... # depending on payload[\"args\"][0]: -1 for close icon, 0 for Validate, 1 for Cancel ... st . show_dialog = False Dialog as block element \u00b6 The content of the dialog can be specified directly inside the dialog block. Page content Markdown <|{show_dialog}|dialog| ... <|{some content}|> ... |> HTML < taipy:dialog open = {show_dialog} > ... < taipy:text > {some content} </ taipy:text > ... </ taipy:dialog > Dialog with page \u00b6 The content of the dialog can be specified as an existing page name using the page property. Page content Markdown <|{show_dialog}|dialog|page=page_name|> HTML < taipy:dialog page = \"page_name\" > {show_dialog} </ taipy:dialog > Dialog with partial \u00b6 The content of the dialog can be specified as a Partial^ instance using the partial property. Page content Markdown <|{show_dialog}|dialog|partial={partial}|> HTML < taipy:dialog partial = \"{partial}\" > {show_dialog} </ taipy:dialog >","title":"<tt>dialog</tt>"},{"location":"manuals/gui/viselements/dialog/#dialog","text":"A modal dialog. Dialog allows showing some content over the current page. The dialog is closed when the user presses the Cancel or Validate buttons, or clicks outside the area of the dialog (triggering a Cancel action).","title":"dialog"},{"location":"manuals/gui/viselements/dialog/#properties","text":"Name Type Default Description open (\u2605) bool False If True , the dialog is visible. If False , it is hidden. on_action Callback Name of a function that is triggered when a button is pressed. The parameters of that function are all optional: state (State^): state instance. id (optional[str]): the identifier of the dialog. action (optional[str]): the name of the action that provoked the change. payload args: List where the first element contains the index of the selected label. close_label str \"Close\" The tooltip of the top-right close icon button. In the on_action function, args will hold -1. labels str|list[str] A list of labels to show in a row of buttons at the bottom of the dialog. The index of the button in the list is reported as args in the on_action function (-1 for the close icon). partial Partial A Partial object that holds the content of the dialog. This should not be defined if page is set. page str The page name to show as the content of the dialog. This should not be defined if partial is set. width str|int|float The width, in CSS units, of this dialog. (CSS property) height str|int|float The height, in CSS units, of this dialog. (CSS property) active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) open is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/dialog/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/dialog/#showing-or-hiding-a-dialog","text":"The default property, open , indicates whether the dialog is visible or not: Page content Markdown <|{show_dialog}|dialog|on_action={lambda s: s.assign(\"show_dialog\", False)}|> HTML < taipy:dialog on_action = \"on_action={lambda s: s.assign('show_dialog', False)}\" > {show_dialog} </ taipy:dialog > With another action that would have previously shown the dialog with: def button_action ( state , id , action ): state . show_dialog = True","title":"Showing or hiding a dialog"},{"location":"manuals/gui/viselements/dialog/#specifying-labels-and-actions","text":"Several properties let you specify the buttons to show, and the action (callback functions) triggered when buttons are pressed: Page content Markdown <|dialog|title=Dialog Title|open={show_dialog}|page_id=page1|on_action=dialog_action|labels=Validate;Cancel|> HTML < taipy:dialog title = \"Dialog Title\" page_id = \"page1\" labels = \"Validate;Cancel\" on_action = \"dialog_action\" > {show_dialog} </ taipy:dialog > The implementation of the dialog callback could be: def dialog_action ( state , id , action , payload ): with state as st : ... # depending on payload[\"args\"][0]: -1 for close icon, 0 for Validate, 1 for Cancel ... st . show_dialog = False","title":"Specifying labels and actions"},{"location":"manuals/gui/viselements/dialog/#dialog-as-block-element","text":"The content of the dialog can be specified directly inside the dialog block. Page content Markdown <|{show_dialog}|dialog| ... <|{some content}|> ... |> HTML < taipy:dialog open = {show_dialog} > ... < taipy:text > {some content} </ taipy:text > ... </ taipy:dialog >","title":"Dialog as block element"},{"location":"manuals/gui/viselements/dialog/#dialog-with-page","text":"The content of the dialog can be specified as an existing page name using the page property. Page content Markdown <|{show_dialog}|dialog|page=page_name|> HTML < taipy:dialog page = \"page_name\" > {show_dialog} </ taipy:dialog >","title":"Dialog with page"},{"location":"manuals/gui/viselements/dialog/#dialog-with-partial","text":"The content of the dialog can be specified as a Partial^ instance using the partial property. Page content Markdown <|{show_dialog}|dialog|partial={partial}|> HTML < taipy:dialog partial = \"{partial}\" > {show_dialog} </ taipy:dialog >","title":"Dialog with partial"},{"location":"manuals/gui/viselements/expandable/","text":"expandable \u00b6 Displays its child elements in a collapsable area. Expandable is a block control. Properties \u00b6 Name Type Default Description value (\u2605) str Title of this block element. expanded bool True If True , the block is expanded, and the content is displayed. If False , the block is collapsed and its content is hidden. partial Partial A Partial object that holds the content of the dialog. This should not be defined if page is set. page str The page name to show as the content of the dialog. This should not be defined if partial is set. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element. Usage \u00b6 Defining a title and managing expanded state \u00b6 The default property title defines the title shown when the visual element is collapsed. Page content Markdown <|Title|expandable|expand={expand}|> HTML < taipy:expandable expand = \"{expand}\" > Title </ taipy:expandable > Content as block \u00b6 The content of expandable can be specified as the block content. Page content Markdown <|Title|expandable| ... <|{some content}|> ... |> HTML < taipy:expandable title = \"Title\" > ... < taipy:text > {some content} </ taipy:text > ... </ taipy:expandable > Expandable with page \u00b6 The content of the expandable can be specified as an existing page name using the page property. Page content Markdown <|Title|expandable|page=page_name|> HTML < taipy:expandable page = \"page_name\" > Title </ taipy:expandable > Expandable with partial \u00b6 The content of the expandable can be specified as a Partial^ instance using the partial property. Page content Markdown <|Title|expandable|partial={partial}|> HTML < taipy:expandable partial = \"{partial}\" > Title </ taipy:dialog >","title":"<tt>expandable</tt>"},{"location":"manuals/gui/viselements/expandable/#expandable","text":"Displays its child elements in a collapsable area. Expandable is a block control.","title":"expandable"},{"location":"manuals/gui/viselements/expandable/#properties","text":"Name Type Default Description value (\u2605) str Title of this block element. expanded bool True If True , the block is expanded, and the content is displayed. If False , the block is collapsed and its content is hidden. partial Partial A Partial object that holds the content of the dialog. This should not be defined if page is set. page str The page name to show as the content of the dialog. This should not be defined if partial is set. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/expandable/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/expandable/#defining-a-title-and-managing-expanded-state","text":"The default property title defines the title shown when the visual element is collapsed. Page content Markdown <|Title|expandable|expand={expand}|> HTML < taipy:expandable expand = \"{expand}\" > Title </ taipy:expandable >","title":"Defining a title and managing expanded state"},{"location":"manuals/gui/viselements/expandable/#content-as-block","text":"The content of expandable can be specified as the block content. Page content Markdown <|Title|expandable| ... <|{some content}|> ... |> HTML < taipy:expandable title = \"Title\" > ... < taipy:text > {some content} </ taipy:text > ... </ taipy:expandable >","title":"Content as block"},{"location":"manuals/gui/viselements/expandable/#expandable-with-page","text":"The content of the expandable can be specified as an existing page name using the page property. Page content Markdown <|Title|expandable|page=page_name|> HTML < taipy:expandable page = \"page_name\" > Title </ taipy:expandable >","title":"Expandable with page"},{"location":"manuals/gui/viselements/expandable/#expandable-with-partial","text":"The content of the expandable can be specified as a Partial^ instance using the partial property. Page content Markdown <|Title|expandable|partial={partial}|> HTML < taipy:expandable partial = \"{partial}\" > Title </ taipy:dialog >","title":"Expandable with partial"},{"location":"manuals/gui/viselements/file_download/","text":"file_download \u00b6 Allows downloading of a file content. The download can be triggered when clicking on a button, or can be performed automatically Properties \u00b6 Name Type Default Description content (\u2605) dynamic(url | path | file) The content of the file. label dynamic(str) The label of the button. on_action Callback The name of a function that is triggered when the download is initiated. All the parameters of that function are optional: state (State^): state instance. id (optional[str]): the identifier of the button. action (optional[str]): the name of the action that provoked the change. auto bool False If True , the download starts as soon as the page is loaded. render dynamic(bool) True If True , the control is displayed. If False , the control is not displayed. bypass_preview bool True If False , allows the browser to try to show the content in a different tab. The file download is always performed. name str A name proposition for the file to save, that the user can change. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) content is the default property for this visual element. Usage \u00b6 Default behavior \u00b6 Allows downloading content when content is a file path or some content Page content Markdown <|{content}|file_download|> HTML < taipy:file_download > {content} </ taipy:file_download > Standard configuration \u00b6 A specific label can be shown beside the standard icon. The function name provided as on_action is called when the user initiates the download. The name provided will be the default name proposed to the user when downloading (depending on browser validation and rules). Page content Markdown <|{content}|file_download|label=Download File|on_action=function_name|name=filename|> HTML < taipy:file_download on_action = \"function_name\" name = \"filename\" > {content} </ taipy:file_download > Preview file in the browser \u00b6 The file content can be visualized in the browser (if supported and in another tab) by specifying bypass_preview as False. Page content Markdown <|{content}|file_download|bypass_preview=False|> HTML < taipy:file_download bypass_preview = \"False\" > {content} </ taipy:file_download > Automatic download \u00b6 The file content can be downloaded automatically (when the page shows and when the content is set). Page content Markdown <|{content}|file_download|auto|> HTML < taipy:file_download auto = \"True\" > {content} </ taipy:file_download >","title":"<tt>file_download</tt>"},{"location":"manuals/gui/viselements/file_download/#file_download","text":"Allows downloading of a file content. The download can be triggered when clicking on a button, or can be performed automatically","title":"file_download"},{"location":"manuals/gui/viselements/file_download/#properties","text":"Name Type Default Description content (\u2605) dynamic(url | path | file) The content of the file. label dynamic(str) The label of the button. on_action Callback The name of a function that is triggered when the download is initiated. All the parameters of that function are optional: state (State^): state instance. id (optional[str]): the identifier of the button. action (optional[str]): the name of the action that provoked the change. auto bool False If True , the download starts as soon as the page is loaded. render dynamic(bool) True If True , the control is displayed. If False , the control is not displayed. bypass_preview bool True If False , allows the browser to try to show the content in a different tab. The file download is always performed. name str A name proposition for the file to save, that the user can change. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) content is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/file_download/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/file_download/#default-behavior","text":"Allows downloading content when content is a file path or some content Page content Markdown <|{content}|file_download|> HTML < taipy:file_download > {content} </ taipy:file_download >","title":"Default behavior"},{"location":"manuals/gui/viselements/file_download/#standard-configuration","text":"A specific label can be shown beside the standard icon. The function name provided as on_action is called when the user initiates the download. The name provided will be the default name proposed to the user when downloading (depending on browser validation and rules). Page content Markdown <|{content}|file_download|label=Download File|on_action=function_name|name=filename|> HTML < taipy:file_download on_action = \"function_name\" name = \"filename\" > {content} </ taipy:file_download >","title":"Standard configuration"},{"location":"manuals/gui/viselements/file_download/#preview-file-in-the-browser","text":"The file content can be visualized in the browser (if supported and in another tab) by specifying bypass_preview as False. Page content Markdown <|{content}|file_download|bypass_preview=False|> HTML < taipy:file_download bypass_preview = \"False\" > {content} </ taipy:file_download >","title":"Preview file in the browser"},{"location":"manuals/gui/viselements/file_download/#automatic-download","text":"The file content can be downloaded automatically (when the page shows and when the content is set). Page content Markdown <|{content}|file_download|auto|> HTML < taipy:file_download auto = \"True\" > {content} </ taipy:file_download >","title":"Automatic download"},{"location":"manuals/gui/viselements/file_selector/","text":"file_selector \u00b6 Allows uploading a file content. The upload can be triggered by pressing a button, or drag-and-dropping a file on top of the control. Properties \u00b6 Name Type Default Description content (\u2605) dynamic(str) The path or the list of paths of the uploaded files. label str The label of the button. on_action Callback The name of the function that will be triggered. All the parameters of that function are optional: state (State^): state instance. id (optional[str]): the identifier of the button. action (optional[str]): the name of the action that provoked the change. multiple bool False If set to True , multiple files can be uploaded. extensions str \".csv,.xlsx\" The list of file extensions that can be uploaded. drop_message str \"Drop here to Upload\" The message that is displayed when the user drags a file above the button. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) content is the default property for this visual element. Usage \u00b6 Default behavior \u00b6 The variable specified in content is populated by a local filename when the transfer is completed. Page content Markdown <|{content}|file_selector|> HTML < taipy:file_selector > {content} </ taipy:file_selector > Standard configuration \u00b6 A specific label can be shown besides the standard icon. The function name provided as on_action is called when the transfer is completed. The extensions property can be used as a list of file name extensions that is used to filter the file selection box. This filter is not enforced: the user can select and upload any file. Upon dragging a file over the button, the drop_message content is displayed as a temporary label for the button. Page content Markdown <|{content}|file_selector|label=Download File|on_action=function_name|extensions=.csv,.xlsx|drop_message=Drop Message|> HTML < taipy:file_selector on_action = \"function_name\" extensions = \".csv,.xlsx\" drop_message = \"Drop Message\" > {content} </ taipy:file_selector > Multiple files upload \u00b6 The user can transfer multiple files at once by setting the multiple property to True. Page content Markdown <|{content}|file_selector|multiple|> HTML < taipy:file_selector multiple = \"True\" > {content} </ taipy:file_selector >","title":"<tt>file_selector</tt>"},{"location":"manuals/gui/viselements/file_selector/#file_selector","text":"Allows uploading a file content. The upload can be triggered by pressing a button, or drag-and-dropping a file on top of the control.","title":"file_selector"},{"location":"manuals/gui/viselements/file_selector/#properties","text":"Name Type Default Description content (\u2605) dynamic(str) The path or the list of paths of the uploaded files. label str The label of the button. on_action Callback The name of the function that will be triggered. All the parameters of that function are optional: state (State^): state instance. id (optional[str]): the identifier of the button. action (optional[str]): the name of the action that provoked the change. multiple bool False If set to True , multiple files can be uploaded. extensions str \".csv,.xlsx\" The list of file extensions that can be uploaded. drop_message str \"Drop here to Upload\" The message that is displayed when the user drags a file above the button. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) content is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/file_selector/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/file_selector/#default-behavior","text":"The variable specified in content is populated by a local filename when the transfer is completed. Page content Markdown <|{content}|file_selector|> HTML < taipy:file_selector > {content} </ taipy:file_selector >","title":"Default behavior"},{"location":"manuals/gui/viselements/file_selector/#standard-configuration","text":"A specific label can be shown besides the standard icon. The function name provided as on_action is called when the transfer is completed. The extensions property can be used as a list of file name extensions that is used to filter the file selection box. This filter is not enforced: the user can select and upload any file. Upon dragging a file over the button, the drop_message content is displayed as a temporary label for the button. Page content Markdown <|{content}|file_selector|label=Download File|on_action=function_name|extensions=.csv,.xlsx|drop_message=Drop Message|> HTML < taipy:file_selector on_action = \"function_name\" extensions = \".csv,.xlsx\" drop_message = \"Drop Message\" > {content} </ taipy:file_selector >","title":"Standard configuration"},{"location":"manuals/gui/viselements/file_selector/#multiple-files-upload","text":"The user can transfer multiple files at once by setting the multiple property to True. Page content Markdown <|{content}|file_selector|multiple|> HTML < taipy:file_selector multiple = \"True\" > {content} </ taipy:file_selector >","title":"Multiple files upload"},{"location":"manuals/gui/viselements/image/","text":"image \u00b6 A control that can display an image. You can indicate a function to be called when the user clicks on the image. Properties \u00b6 Name Type Default Description content (\u2605) dynamic(url | path | file) The image source. label dynamic(str) The label for this image. on_action str The name of a function that is triggered when the user clicks on the image. All the parameters of that function are optional: state (State^): state instance. id (optional[str]): the identifier of the button. action (optional[str]): the name of the action that provoked the change. width str|int|float \"300px\" The width, in CSS units, of this element. height str|int|float The height, in CSS units, of this element. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) content is the default property for this visual element. Usage \u00b6 Default behavior \u00b6 Shows an image specified as a local file path or as raw content. The raw content is generated as a data base64 url if the size of the buffer is lesser than the limit set in the config (data_url_max_size with default value = 50kB). The raw content is written to a temporary file if it's size is greater than the limit. Page content Markdown <|{content}|image|> HTML < taipy:image > {content} </ taipy:image > Call a function on click \u00b6 A specific label can be shown over the image. The function name provided as on_action is called when the image is clicked (same as button). Page content Markdown <|{content}|image|label=this is an image|on_action=function_name|> HTML < taipy:image on_action = \"function_name\" label = \"This is an image\" > {content} </ taipy:image >","title":"<tt>image</tt>"},{"location":"manuals/gui/viselements/image/#image","text":"A control that can display an image. You can indicate a function to be called when the user clicks on the image.","title":"image"},{"location":"manuals/gui/viselements/image/#properties","text":"Name Type Default Description content (\u2605) dynamic(url | path | file) The image source. label dynamic(str) The label for this image. on_action str The name of a function that is triggered when the user clicks on the image. All the parameters of that function are optional: state (State^): state instance. id (optional[str]): the identifier of the button. action (optional[str]): the name of the action that provoked the change. width str|int|float \"300px\" The width, in CSS units, of this element. height str|int|float The height, in CSS units, of this element. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) content is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/image/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/image/#default-behavior","text":"Shows an image specified as a local file path or as raw content. The raw content is generated as a data base64 url if the size of the buffer is lesser than the limit set in the config (data_url_max_size with default value = 50kB). The raw content is written to a temporary file if it's size is greater than the limit. Page content Markdown <|{content}|image|> HTML < taipy:image > {content} </ taipy:image >","title":"Default behavior"},{"location":"manuals/gui/viselements/image/#call-a-function-on-click","text":"A specific label can be shown over the image. The function name provided as on_action is called when the image is clicked (same as button). Page content Markdown <|{content}|image|label=this is an image|on_action=function_name|> HTML < taipy:image on_action = \"function_name\" label = \"This is an image\" > {content} </ taipy:image >","title":"Call a function on click"},{"location":"manuals/gui/viselements/indicator/","text":"indicator \u00b6 Displays a label on a red to green scale at a specific position. The min value can be greater than the max value. The value will be maintained between min and max. Properties \u00b6 Name Type Default Description display (\u2605) dynamic(any) The label to be displayed. This can be formatted if it is a numerical value. value dynamic(int,float) min The location of the label on the [ min , max ] range. min int|float 0 The minimum value of the range. max int|float 100 The maximum value of the range. format str The format to use when displaying the value. This uses the printf syntax. orientation str \"horizontal\" The orientation of this slider. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) display is the default property for this visual element. Usage \u00b6 Minimal usage \u00b6 Shows a message at a specified position between min and max. Page content Markdown <|message|indicator|value={val}|min=0|max=100|> HTML < taipy:indicator value = \"{val}\" min = \"0\" max = \"100\" > message </ taipy:indicator > Formatting the message \u00b6 A format can be applied to the message. Page content Markdown <|{50}|indicator|format=%.2f|value=10|> HTML < taipy:indicator format = \"%.2f\" value = \"10\" > {50} </ taipy:indicator > Vertical indicators \u00b6 The orientation can be specified to \"vertical\" (or \"v\") to create a vertical indicator. Page content Markdown <|{50}|indicator|orientation=v|value=10|> HTML < taipy:indicator orientation = \"vertical\" value = \"10\" > {50} </ taipy:indicator >","title":"<tt>indicator</tt>"},{"location":"manuals/gui/viselements/indicator/#indicator","text":"Displays a label on a red to green scale at a specific position. The min value can be greater than the max value. The value will be maintained between min and max.","title":"indicator"},{"location":"manuals/gui/viselements/indicator/#properties","text":"Name Type Default Description display (\u2605) dynamic(any) The label to be displayed. This can be formatted if it is a numerical value. value dynamic(int,float) min The location of the label on the [ min , max ] range. min int|float 0 The minimum value of the range. max int|float 100 The maximum value of the range. format str The format to use when displaying the value. This uses the printf syntax. orientation str \"horizontal\" The orientation of this slider. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) display is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/indicator/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/indicator/#minimal-usage","text":"Shows a message at a specified position between min and max. Page content Markdown <|message|indicator|value={val}|min=0|max=100|> HTML < taipy:indicator value = \"{val}\" min = \"0\" max = \"100\" > message </ taipy:indicator >","title":"Minimal usage"},{"location":"manuals/gui/viselements/indicator/#formatting-the-message","text":"A format can be applied to the message. Page content Markdown <|{50}|indicator|format=%.2f|value=10|> HTML < taipy:indicator format = \"%.2f\" value = \"10\" > {50} </ taipy:indicator >","title":"Formatting the message"},{"location":"manuals/gui/viselements/indicator/#vertical-indicators","text":"The orientation can be specified to \"vertical\" (or \"v\") to create a vertical indicator. Page content Markdown <|{50}|indicator|orientation=v|value=10|> HTML < taipy:indicator orientation = \"vertical\" value = \"10\" > {50} </ taipy:indicator >","title":"Vertical indicators"},{"location":"manuals/gui/viselements/input/","text":"input \u00b6 A control that displays some text that can potentially be edited. Properties \u00b6 Name Type Default Description value (\u2605) dynamic(any) None The value represented by this control. change_delay int App config Minimum time between triggering two on_change calls. The default value is defined at the application configuration level by the change_delay configuration option. if None, the delay is set to 300ms. on_action Callback Name of a function that is triggered when a specific key is pressed. The parameters of that function are all optional: state (State^): state instance. id (optional[str]): the identifier of the dialog. action (optional[str]): the name of the action that provoked the change. payload args (List): key name variable name current value action_keys str \"Enter\" ;-separated list of supported keys. Authorized values are Enter, Escape, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12 on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. propagate bool App config Allows the control's main value to be automatically propagated. The default value is defined at the application configuration level. If True , any change to the control's value is immediately reflected in the bound application variable. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element. Usage \u00b6 Get user input \u00b6 You can create an input field bound to a variable with the following content: Page content Markdown <|{value}|input|> HTML < taipy:input > {value} </ taipy:input >","title":"<tt>input</tt>"},{"location":"manuals/gui/viselements/input/#input","text":"A control that displays some text that can potentially be edited.","title":"input"},{"location":"manuals/gui/viselements/input/#properties","text":"Name Type Default Description value (\u2605) dynamic(any) None The value represented by this control. change_delay int App config Minimum time between triggering two on_change calls. The default value is defined at the application configuration level by the change_delay configuration option. if None, the delay is set to 300ms. on_action Callback Name of a function that is triggered when a specific key is pressed. The parameters of that function are all optional: state (State^): state instance. id (optional[str]): the identifier of the dialog. action (optional[str]): the name of the action that provoked the change. payload args (List): key name variable name current value action_keys str \"Enter\" ;-separated list of supported keys. Authorized values are Enter, Escape, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12 on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. propagate bool App config Allows the control's main value to be automatically propagated. The default value is defined at the application configuration level. If True , any change to the control's value is immediately reflected in the bound application variable. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/input/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/input/#get-user-input","text":"You can create an input field bound to a variable with the following content: Page content Markdown <|{value}|input|> HTML < taipy:input > {value} </ taipy:input >","title":"Get user input"},{"location":"manuals/gui/viselements/layout/","text":"layout \u00b6 Organizes its children into cells in a regular grid. The columns property follows the css standard . If the columns property contains only digits and spaces, it is considered as flex-factor unit: \"1 1\" => \"1fr 1fr\" Properties \u00b6 Name Type Default Description columns (\u2605) str \"1 1\" The list of weights for each column. For example, `\"1 2\"` creates a 2 column grid: 1fr 2fr columns[mobile] str \"1\" The list of weights for each column, when displayed on a mobile device. The syntax is the same as for columns . gap str \"0.5rem\" The size of the gap between the columns. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) columns is the default property for this visual element. Usage \u00b6 Default layout \u00b6 The default layout contains 2 columns in desktop mode and 1 column in mobile mode. Page content Markdown <|layout| <|{some content}|> |> HTML < taipy:layout > < taipy:text > {some content} </ taipy:text > </ taipy:layout > Specifying gap \u00b6 The gap between adjacent cells is set by default to 0.5rem and can be specified. Page content Markdown <|layout|gap=20px| ... <|{some content}|> ... |> HTML < taipy:layout gap = \"20px\" > ... < taipy:text > {some content} </ taipy:text > > ... </ taipy:layout > Layout with a central \"greedy\" column \u00b6 You can use the fr CSS unit so that the middle column use all the available space. Page content Markdown <|layout|columns=50px 1fr 50px| <|{1st column content}|> <|{2nd column content}|> <|{3rd column content}|> <|{1st column and second row content}|> ... |> HTML < taipy:layout columns = \"50px 1fr 50px\" > < taipy:part > < taipy:text > {1st column content} </ taipy:text > </ taipy:part > < div > < taipy:text > {2nd column content} </ taipy:text > </ div > < taipy:part > < taipy:text > {3rd column content} </ taipy:text > </ taipy:part > < taipy:part > < taipy:text > {1st column and second row content} </ taipy:text > </ taipy:part > ... </ taipy:layout > Different layout for desktop and mobile devices \u00b6 The columns[mobile] property allows to specify a different layout when running on a mobile device. Page content Markdown <|layout|columns=50px 1fr 50px|columns[mobile]=1 1| <|{1st column content}|> <|{2nd column content}|> <|{3rd column content or 2nd row 1st column on mobile}|> <|{1st column and second row content or 2nd row 2nd column on mobile}|> ... |> HTML < taipy:layout columns = \"50px 1fr 50px\" columns [ mobile ]=\" 1 1 \" > < taipy:part > < taipy:text > {1st column content} </ taipy:text > </ taipy:part > < div > < taipy:text > {2nd column content} </ taipy:text > </ div > < taipy:part > < taipy:text > {3rd column content or 2nd row 1st column on mobile} </ taipy:text > </ taipy:part > < taipy:part > < taipy:text > {1st column and second row content or 2nd row 2nd column on mobile} </ taipy:text > </ taipy:part > ... </ taipy:layout >","title":"<tt>layout</tt>"},{"location":"manuals/gui/viselements/layout/#layout","text":"Organizes its children into cells in a regular grid. The columns property follows the css standard . If the columns property contains only digits and spaces, it is considered as flex-factor unit: \"1 1\" => \"1fr 1fr\"","title":"layout"},{"location":"manuals/gui/viselements/layout/#properties","text":"Name Type Default Description columns (\u2605) str \"1 1\" The list of weights for each column. For example, `\"1 2\"` creates a 2 column grid: 1fr 2fr columns[mobile] str \"1\" The list of weights for each column, when displayed on a mobile device. The syntax is the same as for columns . gap str \"0.5rem\" The size of the gap between the columns. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) columns is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/layout/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/layout/#default-layout","text":"The default layout contains 2 columns in desktop mode and 1 column in mobile mode. Page content Markdown <|layout| <|{some content}|> |> HTML < taipy:layout > < taipy:text > {some content} </ taipy:text > </ taipy:layout >","title":"Default layout"},{"location":"manuals/gui/viselements/layout/#specifying-gap","text":"The gap between adjacent cells is set by default to 0.5rem and can be specified. Page content Markdown <|layout|gap=20px| ... <|{some content}|> ... |> HTML < taipy:layout gap = \"20px\" > ... < taipy:text > {some content} </ taipy:text > > ... </ taipy:layout >","title":"Specifying gap"},{"location":"manuals/gui/viselements/layout/#layout-with-a-central-greedy-column","text":"You can use the fr CSS unit so that the middle column use all the available space. Page content Markdown <|layout|columns=50px 1fr 50px| <|{1st column content}|> <|{2nd column content}|> <|{3rd column content}|> <|{1st column and second row content}|> ... |> HTML < taipy:layout columns = \"50px 1fr 50px\" > < taipy:part > < taipy:text > {1st column content} </ taipy:text > </ taipy:part > < div > < taipy:text > {2nd column content} </ taipy:text > </ div > < taipy:part > < taipy:text > {3rd column content} </ taipy:text > </ taipy:part > < taipy:part > < taipy:text > {1st column and second row content} </ taipy:text > </ taipy:part > ... </ taipy:layout >","title":"Layout with a central \"greedy\" column"},{"location":"manuals/gui/viselements/layout/#different-layout-for-desktop-and-mobile-devices","text":"The columns[mobile] property allows to specify a different layout when running on a mobile device. Page content Markdown <|layout|columns=50px 1fr 50px|columns[mobile]=1 1| <|{1st column content}|> <|{2nd column content}|> <|{3rd column content or 2nd row 1st column on mobile}|> <|{1st column and second row content or 2nd row 2nd column on mobile}|> ... |> HTML < taipy:layout columns = \"50px 1fr 50px\" columns [ mobile ]=\" 1 1 \" > < taipy:part > < taipy:text > {1st column content} </ taipy:text > </ taipy:part > < div > < taipy:text > {2nd column content} </ taipy:text > </ div > < taipy:part > < taipy:text > {3rd column content or 2nd row 1st column on mobile} </ taipy:text > </ taipy:part > < taipy:part > < taipy:text > {1st column and second row content or 2nd row 2nd column on mobile} </ taipy:text > </ taipy:part > ... </ taipy:layout >","title":"Different layout for desktop and mobile devices"},{"location":"manuals/gui/viselements/menu/","text":"menu \u00b6 Shows a left-side menu. This control is represented by a unique left-anchor and foldable vertical menu. Properties \u00b6 Name Type Default Description lov (\u2605) dynamic(str|List[str|Icon|any]) The list of menu option values. adapter Function `\"lambda x: str(x)\"` The function that transforms an element of lov into a tuple(id:str, label:str|Icon) . type str Type of first lov element Must be specified if `lov` contains a non specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. label str The title of the menu. width str \"15vw\" The width, in CSS units, of the menu when unfolded. Note that when running on a mobile device, the property width[active] is used instead. width[mobile] str \"85vw\" The width, in CSS units, of the menu when unfolded, on a mobile device. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. on_action Callback The name of the function that will be triggered when a menu option is selected. All the parameters of that function are optional: state (State^): state instance. id (optional[str]): the identifier of the button. action (optional[str]): the name of the action that provoked the change. payload with selected id in args payload args: List where the first element contains the id of the selected option. (\u2605) lov is the default property for this visual element. Usage \u00b6 Defining a simple static menu \u00b6 Page content Markdown <|menu|lov=menu 1;menu 2|> HTML < taipy:menu lov = \"menu 1;menu 2\" ></ taipy:menu > Calling a user-defined function \u00b6 To have the selection of a menu item call a user-defined function, you must set the on_action property to a function that you define: You page can define a menu control like: Page content Markdown <|menu|lov=menu 1;menu 2|on_action=my_menu_action> HTML < taipy:menu lov = \"menu 1;menu 2\" on_action = \"my_menu_action\" ></ taipy:menu > Your Python script must define the my_menu_action function: def my_menu_action(state, ...): ... Disabling menu options \u00b6 The property inactive_ids can be set to dynamically disable any specific menu options. Page content Markdown <|menu|lov=menu 1;menu 2;menu 3|inactive_ids=menu 2;menu 3|> HTML html <taipy:menu lov=\"menu 1;menu 2\" inactive_ids=\"menu 2;menu 3\"></taipy:menu> Adjusting presentation \u00b6 The property label defines the text associated with the main Icon. The properties width and width[mobile] specify the requested width of the menu when expanded. Page content Markdown <|menu|lov=menu 1;menu 2;menu 3|label=Menu title|width=15vw|width[mobile]=80vw|> HTML html <taipy:menu lov=\"menu 1;menu 2\" label=\"Menu title\" width=\"15vw\" width[mobile]=\"80vw\"></taipy:menu> Menu icons \u00b6 As for every control that deals with lov, each menu option can display an image (see Icon^) and/or some text. Page content Markdown <|menu|lov={[(\"id1\", Icon(\"/images/icon.png\", \"Menu option 1\")), (\"id2\", \"Menu option 2\")]}|> HTML html <taipy:menu>{[(\"id1\", Icon(\"/images/icon.png\", \"Menu option 1\")), (\"id2\", \"Menu option 2\")]}</taipy:menu>","title":"<tt>menu</tt>"},{"location":"manuals/gui/viselements/menu/#menu","text":"Shows a left-side menu. This control is represented by a unique left-anchor and foldable vertical menu.","title":"menu"},{"location":"manuals/gui/viselements/menu/#properties","text":"Name Type Default Description lov (\u2605) dynamic(str|List[str|Icon|any]) The list of menu option values. adapter Function `\"lambda x: str(x)\"` The function that transforms an element of lov into a tuple(id:str, label:str|Icon) . type str Type of first lov element Must be specified if `lov` contains a non specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. label str The title of the menu. width str \"15vw\" The width, in CSS units, of the menu when unfolded. Note that when running on a mobile device, the property width[active] is used instead. width[mobile] str \"85vw\" The width, in CSS units, of the menu when unfolded, on a mobile device. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. on_action Callback The name of the function that will be triggered when a menu option is selected. All the parameters of that function are optional: state (State^): state instance. id (optional[str]): the identifier of the button. action (optional[str]): the name of the action that provoked the change. payload with selected id in args payload args: List where the first element contains the id of the selected option. (\u2605) lov is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/menu/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/menu/#defining-a-simple-static-menu","text":"Page content Markdown <|menu|lov=menu 1;menu 2|> HTML < taipy:menu lov = \"menu 1;menu 2\" ></ taipy:menu >","title":"Defining a simple static menu"},{"location":"manuals/gui/viselements/menu/#calling-a-user-defined-function","text":"To have the selection of a menu item call a user-defined function, you must set the on_action property to a function that you define: You page can define a menu control like: Page content Markdown <|menu|lov=menu 1;menu 2|on_action=my_menu_action> HTML < taipy:menu lov = \"menu 1;menu 2\" on_action = \"my_menu_action\" ></ taipy:menu > Your Python script must define the my_menu_action function: def my_menu_action(state, ...): ...","title":"Calling a user-defined function"},{"location":"manuals/gui/viselements/menu/#disabling-menu-options","text":"The property inactive_ids can be set to dynamically disable any specific menu options. Page content Markdown <|menu|lov=menu 1;menu 2;menu 3|inactive_ids=menu 2;menu 3|> HTML html <taipy:menu lov=\"menu 1;menu 2\" inactive_ids=\"menu 2;menu 3\"></taipy:menu>","title":"Disabling menu options"},{"location":"manuals/gui/viselements/menu/#adjusting-presentation","text":"The property label defines the text associated with the main Icon. The properties width and width[mobile] specify the requested width of the menu when expanded. Page content Markdown <|menu|lov=menu 1;menu 2;menu 3|label=Menu title|width=15vw|width[mobile]=80vw|> HTML html <taipy:menu lov=\"menu 1;menu 2\" label=\"Menu title\" width=\"15vw\" width[mobile]=\"80vw\"></taipy:menu>","title":"Adjusting presentation"},{"location":"manuals/gui/viselements/menu/#menu-icons","text":"As for every control that deals with lov, each menu option can display an image (see Icon^) and/or some text. Page content Markdown <|menu|lov={[(\"id1\", Icon(\"/images/icon.png\", \"Menu option 1\")), (\"id2\", \"Menu option 2\")]}|> HTML html <taipy:menu>{[(\"id1\", Icon(\"/images/icon.png\", \"Menu option 1\")), (\"id2\", \"Menu option 2\")]}</taipy:menu>","title":"Menu icons"},{"location":"manuals/gui/viselements/navbar/","text":"navbar \u00b6 A navigation bar control. This control is implemented as a list of links. Properties \u00b6 Name Type Default Description value (\u2605) dynamic(any) Bound to the selection value. lov dict[str, any] The list of values. See [GLOBAL-LOV] for details. adapter Function `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|Icon) . type str Type of first lov element Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. value_by_id bool False If False, the selection value (in value ) is the selected element in lov . If set to True, then value is set to the id of the selected element in lov . on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element. Usage \u00b6 Defining a default navbar \u00b6 The list of all pages registered in the Gui instance is used to build the navbar. Page content Markdown <|navbar|> HTML < taipy:navbar ></ taipy:navbar > Defining a custom navbar \u00b6 The lov property is used to define the list of elements that are displayed. If a lov element id starts whith http, the page is opened in another tab. Page content Markdown <|navbar|lov={[(\"page1\", \"Page 1\"), (\"http://www.google.com\", \"Google\")]}|> HTML < taipy:navbar lov = {[(\"page1\", \" Page 1 \"), (\" http: // www . google . com \", \" Google \")]} ></ taipy:navbar >","title":"<tt>navbar</tt>"},{"location":"manuals/gui/viselements/navbar/#navbar","text":"A navigation bar control. This control is implemented as a list of links.","title":"navbar"},{"location":"manuals/gui/viselements/navbar/#properties","text":"Name Type Default Description value (\u2605) dynamic(any) Bound to the selection value. lov dict[str, any] The list of values. See [GLOBAL-LOV] for details. adapter Function `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|Icon) . type str Type of first lov element Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. value_by_id bool False If False, the selection value (in value ) is the selected element in lov . If set to True, then value is set to the id of the selected element in lov . on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/navbar/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/navbar/#defining-a-default-navbar","text":"The list of all pages registered in the Gui instance is used to build the navbar. Page content Markdown <|navbar|> HTML < taipy:navbar ></ taipy:navbar >","title":"Defining a default navbar"},{"location":"manuals/gui/viselements/navbar/#defining-a-custom-navbar","text":"The lov property is used to define the list of elements that are displayed. If a lov element id starts whith http, the page is opened in another tab. Page content Markdown <|navbar|lov={[(\"page1\", \"Page 1\"), (\"http://www.google.com\", \"Google\")]}|> HTML < taipy:navbar lov = {[(\"page1\", \" Page 1 \"), (\" http: // www . google . com \", \" Google \")]} ></ taipy:navbar >","title":"Defining a custom navbar"},{"location":"manuals/gui/viselements/number/","text":"number \u00b6 A kind of input that handles numbers. Properties \u00b6 Name Type Default Description value (\u2605) dynamic(any) The numerical value represented by this control. change_delay int App config Minimum time between triggering two on_change calls. The default value is defined at the application configuration level by the change_delay configuration option. if None, the delay is set to 300ms. on_action Callback Name of a function that is triggered when a specific key is pressed. The parameters of that function are all optional: state (State^): state instance. id (optional[str]): the identifier of the dialog. action (optional[str]): the name of the action that provoked the change. payload args (List): key name variable name current value action_keys str \"Enter\" ;-separated list of supported keys. Authorized values are Enter, Escape, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12 on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. propagate bool App config Allows the control's main value to be automatically propagated. The default value is defined at the application configuration level. If True , any change to the control's value is immediately reflected in the bound application variable. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element. Usage \u00b6 Simple \u00b6 You can create a number field bound to a numerical variable with the following content: Page content Markdown <|{value}|number|> HTML < taipy:number > {value} </ taipy:number >","title":"<tt>number</tt>"},{"location":"manuals/gui/viselements/number/#number","text":"A kind of input that handles numbers.","title":"number"},{"location":"manuals/gui/viselements/number/#properties","text":"Name Type Default Description value (\u2605) dynamic(any) The numerical value represented by this control. change_delay int App config Minimum time between triggering two on_change calls. The default value is defined at the application configuration level by the change_delay configuration option. if None, the delay is set to 300ms. on_action Callback Name of a function that is triggered when a specific key is pressed. The parameters of that function are all optional: state (State^): state instance. id (optional[str]): the identifier of the dialog. action (optional[str]): the name of the action that provoked the change. payload args (List): key name variable name current value action_keys str \"Enter\" ;-separated list of supported keys. Authorized values are Enter, Escape, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12 on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. propagate bool App config Allows the control's main value to be automatically propagated. The default value is defined at the application configuration level. If True , any change to the control's value is immediately reflected in the bound application variable. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/number/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/number/#simple","text":"You can create a number field bound to a numerical variable with the following content: Page content Markdown <|{value}|number|> HTML < taipy:number > {value} </ taipy:number >","title":"Simple"},{"location":"manuals/gui/viselements/pane/","text":"pane \u00b6 A side pane. Pane allows showing some content on top of the current page. The pane is closed when the user clicks outside the area of the pane (triggering a on_close action). Properties \u00b6 Name Type Default Description open (\u2605) bool False If True , this pane is visible on the page. If False , the pane is hidden. on_close Callback The name of a function that is be triggered when this pane is closed (if the user clicks outside of it or presses the Esc key). All parameters of that function are optional: state (State^): state instance. id (optional[str]): the identifier of the button. action (optional[str]): the name of the action that provoked the change. If this property is not set, no function is called when this pane is closed. partial Partial A Partial object that holds the content of the dialog. This should not be defined if page is set. page str The page name to show as the content of the dialog. This should not be defined if partial is set. anchor str \"left\" Anchor side of the pane. Valid values are \"left\", \"right\", \"top\", or \"bottom\". width str \"30vw\" Width, in CSS units, of this pane. This is used only if anchor is \"left\" or \"right\". height str \"30vh\" Height, in CSS units, of this pane. This is used only if anchor is \"top\" or \"bottom\". persistent bool False If True , the pane appears next to the page. If False , the pane covers the page where it appeared. on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) open is the default property for this visual element. Usage \u00b6 Showing or hiding a pane \u00b6 The default property, open , indicates whether the pane is visible or not: Page content Markdown <|{show}|pane|> HTML < taipy:pane > {show} </ taipy:pane > Choosing where the pane appears \u00b6 The anchor property defines on which side of the display the pane is shown. Page content Markdown <|{show}|pane|anchor=left|> HTML < taipy:pane anchor = \"left\" > {show} </ taipy:pane > Showing the pane beside the page content \u00b6 The pane is shown beside the page content instead of over it if the persistent property evaluates to True. Page content Markdown <|{show}|pane|persistent|> HTML < taipy:pane persistent = \"True\" > {show} </ taipy:pane > Pane as block element \u00b6 The content of the pane can be specified directly inside the pane block. Page content Markdown <|{show}|pane| ... <|{some content}|> ... |> HTML < taipy:pane open = {show} > ... < taipy:text > {some content} </ taipy:text > ... </ taipy:pane > Pane with page \u00b6 The content of the pane can be specified as an existing page name using the page property. Page content Markdown <|{show}|pane|page=page_name|> HTML < taipy:pane page = \"page_name\" > {show} </ taipy:pane > Pane with partial \u00b6 The content of the pane can be specified as a Partial^ instance using the partial property. Page content Markdown <|{show}|pane|partial={partial}|> HTML < taipy:pane partial = \"{partial}\" > {show} </ taipy:pane >","title":"<tt>pane</tt>"},{"location":"manuals/gui/viselements/pane/#pane","text":"A side pane. Pane allows showing some content on top of the current page. The pane is closed when the user clicks outside the area of the pane (triggering a on_close action).","title":"pane"},{"location":"manuals/gui/viselements/pane/#properties","text":"Name Type Default Description open (\u2605) bool False If True , this pane is visible on the page. If False , the pane is hidden. on_close Callback The name of a function that is be triggered when this pane is closed (if the user clicks outside of it or presses the Esc key). All parameters of that function are optional: state (State^): state instance. id (optional[str]): the identifier of the button. action (optional[str]): the name of the action that provoked the change. If this property is not set, no function is called when this pane is closed. partial Partial A Partial object that holds the content of the dialog. This should not be defined if page is set. page str The page name to show as the content of the dialog. This should not be defined if partial is set. anchor str \"left\" Anchor side of the pane. Valid values are \"left\", \"right\", \"top\", or \"bottom\". width str \"30vw\" Width, in CSS units, of this pane. This is used only if anchor is \"left\" or \"right\". height str \"30vh\" Height, in CSS units, of this pane. This is used only if anchor is \"top\" or \"bottom\". persistent bool False If True , the pane appears next to the page. If False , the pane covers the page where it appeared. on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) open is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/pane/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/pane/#showing-or-hiding-a-pane","text":"The default property, open , indicates whether the pane is visible or not: Page content Markdown <|{show}|pane|> HTML < taipy:pane > {show} </ taipy:pane >","title":"Showing or hiding a pane"},{"location":"manuals/gui/viselements/pane/#choosing-where-the-pane-appears","text":"The anchor property defines on which side of the display the pane is shown. Page content Markdown <|{show}|pane|anchor=left|> HTML < taipy:pane anchor = \"left\" > {show} </ taipy:pane >","title":"Choosing where the pane appears"},{"location":"manuals/gui/viselements/pane/#showing-the-pane-beside-the-page-content","text":"The pane is shown beside the page content instead of over it if the persistent property evaluates to True. Page content Markdown <|{show}|pane|persistent|> HTML < taipy:pane persistent = \"True\" > {show} </ taipy:pane >","title":"Showing the pane beside the page content"},{"location":"manuals/gui/viselements/pane/#pane-as-block-element","text":"The content of the pane can be specified directly inside the pane block. Page content Markdown <|{show}|pane| ... <|{some content}|> ... |> HTML < taipy:pane open = {show} > ... < taipy:text > {some content} </ taipy:text > ... </ taipy:pane >","title":"Pane as block element"},{"location":"manuals/gui/viselements/pane/#pane-with-page","text":"The content of the pane can be specified as an existing page name using the page property. Page content Markdown <|{show}|pane|page=page_name|> HTML < taipy:pane page = \"page_name\" > {show} </ taipy:pane >","title":"Pane with page"},{"location":"manuals/gui/viselements/pane/#pane-with-partial","text":"The content of the pane can be specified as a Partial^ instance using the partial property. Page content Markdown <|{show}|pane|partial={partial}|> HTML < taipy:pane partial = \"{partial}\" > {show} </ taipy:pane >","title":"Pane with partial"},{"location":"manuals/gui/viselements/part/","text":"part \u00b6 Displays its children in a block. The part control is used to group controls in a single element. This allows to show or hide them in one action and be placed as a unique element in a Layout cell. There is a simplified Markdown syntax to create a part , where the element name is optional: <| just before the end of the line indicates the beginning of a part element; |> at the beginning of a line indicated the end of the part definition. Properties \u00b6 Name Type Default Description render (\u2605) bool True If True , this part is visible on the page. If False , the part is hidden and all its content is not displayed. partial Partial A Partial object that holds the content of the dialog. This should not be defined if page is set. page str The page name to show as the content of the dialog. This should not be defined if partial is set. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) render is the default property for this visual element. Usage \u00b6 Grouping controls \u00b6 Page content Markdown <| ... <|{Some Content}|> ... |> HTML < taipy:part > ... < taipy:text > {Some Content} </ taipy:text > ... </ taipy:part > Showing and hiding controls \u00b6 Page content Markdown <|part|don't render| ... <|{Some Content}|> ... |> HTML < taipy:part render = \"False\" > ... < taipy:text > {Some Content} </ taipy:text > ... </ taipy:part > If the render property is bound to a Boolean value, the part will show or hide its elements according to the value of the bound variable. Part with page \u00b6 The content of the part can be specified as an existing page name using the page property. Page content Markdown <|part|page=page_name|> HTML < taipy:part page = \"page_name\" /> Part with partial \u00b6 The content of the part can be specified as a Partial^ instance using the partial property. Page content Markdown <|part|partial={partial}|> HTML < taipy:part partial = \"{partial}\" />","title":"<tt>part</tt>"},{"location":"manuals/gui/viselements/part/#part","text":"Displays its children in a block. The part control is used to group controls in a single element. This allows to show or hide them in one action and be placed as a unique element in a Layout cell. There is a simplified Markdown syntax to create a part , where the element name is optional: <| just before the end of the line indicates the beginning of a part element; |> at the beginning of a line indicated the end of the part definition.","title":"part"},{"location":"manuals/gui/viselements/part/#properties","text":"Name Type Default Description render (\u2605) bool True If True , this part is visible on the page. If False , the part is hidden and all its content is not displayed. partial Partial A Partial object that holds the content of the dialog. This should not be defined if page is set. page str The page name to show as the content of the dialog. This should not be defined if partial is set. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) render is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/part/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/part/#grouping-controls","text":"Page content Markdown <| ... <|{Some Content}|> ... |> HTML < taipy:part > ... < taipy:text > {Some Content} </ taipy:text > ... </ taipy:part >","title":"Grouping controls"},{"location":"manuals/gui/viselements/part/#showing-and-hiding-controls","text":"Page content Markdown <|part|don't render| ... <|{Some Content}|> ... |> HTML < taipy:part render = \"False\" > ... < taipy:text > {Some Content} </ taipy:text > ... </ taipy:part > If the render property is bound to a Boolean value, the part will show or hide its elements according to the value of the bound variable.","title":"Showing and hiding controls"},{"location":"manuals/gui/viselements/part/#part-with-page","text":"The content of the part can be specified as an existing page name using the page property. Page content Markdown <|part|page=page_name|> HTML < taipy:part page = \"page_name\" />","title":"Part with page"},{"location":"manuals/gui/viselements/part/#part-with-partial","text":"The content of the part can be specified as a Partial^ instance using the partial property. Page content Markdown <|part|partial={partial}|> HTML < taipy:part partial = \"{partial}\" />","title":"Part with partial"},{"location":"manuals/gui/viselements/selector/","text":"selector \u00b6 A control that allows for selecting items from a list of choices. Each item is represented by a string, an image or both. The selector can let the user select multiple items. A filtering feature is available to display only a subset of the items. You can use an arbitrary type for all the items (see the example ). Properties \u00b6 Name Type Default Description filter bool False If True , this control is combined with a filter input area. multiple bool False If True , the user can select multiple items. width str|int \"360px\" The width, in CSS units, of this element. height str|int The height, in CSS units, of this element. dropdown bool False If True , the list of items is shown in a dropdown menu. You cannot use the filter in that situation. value (\u2605) dynamic(any) Bound to the selection value. lov dict[str, any] The list of values. See [GLOBAL-LOV] for details. adapter Function `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|Icon) . type str Type of first lov element Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. value_by_id bool False If False, the selection value (in value ) is the selected element in lov . If set to True, then value is set to the id of the selected element in lov . on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. propagate bool App config Allows the control's main value to be automatically propagated. The default value is defined at the application configuration level. If True , any change to the control's value is immediately reflected in the bound application variable. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element. Usage \u00b6 Display a list of string \u00b6 You can create a selector on a series of strings: Page content Markdown <|{value}|selector|lov=Item 1;Item 2;Item 3|> HTML < taipy:selector lov = \"Item 1;Item 2;Item 3\" > {value} </ taipy:selector > Display as a dropdown \u00b6 Page content Markdown <|{value}|selector|lov=Item 1;Item 2;Item 3|dropdown|> HTML < taipy:selector lov = \"Item 1;Item 2;Item 3\" dropdown = \"True\" > {value} </ taipy:selector > Display with filter and multiple selection \u00b6 You can add a filter input field that lets you display only strings that match the filter value. Page content Markdown <|{value}|selector|lov=Item 1;Item 2;Item 3|multiple|filter|> HTML < taipy:selector lov = \"Item 1;Item 2;Item 3\" multiple = \"True\" filter = \"True\" > {value} </ taipy:selector > Display a list of tuples \u00b6 A selector control that returns an id while selecting a label or Icon^ . Page content Markdown <|{sel}|selector|lov={[(\"id1\", \"Label 1\"), (\"id2\", Icon(\"/images/icon.png\", \"Label 2\"),(\"id3\", \"Label 3\")]}|> HTML < taipy:selector value = \"{sel}\" lov = \"{[('id1', 'Label 1'), ('id2', Icon('/images/icon.png', 'Label 2'),('id3', 'Label 3')]}\" /> Display a list of objects \u00b6 Assuming your Python code has created a list of object: class User : def __init__ ( self , id , name , birth_year ): self . id , self . name , self . birth_year = ( id , name , birth_year ) users = [ User ( 231 , \"Johanna\" , 1987 ), User ( 125 , \"John\" , 1979 ), User ( 4 , \"Peter\" , 1968 ), User ( 31 , \"Mary\" , 1974 ) ] user_sel = users [ 2 ] If you want to create a selector control that lets you pick a specific user, you can use the following fragment. Page content Markdown <|{user_sel}|selector|lov={users}|type=User|adapter={lambda u: (u.id, u.name)}|> HTML < taipy:selector lov = \"{users}\" type = \"User\" adapter = \"{lambda u: (u.id, u.name)}\" > {user_sel} </ taipy:selector > In this example, we are using the Python list users as the selector's list of values . Because the control needs a way to convert the list items (which are instances of the class User ) into a string that can be displayed, we are using an adapter : a function that converts an object, whose type must be provided to the type property, to a tuple. The first element of the tuple is used to reference the selection (therefore those elements should be unique among all the items) and the second element is the string that turns out to be displayed.","title":"<tt>selector</tt>"},{"location":"manuals/gui/viselements/selector/#selector","text":"A control that allows for selecting items from a list of choices. Each item is represented by a string, an image or both. The selector can let the user select multiple items. A filtering feature is available to display only a subset of the items. You can use an arbitrary type for all the items (see the example ).","title":"selector"},{"location":"manuals/gui/viselements/selector/#properties","text":"Name Type Default Description filter bool False If True , this control is combined with a filter input area. multiple bool False If True , the user can select multiple items. width str|int \"360px\" The width, in CSS units, of this element. height str|int The height, in CSS units, of this element. dropdown bool False If True , the list of items is shown in a dropdown menu. You cannot use the filter in that situation. value (\u2605) dynamic(any) Bound to the selection value. lov dict[str, any] The list of values. See [GLOBAL-LOV] for details. adapter Function `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|Icon) . type str Type of first lov element Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. value_by_id bool False If False, the selection value (in value ) is the selected element in lov . If set to True, then value is set to the id of the selected element in lov . on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. propagate bool App config Allows the control's main value to be automatically propagated. The default value is defined at the application configuration level. If True , any change to the control's value is immediately reflected in the bound application variable. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/selector/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/selector/#display-a-list-of-string","text":"You can create a selector on a series of strings: Page content Markdown <|{value}|selector|lov=Item 1;Item 2;Item 3|> HTML < taipy:selector lov = \"Item 1;Item 2;Item 3\" > {value} </ taipy:selector >","title":"Display a list of string"},{"location":"manuals/gui/viselements/selector/#display-as-a-dropdown","text":"Page content Markdown <|{value}|selector|lov=Item 1;Item 2;Item 3|dropdown|> HTML < taipy:selector lov = \"Item 1;Item 2;Item 3\" dropdown = \"True\" > {value} </ taipy:selector >","title":"Display as a dropdown"},{"location":"manuals/gui/viselements/selector/#display-with-filter-and-multiple-selection","text":"You can add a filter input field that lets you display only strings that match the filter value. Page content Markdown <|{value}|selector|lov=Item 1;Item 2;Item 3|multiple|filter|> HTML < taipy:selector lov = \"Item 1;Item 2;Item 3\" multiple = \"True\" filter = \"True\" > {value} </ taipy:selector >","title":"Display with filter and multiple selection"},{"location":"manuals/gui/viselements/selector/#display-a-list-of-tuples","text":"A selector control that returns an id while selecting a label or Icon^ . Page content Markdown <|{sel}|selector|lov={[(\"id1\", \"Label 1\"), (\"id2\", Icon(\"/images/icon.png\", \"Label 2\"),(\"id3\", \"Label 3\")]}|> HTML < taipy:selector value = \"{sel}\" lov = \"{[('id1', 'Label 1'), ('id2', Icon('/images/icon.png', 'Label 2'),('id3', 'Label 3')]}\" />","title":"Display a list of tuples"},{"location":"manuals/gui/viselements/selector/#display-a-list-of-objects","text":"Assuming your Python code has created a list of object: class User : def __init__ ( self , id , name , birth_year ): self . id , self . name , self . birth_year = ( id , name , birth_year ) users = [ User ( 231 , \"Johanna\" , 1987 ), User ( 125 , \"John\" , 1979 ), User ( 4 , \"Peter\" , 1968 ), User ( 31 , \"Mary\" , 1974 ) ] user_sel = users [ 2 ] If you want to create a selector control that lets you pick a specific user, you can use the following fragment. Page content Markdown <|{user_sel}|selector|lov={users}|type=User|adapter={lambda u: (u.id, u.name)}|> HTML < taipy:selector lov = \"{users}\" type = \"User\" adapter = \"{lambda u: (u.id, u.name)}\" > {user_sel} </ taipy:selector > In this example, we are using the Python list users as the selector's list of values . Because the control needs a way to convert the list items (which are instances of the class User ) into a string that can be displayed, we are using an adapter : a function that converts an object, whose type must be provided to the type property, to a tuple. The first element of the tuple is used to reference the selection (therefore those elements should be unique among all the items) and the second element is the string that turns out to be displayed.","title":"Display a list of objects"},{"location":"manuals/gui/viselements/slider/","text":"slider \u00b6 Displays and allows the user to set a value within a range. The range is set by the values min and max which must be integer values. If the lov property is used, then the slider can be used to select a value among the different choices. Properties \u00b6 Name Type Default Description value (\u2605) dynamic(int | float | str) The value that is set for this slider. It would be a lov label if it is used. min int|float 0 The minimum value. This is ignored when lov is defined. max int|float 100 The maximum value. This is ignored when lov is defined. text_anchor str \"bottom\" When the lov property is used, this property indicates the location of the label. Possible values are: bottom top left right none (no label is displayed) labels bool|dict The labels for specific points of the slider. If set to True, this slider uses the labels of the lov if there are any. If set to a dictionary, the slider uses the dictionary keys as a lov key or index, and the associated value as the label. continuous bool True If set to False, the control emits an on_change notification only when the mouse button is released, otherwise notifications are emitted during the cursor movements. If lov is defined, the default value is False. change_delay int App config Minimum time between triggering two on_change calls. The default value is defined at the application configuration level by the change_delay configuration option. if None or 0, there's no delay. width str \"300px\" The width, in CSS units, of this element. height str The height, in CSS units, of this element. It defaults to the width value when using the vertical orientation. orientation str \"horizontal\" The orientation of this slider. Valid values are \"horizontal\" or \"vertical\". lov dict[str, any] The list of values. See [GLOBAL-LOV] for details. adapter Function `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|Icon) . type str Type of first lov element Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. value_by_id bool False If False, the selection value (in value ) is the selected element in lov . If set to True, then value is set to the id of the selected element in lov . on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. propagate bool App config Allows the control's main value to be automatically propagated. The default value is defined at the application configuration level. If True , any change to the control's value is immediately reflected in the bound application variable. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element. Usage \u00b6 Selecting a value between 0 and 100 \u00b6 A numeric value can easily be represented and interacted with using the following content: Page content Markdown <|{value}|slider|> HTML < taipy:slider > {value} </ taipy:slider > Constraining values \u00b6 You can specify what bounds the value should be restrained to: Page content Markdown <|{value}|slider|min=1|max=10|> HTML < taipy:slider min = \"1\" max = \"10\" > {value} </ taipy:slider > Changing orientation \u00b6 Page content Markdown <|{value}|slider|orientation=vert|> HTML < taipy:slider orientation = \"vertical\" > {value} </ taipy:slider >","title":"<tt>slider</tt>"},{"location":"manuals/gui/viselements/slider/#slider","text":"Displays and allows the user to set a value within a range. The range is set by the values min and max which must be integer values. If the lov property is used, then the slider can be used to select a value among the different choices.","title":"slider"},{"location":"manuals/gui/viselements/slider/#properties","text":"Name Type Default Description value (\u2605) dynamic(int | float | str) The value that is set for this slider. It would be a lov label if it is used. min int|float 0 The minimum value. This is ignored when lov is defined. max int|float 100 The maximum value. This is ignored when lov is defined. text_anchor str \"bottom\" When the lov property is used, this property indicates the location of the label. Possible values are: bottom top left right none (no label is displayed) labels bool|dict The labels for specific points of the slider. If set to True, this slider uses the labels of the lov if there are any. If set to a dictionary, the slider uses the dictionary keys as a lov key or index, and the associated value as the label. continuous bool True If set to False, the control emits an on_change notification only when the mouse button is released, otherwise notifications are emitted during the cursor movements. If lov is defined, the default value is False. change_delay int App config Minimum time between triggering two on_change calls. The default value is defined at the application configuration level by the change_delay configuration option. if None or 0, there's no delay. width str \"300px\" The width, in CSS units, of this element. height str The height, in CSS units, of this element. It defaults to the width value when using the vertical orientation. orientation str \"horizontal\" The orientation of this slider. Valid values are \"horizontal\" or \"vertical\". lov dict[str, any] The list of values. See [GLOBAL-LOV] for details. adapter Function `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|Icon) . type str Type of first lov element Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. value_by_id bool False If False, the selection value (in value ) is the selected element in lov . If set to True, then value is set to the id of the selected element in lov . on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. propagate bool App config Allows the control's main value to be automatically propagated. The default value is defined at the application configuration level. If True , any change to the control's value is immediately reflected in the bound application variable. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/slider/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/slider/#selecting-a-value-between-0-and-100","text":"A numeric value can easily be represented and interacted with using the following content: Page content Markdown <|{value}|slider|> HTML < taipy:slider > {value} </ taipy:slider >","title":"Selecting a value between 0 and 100"},{"location":"manuals/gui/viselements/slider/#constraining-values","text":"You can specify what bounds the value should be restrained to: Page content Markdown <|{value}|slider|min=1|max=10|> HTML < taipy:slider min = \"1\" max = \"10\" > {value} </ taipy:slider >","title":"Constraining values"},{"location":"manuals/gui/viselements/slider/#changing-orientation","text":"Page content Markdown <|{value}|slider|orientation=vert|> HTML < taipy:slider orientation = \"vertical\" > {value} </ taipy:slider >","title":"Changing orientation"},{"location":"manuals/gui/viselements/status/","text":"status \u00b6 Displays a status or a list of statuses. Properties \u00b6 Name Type Default Description value (\u2605) dict|list[dict]|tuple|list[tuple] The different statuses to represent. See below. without_close bool False If True , the user cannot hide the child statuses. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element. Usage \u00b6 value can be a list of tuples: first element: status second element: message or a list of dictionaries that contain the keys: status message Show the current status \u00b6 Page content Markdown <|{value}|status|> HTML < taipy:status > {value} </ taipy:status > Prevent status dismiss \u00b6 If you don't want the user to be allowed to dismiss the displayed statuses, you can use the without_close property. Page content Markdown <|{value}|status|without_close|> HTML < taipy:status without_close = \"True\" > {value} </ taipy:status >","title":"<tt>status</tt>"},{"location":"manuals/gui/viselements/status/#status","text":"Displays a status or a list of statuses.","title":"status"},{"location":"manuals/gui/viselements/status/#properties","text":"Name Type Default Description value (\u2605) dict|list[dict]|tuple|list[tuple] The different statuses to represent. See below. without_close bool False If True , the user cannot hide the child statuses. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/status/#usage","text":"value can be a list of tuples: first element: status second element: message or a list of dictionaries that contain the keys: status message","title":"Usage"},{"location":"manuals/gui/viselements/status/#show-the-current-status","text":"Page content Markdown <|{value}|status|> HTML < taipy:status > {value} </ taipy:status >","title":"Show the current status"},{"location":"manuals/gui/viselements/status/#prevent-status-dismiss","text":"If you don't want the user to be allowed to dismiss the displayed statuses, you can use the without_close property. Page content Markdown <|{value}|status|without_close|> HTML < taipy:status without_close = \"True\" > {value} </ taipy:status >","title":"Prevent status dismiss"},{"location":"manuals/gui/viselements/table/","text":"table \u00b6 Displays a data set as tabular data. The table component supports 3 display modes: paginated : you can choose the page size and page size options ( allow_all_rows adds an option to show a page with all rows). unpaginated : all rows and no page are shown ( show_all = True ). auto_loading : the pages are loaded on demand depending on the visible area. The data property supported types are: pandas Dataframe array of arrays numpy series Data columns are accessed by their name or index (temporary dataframes are built from these different sources). Properties \u00b6 Name Type Default Description data (\u2605) any The data to be represented in this table. page_size int 100 For paginated table, the number of rows displayed. allow_all_rows bool False For paginated table, adds an option to show all rows. show_all bool False For paginated table, show all rows. auto_loading bool False data will be loaded on demand. width[ col_name ] str The width, in CSS units, of the indicated column. selected list[int]|str The list of the indices of the rows to show as selected. page_size_options List[int]|str [50, 100, 500] The list of available page sizes that users can choose. columns str|List[str]|Dict[str, Dict[str, str|int]] shows all columns when empty The list of the column names. str: ;-separated list of column names. List[str] dict: {\"col name\": {format: \"format\", index: 1}} if index is specified, it represents the display order of the columns. If index is not specified, the list order defines the index.if format is specified, it is used for numbers or dates. date_format str \"MM/dd/yyyy\" The date format that is used for all date columns when format is not specifically defined. number_format str The number format that is used for all number columns when format is not specifically defined. group_by[ col_name ] bool False Indicates, if True , that the given column can be aggregated. See [below](#aggregation) for details. apply[ col_name ] str \"first\" The name of the aggregation function to use. This is used only if group_by[column_name] is set to True . See [below](#aggregation) for details. style str Allows the styling of table lines. See [below](#styling) for details. style[ col_name ] str Allows the styling of table cells. See [below](#styling) for details. width str|int|float \"100vw\" The width, in CSS units, of this table control. height str|int|float \"80vh\" The height, in CSS units, of this table control. nan_value str \"\" The replacement text for NaN (not-a-number) values. nan_value[ col_name ] str \"\" The replacement text for NaN (not-a-number) values for the indicated column. on_edit Callback The name of a function that is to be triggered when a cell edition is validated. All parameters of that function are optional: state (State^): state instance. var_name (str): the name of the tabular data variable. action (str): the name of the action that provoked the change. payload index (int): row Index. col (str): column name. value (any): the new value. If this property is not set, the user cannot edit cells. on_delete str The name of a function that is to be triggered when a row is deleted. All parameters of that function are optional: state (State^): state instance. var_name (str): the name of the tabular data variable. action (str): the name of the action that provoked the change. payload index (int): row Index. If this property is not set, the user cannot delete rows. on_add str The name of a function that is to be triggered when the user requests a row to be added. All parameters of that function are optional: state (State^): state instance. var_name (str): the name of the tabular data variable. action (str): the name of the action that provoked the change. payload index (int): row Index. If this property is not set, the user cannot add rows. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) data is the default property for this visual element. Usage \u00b6 Show a table \u00b6 If you want to create a table that represents a dataframe stored in the Python variable data (all columns will be displayed), you can use the following content: Page content Markdown <{data}|table|> HTML < taipy:table data = \"{data}\" /> show specific clomuns \u00b6 Page content Markdown <|{data}|table|columns=Col 1;Col 2;Col 3|page_size=10|page_size_options=10;30;100|date_format=eee dd MMM yyyy|not allow_all_rows|show_all=No|auto_loading=False|width=100vw|height=100vw|selected={selection}|> HTML < taipy:table columns = \"Col 1;Col 2;Col 3\" page_size = \"10\" page_size_options = \"10;30;100\" date_format = \"eee dd MMM yyyy\" allow_all_rows = \"False\" show_all = \"False\" auto_loading = \"False\" width = \"100vw\" height = \"100vw\" selected = \"{selection}\" > {data} </ taipy:table > Aggregation \u00b6 To get the aggregation functionality in your table, you must indicate which columns can be aggregated, and how to perform the aggregation. This is done using the group_by and apply properties. The group_by[column_name] property, when set to True indicates that the column column_name can be aggregated. The function provided in the apply[column_name] property indicates how to perform this aggregation. The value of this property, which is a string, can be: A built-in function. Available predefined functions are the following: count , sum , mean , median , min , max , std , first (the default value), and last . The name of a user-defined function, or a lambda function. This function receives a single parameter which is the series to aggregate, and it must return a scalar value which would be the result of the aggregation. Page content Markdown <{data}|table|group_by[Group column]|apply[Apply column]=count|> HTML < taipy:table data = \"{data}\" group_by [ Group column ]=\" True \" apply [ Apply column ]=\" count \" /> Styling \u00b6 You can modify the style of entire rows or specific table cells. When Taipy creates the rows and the cells, it can add a specific CSS class that you would have set as the return value of the function set to the style property, for entire rows, or style[_column_name_] , for specific cells. The signature of this function depends on which style property you use: style : this applies to entire rows. The given function expects three parameters: state : the current state index : the index of the row in this table row (optional): all the values for this row style[_column_name_] : this applies to a specific cell. The given function expects four parameters: state : the current state value : the value of the cell index (optional): the index of the row of this cell column_name (optional): the name of the column for this cell Based on these parameters, the function must return a string that defines a CSS class name that will be added to the CSS classes for this table row or this specific cell. You can then add the definition of this class in your CSS file. Page content Markdown <{data}|table|style={lambda state, idx, row: \"red-row\" if idx % 2 == 0 else \"blue-row\"}|> HTML < taipy:table data = \"{data}\" style = \"{lambda state, idx, row: 'red-row' if idx % 2 == 0 else 'blue-row'}\" /> Css definition . red-row td { background-color : red ; } . blue-row td { background-color : blue ; }","title":"<tt>table</tt>"},{"location":"manuals/gui/viselements/table/#table","text":"Displays a data set as tabular data. The table component supports 3 display modes: paginated : you can choose the page size and page size options ( allow_all_rows adds an option to show a page with all rows). unpaginated : all rows and no page are shown ( show_all = True ). auto_loading : the pages are loaded on demand depending on the visible area. The data property supported types are: pandas Dataframe array of arrays numpy series Data columns are accessed by their name or index (temporary dataframes are built from these different sources).","title":"table"},{"location":"manuals/gui/viselements/table/#properties","text":"Name Type Default Description data (\u2605) any The data to be represented in this table. page_size int 100 For paginated table, the number of rows displayed. allow_all_rows bool False For paginated table, adds an option to show all rows. show_all bool False For paginated table, show all rows. auto_loading bool False data will be loaded on demand. width[ col_name ] str The width, in CSS units, of the indicated column. selected list[int]|str The list of the indices of the rows to show as selected. page_size_options List[int]|str [50, 100, 500] The list of available page sizes that users can choose. columns str|List[str]|Dict[str, Dict[str, str|int]] shows all columns when empty The list of the column names. str: ;-separated list of column names. List[str] dict: {\"col name\": {format: \"format\", index: 1}} if index is specified, it represents the display order of the columns. If index is not specified, the list order defines the index.if format is specified, it is used for numbers or dates. date_format str \"MM/dd/yyyy\" The date format that is used for all date columns when format is not specifically defined. number_format str The number format that is used for all number columns when format is not specifically defined. group_by[ col_name ] bool False Indicates, if True , that the given column can be aggregated. See [below](#aggregation) for details. apply[ col_name ] str \"first\" The name of the aggregation function to use. This is used only if group_by[column_name] is set to True . See [below](#aggregation) for details. style str Allows the styling of table lines. See [below](#styling) for details. style[ col_name ] str Allows the styling of table cells. See [below](#styling) for details. width str|int|float \"100vw\" The width, in CSS units, of this table control. height str|int|float \"80vh\" The height, in CSS units, of this table control. nan_value str \"\" The replacement text for NaN (not-a-number) values. nan_value[ col_name ] str \"\" The replacement text for NaN (not-a-number) values for the indicated column. on_edit Callback The name of a function that is to be triggered when a cell edition is validated. All parameters of that function are optional: state (State^): state instance. var_name (str): the name of the tabular data variable. action (str): the name of the action that provoked the change. payload index (int): row Index. col (str): column name. value (any): the new value. If this property is not set, the user cannot edit cells. on_delete str The name of a function that is to be triggered when a row is deleted. All parameters of that function are optional: state (State^): state instance. var_name (str): the name of the tabular data variable. action (str): the name of the action that provoked the change. payload index (int): row Index. If this property is not set, the user cannot delete rows. on_add str The name of a function that is to be triggered when the user requests a row to be added. All parameters of that function are optional: state (State^): state instance. var_name (str): the name of the tabular data variable. action (str): the name of the action that provoked the change. payload index (int): row Index. If this property is not set, the user cannot add rows. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) data is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/table/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/table/#show-a-table","text":"If you want to create a table that represents a dataframe stored in the Python variable data (all columns will be displayed), you can use the following content: Page content Markdown <{data}|table|> HTML < taipy:table data = \"{data}\" />","title":"Show a table"},{"location":"manuals/gui/viselements/table/#show-specific-clomuns","text":"Page content Markdown <|{data}|table|columns=Col 1;Col 2;Col 3|page_size=10|page_size_options=10;30;100|date_format=eee dd MMM yyyy|not allow_all_rows|show_all=No|auto_loading=False|width=100vw|height=100vw|selected={selection}|> HTML < taipy:table columns = \"Col 1;Col 2;Col 3\" page_size = \"10\" page_size_options = \"10;30;100\" date_format = \"eee dd MMM yyyy\" allow_all_rows = \"False\" show_all = \"False\" auto_loading = \"False\" width = \"100vw\" height = \"100vw\" selected = \"{selection}\" > {data} </ taipy:table >","title":"show specific clomuns"},{"location":"manuals/gui/viselements/table/#aggregation","text":"To get the aggregation functionality in your table, you must indicate which columns can be aggregated, and how to perform the aggregation. This is done using the group_by and apply properties. The group_by[column_name] property, when set to True indicates that the column column_name can be aggregated. The function provided in the apply[column_name] property indicates how to perform this aggregation. The value of this property, which is a string, can be: A built-in function. Available predefined functions are the following: count , sum , mean , median , min , max , std , first (the default value), and last . The name of a user-defined function, or a lambda function. This function receives a single parameter which is the series to aggregate, and it must return a scalar value which would be the result of the aggregation. Page content Markdown <{data}|table|group_by[Group column]|apply[Apply column]=count|> HTML < taipy:table data = \"{data}\" group_by [ Group column ]=\" True \" apply [ Apply column ]=\" count \" />","title":"Aggregation"},{"location":"manuals/gui/viselements/table/#styling","text":"You can modify the style of entire rows or specific table cells. When Taipy creates the rows and the cells, it can add a specific CSS class that you would have set as the return value of the function set to the style property, for entire rows, or style[_column_name_] , for specific cells. The signature of this function depends on which style property you use: style : this applies to entire rows. The given function expects three parameters: state : the current state index : the index of the row in this table row (optional): all the values for this row style[_column_name_] : this applies to a specific cell. The given function expects four parameters: state : the current state value : the value of the cell index (optional): the index of the row of this cell column_name (optional): the name of the column for this cell Based on these parameters, the function must return a string that defines a CSS class name that will be added to the CSS classes for this table row or this specific cell. You can then add the definition of this class in your CSS file. Page content Markdown <{data}|table|style={lambda state, idx, row: \"red-row\" if idx % 2 == 0 else \"blue-row\"}|> HTML < taipy:table data = \"{data}\" style = \"{lambda state, idx, row: 'red-row' if idx % 2 == 0 else 'blue-row'}\" /> Css definition . red-row td { background-color : red ; } . blue-row td { background-color : blue ; }","title":"Styling"},{"location":"manuals/gui/viselements/text/","text":"text \u00b6 Displays a value as a static text. Note that in order to create a text control, you don't need to specify the control name in the text template. See the documentation for Controls for more details. Properties \u00b6 Name Type Default Description value (\u2605) dynamic(Any) \"\" The value displayed as text by this control. format str The format to apply to the value. See below. on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element. Details \u00b6 The format property uses a format string like the ones used by the string format() function of Python. If the value is a date or a datetime , then format can be set to a date/time formatting string. Usage \u00b6 Display value \u00b6 You can represent a variable value as a simple, static text: Page content Markdown <|{value}|> HTML < taipy:text > {value} </ taipy:text > Formatted output \u00b6 If your value is a floating point value, you can use the format property to indicate what the output format should be used. To display a floating point value with two decimal places: Page content Markdown <|{value}|text|format=%.2f|> HTML < taipy:text format = \"%.2f\" > {value} </ taipy:text >","title":"<tt>text</tt>"},{"location":"manuals/gui/viselements/text/#text","text":"Displays a value as a static text. Note that in order to create a text control, you don't need to specify the control name in the text template. See the documentation for Controls for more details.","title":"text"},{"location":"manuals/gui/viselements/text/#properties","text":"Name Type Default Description value (\u2605) dynamic(Any) \"\" The value displayed as text by this control. format str The format to apply to the value. See below. on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/text/#details","text":"The format property uses a format string like the ones used by the string format() function of Python. If the value is a date or a datetime , then format can be set to a date/time formatting string.","title":"Details"},{"location":"manuals/gui/viselements/text/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/text/#display-value","text":"You can represent a variable value as a simple, static text: Page content Markdown <|{value}|> HTML < taipy:text > {value} </ taipy:text >","title":"Display value"},{"location":"manuals/gui/viselements/text/#formatted-output","text":"If your value is a floating point value, you can use the format property to indicate what the output format should be used. To display a floating point value with two decimal places: Page content Markdown <|{value}|text|format=%.2f|> HTML < taipy:text format = \"%.2f\" > {value} </ taipy:text >","title":"Formatted output"},{"location":"manuals/gui/viselements/toggle/","text":"toggle \u00b6 A series of toggle buttons that the user can select. Properties \u00b6 Name Type Default Description value (\u2605) dynamic(any) Bound to the selection value. theme bool False If set, this toggle control acts as a way to set the application Theme (dark or light). lov dict[str, any] The list of values. See [GLOBAL-LOV] for details. adapter Function `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|Icon) . type str Type of first lov element Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. value_by_id bool False If False, the selection value (in value ) is the selected element in lov . If set to True, then value is set to the id of the selected element in lov . on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. propagate bool App config Allows the control's main value to be automatically propagated. The default value is defined at the application configuration level. If True , any change to the control's value is immediately reflected in the bound application variable. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element. Details \u00b6 Each button is represented by a string, an image or both. You can use an arbitrary type for all the items (see the example ). Usage \u00b6 Display a list of string \u00b6 You can create a list of toggle buttons from a series of strings: Page content Markdown <|{value}|toggle|lov=Item 1;Item 2;Item 3|> HTML < taipy:toggle lov = \"Item 1;Item 2;Item 3\" > {value} </ taipy:toggle > Unselect value \u00b6 In a toggle control, all buttons might be unselected. Therefore there is no value selected. In that case, the value of the property unselected_value is assigned if specified. Page content Markdown <|{value}|toggle|lov=Item 1;Item 2;Item 3|unselected_value=No Value|> HTML < taipy:toggle lov = \"Item 1;Item 2;Item 3\" unselected_value = \"No Value\" > {value} </ taipy:toggle > Display a list of tuples \u00b6 A toggle control that returns an id while selecting a label or Icon^ . Page content Markdown <|{sel}|toggle|lov={[(\"id1\", \"Label 1\"), (\"id2\", Icon(\"/images/icon.png\", \"Label 2\"),(\"id3\", \"Label 3\")]}|> HTML < taipy:toggle value = \"{sel}\" lov = \"{[('id1', 'Label 1'), ('id2', Icon('/images/icon.png', 'Label 2'),('id3', 'Label 3')]}\" /> Use arbitrary objects \u00b6 Assuming your Python code has created a list of objects: class User : def __init__ ( self , id , name , birth_year ): self . id , self . name , self . birth_year = ( id , name , birth_year ) users = [ User ( 231 , \"Johanna\" , 1987 ), User ( 125 , \"John\" , 1979 ), User ( 4 , \"Peter\" , 1968 ), User ( 31 , \"Mary\" , 1974 ) ] user_sel = users [ 2 ] If you want to create a toggle control that lets you pick a specific user, you can use the following fragment: Page content Markdown <|{user_sel}|toggle|lov={users}|type=User|adapter={lambda u: (u.id, u.name)}|> HTML < taipy:toggle lov = \"{users}\" type = \"User\" adapter = \"{lambda u: (u.id, u.name)}\" > {user_sel} </ taipy:toggle > In this example, we are using the Python list users as the toggle's list of values . Because the control needs a way to convert the list items (which are instances of the class User ) into a string that can be displayed, we are using an adapter : a function that converts an object, whose type must be provided to the type property, to a tuple. The first element of the tuple is used to reference the selection (therefore those elements should be unique among all the items) and the second element is the string that turns out to be displayed.","title":"<tt>toggle</tt>"},{"location":"manuals/gui/viselements/toggle/#toggle","text":"A series of toggle buttons that the user can select.","title":"toggle"},{"location":"manuals/gui/viselements/toggle/#properties","text":"Name Type Default Description value (\u2605) dynamic(any) Bound to the selection value. theme bool False If set, this toggle control acts as a way to set the application Theme (dark or light). lov dict[str, any] The list of values. See [GLOBAL-LOV] for details. adapter Function `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|Icon) . type str Type of first lov element Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. value_by_id bool False If False, the selection value (in value ) is the selected element in lov . If set to True, then value is set to the id of the selected element in lov . on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. propagate bool App config Allows the control's main value to be automatically propagated. The default value is defined at the application configuration level. If True , any change to the control's value is immediately reflected in the bound application variable. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/toggle/#details","text":"Each button is represented by a string, an image or both. You can use an arbitrary type for all the items (see the example ).","title":"Details"},{"location":"manuals/gui/viselements/toggle/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/toggle/#display-a-list-of-string","text":"You can create a list of toggle buttons from a series of strings: Page content Markdown <|{value}|toggle|lov=Item 1;Item 2;Item 3|> HTML < taipy:toggle lov = \"Item 1;Item 2;Item 3\" > {value} </ taipy:toggle >","title":"Display a list of string"},{"location":"manuals/gui/viselements/toggle/#unselect-value","text":"In a toggle control, all buttons might be unselected. Therefore there is no value selected. In that case, the value of the property unselected_value is assigned if specified. Page content Markdown <|{value}|toggle|lov=Item 1;Item 2;Item 3|unselected_value=No Value|> HTML < taipy:toggle lov = \"Item 1;Item 2;Item 3\" unselected_value = \"No Value\" > {value} </ taipy:toggle >","title":"Unselect value"},{"location":"manuals/gui/viselements/toggle/#display-a-list-of-tuples","text":"A toggle control that returns an id while selecting a label or Icon^ . Page content Markdown <|{sel}|toggle|lov={[(\"id1\", \"Label 1\"), (\"id2\", Icon(\"/images/icon.png\", \"Label 2\"),(\"id3\", \"Label 3\")]}|> HTML < taipy:toggle value = \"{sel}\" lov = \"{[('id1', 'Label 1'), ('id2', Icon('/images/icon.png', 'Label 2'),('id3', 'Label 3')]}\" />","title":"Display a list of tuples"},{"location":"manuals/gui/viselements/toggle/#use-arbitrary-objects","text":"Assuming your Python code has created a list of objects: class User : def __init__ ( self , id , name , birth_year ): self . id , self . name , self . birth_year = ( id , name , birth_year ) users = [ User ( 231 , \"Johanna\" , 1987 ), User ( 125 , \"John\" , 1979 ), User ( 4 , \"Peter\" , 1968 ), User ( 31 , \"Mary\" , 1974 ) ] user_sel = users [ 2 ] If you want to create a toggle control that lets you pick a specific user, you can use the following fragment: Page content Markdown <|{user_sel}|toggle|lov={users}|type=User|adapter={lambda u: (u.id, u.name)}|> HTML < taipy:toggle lov = \"{users}\" type = \"User\" adapter = \"{lambda u: (u.id, u.name)}\" > {user_sel} </ taipy:toggle > In this example, we are using the Python list users as the toggle's list of values . Because the control needs a way to convert the list items (which are instances of the class User ) into a string that can be displayed, we are using an adapter : a function that converts an object, whose type must be provided to the type property, to a tuple. The first element of the tuple is used to reference the selection (therefore those elements should be unique among all the items) and the second element is the string that turns out to be displayed.","title":"Use arbitrary objects"},{"location":"manuals/gui/viselements/tree/","text":"tree \u00b6 A control that allows for selecting items from a hierarchical view of items. Each item is represented by a string, an image or both. The tree can let the user select multiple items. A filtering feature is available to display only a subset of the items. You can use an arbitrary type for all the items (see the example ). Properties \u00b6 Name Type Default Description expanded dynamic(bool|str[]) True if boolean value False: only one node can be expanded at one given level else it should be an array of the ids that need to be expanded multiple bool False If True, the user can select multiple items by holding the Ctrl key while clicking on items. filter bool False If True , this control is combined with a filter input area. width str|int \"360px\" The width, in CSS units, of this element. height str|int The height, in CSS units, of this element. dropdown bool False If True , the list of items is shown in a dropdown menu. You cannot use the filter in that situation. value (\u2605) dynamic(any) Bound to the selection value. lov dict[str, any] The list of values. See [GLOBAL-LOV] for details. adapter Function `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|Icon) . type str Type of first lov element Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. value_by_id bool False If False, the selection value (in value ) is the selected element in lov . If set to True, then value is set to the id of the selected element in lov . on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. propagate bool App config Allows the control's main value to be automatically propagated. The default value is defined at the application configuration level. If True , any change to the control's value is immediately reflected in the bound application variable. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element. Usage \u00b6 Display a list of string \u00b6 You can create a tree on a series of strings: Page content Markdown <|{value}|tree|lov=Item 1;Item 2;Item 3|> HTML < taipy:tree lov = \"Item 1;Item 2;Item 3\" > {value} </ taipy:tree > Display with filter and multiple selection \u00b6 You can add a filter input field that lets you display only strings that match the filter value. Page content Markdown <|{value}|tree|lov=Item 1;Item 2;Item 3|multiple|filter|> HTML < taipy:tree lov = \"Item 1;Item 2;Item 3\" multiple = \"True\" filter = \"True\" > {value} </ taipy:tree > Display a list of tuples \u00b6 A tree control that returns an id while selecting a label or Icon^ . Page content Markdown <|{sel}|tree|lov={[(\"id1\", \"Label 1\", [(\"id1.1\", \"Label 1.1\"), (\"id1.2\", \"Label 1.2\")]), (\"id2\", Icon(\"/images/icon.png\", \"Label 2\")), (\"id3\", \"Label 3\", [(\"id3.1\", \"Label 3.1\"), (\"id3.2\", \"Label 3.2\")])]}|> HTML < taipy:tree value = \"{sel}\" lov = \"{[('id1', 'Label 1'), ('id2', Icon('/images/icon.png', 'Label 2'),('id3', 'Label 3')]}\" /> Display with filter and multiple selection \u00b6 You can add a filter input field that lets you display only strings that match the filter value. Page content Markdown <|{value}|tree|lov=Item 1;Item 2;Item 3|multiple|filter|> HTML < taipy:tree lov = \"Item 1;Item 2;Item 3\" multiple = \"True\" filter = \"True\" > {value} </ taipy:tree > Manage expanded nodes \u00b6 The property expanded must be used to control the expanded/collapse state of the nodes. By default, the user can expand or collapse nodes. If expanded is set to False, there can be only one expanded node at any given level of the tree: if a node is expanded at a certain level and the user click on another node at the same level, the first node will be automatically collapsed. The expanded property can also hold a list of ids that are expanded. Page content Markdown <|{value}|tree|lov=Item 1;Item 2;Item 3|not expanded|> <|{value}|tree|lov=Item 1;Item 2;Item 3|expanded=Item 2|> HTML < taipy:tree value = \"{value}\" lov = \"Item 1;Item 2;Item 3\" expanded = \"False\" /> < taipy:tree value = \"{value}\" lov = \"Item 1;Item 2;Item 3\" expanded = \"Item 2\" /> Display a list of objects \u00b6 Assuming your Python code has created a list of object: class User : def __init__ ( self , id , name , birth_year , children ): self . id , self . name , self . birth_year , self . children = ( id , name , birth_year , children ) users = [ User ( 231 , \"Johanna\" , 1987 , [ User ( 231.1 , \"Johanna's son\" , 2006 , [])]), User ( 125 , \"John\" , 1979 , []), User ( 4 , \"Peter\" , 1968 , []), User ( 31 , \"Mary\" , 1974 , []) ] user_sel = users [ 2 ] If you want to create a tree control that lets you pick a specific user, you can use the following fragment. Page content Markdown <|{user_sel}|tree|lov={users}|type=User|adapter={lambda u: (u.id, u.name, u.children)}|> HTML < taipy:tree lov = \"{users}\" type = \"User\" adapter = \"{lambda u: (u.id, u.name, u.children)}\" > {user_sel} </ taipy:tree > In this example, we are using the Python list users as the tree's list of values . Because the control needs a way to convert the list items (which are instances of the class User ) into a string that can be displayed, we are using an adapter : a function that converts an object, whose type must be provided to the type property, to a tuple. The first element of the tuple is used to reference the selection (therefore those elements should be unique among all the items) and the second element is the string that turns out to be displayed. Display a list of objects with built-in adapter \u00b6 Objects with attributes id , label and children (as a list) can de dealt directly by the built-in lov adapter. Assuming your Python code has created a list of object: class User : def __init__ ( self , id , label , birth_year , children ): self . id , self . label , self . birth_year , self . children = ( id , label , birth_year , children ) users = [ User ( 231 , \"Johanna\" , 1987 , [ User ( 231.1 , \"Johanna's son\" , 2006 , [])]), User ( 125 , \"John\" , 1979 , []), User ( 4 , \"Peter\" , 1968 , []), User ( 31 , \"Mary\" , 1974 , []) ] user_sel = users [ 2 ] If you want to create a tree control that lets you pick a specific user, you can use the following fragment. Page content Markdown <|{user_sel}|tree|lov={users}|> HTML < taipy:tree lov = \"{users}\" value = \"{user_sel}\" /> Display a list of dictionary with built-in adapter \u00b6 Dictionaries with keys id , label and children (as a list) can de dealt directly by the built-in lov adapter. Assuming your Python code has created a list of object: users = [ { \"id\" : \"231\" , \"label\" : \"Johanna\" , \"year\" : 1987 , \"children\" : [{ \"id\" : \"231.1\" , \"label\" : \"Johanna's son\" , \"year\" : 2006 }]}, { \"id\" : \"125\" , \"label\" : \"John\" , \"year\" : 1979 , \"children\" : []}, { \"id\" : \"4\" , \"label\" : \"Peter\" , \"year\" : 1968 , \"children\" : []}, { \"id\" : \"31\" , \"label\" : \"Mary\" , \"year\" : 1974 , \"children\" : []} ] user_sel = users [ 2 ] Displaying the data would be as simple as: Page content Markdown <|{user_sel}|tree|lov={users}|> HTML < taipy:tree lov = \"{users}\" value = \"{user_sel}\" />","title":"<tt>tree</tt>"},{"location":"manuals/gui/viselements/tree/#tree","text":"A control that allows for selecting items from a hierarchical view of items. Each item is represented by a string, an image or both. The tree can let the user select multiple items. A filtering feature is available to display only a subset of the items. You can use an arbitrary type for all the items (see the example ).","title":"tree"},{"location":"manuals/gui/viselements/tree/#properties","text":"Name Type Default Description expanded dynamic(bool|str[]) True if boolean value False: only one node can be expanded at one given level else it should be an array of the ids that need to be expanded multiple bool False If True, the user can select multiple items by holding the Ctrl key while clicking on items. filter bool False If True , this control is combined with a filter input area. width str|int \"360px\" The width, in CSS units, of this element. height str|int The height, in CSS units, of this element. dropdown bool False If True , the list of items is shown in a dropdown menu. You cannot use the filter in that situation. value (\u2605) dynamic(any) Bound to the selection value. lov dict[str, any] The list of values. See [GLOBAL-LOV] for details. adapter Function `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|Icon) . type str Type of first lov element Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. value_by_id bool False If False, the selection value (in value ) is the selected element in lov . If set to True, then value is set to the id of the selected element in lov . on_change Callback The name of a function that is triggered when the value is updated. The parameters of that function are all optional: state (State^): state instance. var_name (str): the variable name. value (any): the new value. propagate bool App config Allows the control's main value to be automatically propagated. The default value is defined at the application configuration level. If True , any change to the control's value is immediately reflected in the bound application variable. active dynamic(bool) True Indicates if this component is active. An inactive component allows no user interaction. id str The identifier that will be assigned to the rendered HTML component. properties dict[str, any] Bound to a dictionary that contains additional properties for this element. class_name str List of CSS class names that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . hover_text dynamic(str) Information that is displayed when the user hovers over this element. (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/tree/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/tree/#display-a-list-of-string","text":"You can create a tree on a series of strings: Page content Markdown <|{value}|tree|lov=Item 1;Item 2;Item 3|> HTML < taipy:tree lov = \"Item 1;Item 2;Item 3\" > {value} </ taipy:tree >","title":"Display a list of string"},{"location":"manuals/gui/viselements/tree/#display-with-filter-and-multiple-selection","text":"You can add a filter input field that lets you display only strings that match the filter value. Page content Markdown <|{value}|tree|lov=Item 1;Item 2;Item 3|multiple|filter|> HTML < taipy:tree lov = \"Item 1;Item 2;Item 3\" multiple = \"True\" filter = \"True\" > {value} </ taipy:tree >","title":"Display with filter and multiple selection"},{"location":"manuals/gui/viselements/tree/#display-a-list-of-tuples","text":"A tree control that returns an id while selecting a label or Icon^ . Page content Markdown <|{sel}|tree|lov={[(\"id1\", \"Label 1\", [(\"id1.1\", \"Label 1.1\"), (\"id1.2\", \"Label 1.2\")]), (\"id2\", Icon(\"/images/icon.png\", \"Label 2\")), (\"id3\", \"Label 3\", [(\"id3.1\", \"Label 3.1\"), (\"id3.2\", \"Label 3.2\")])]}|> HTML < taipy:tree value = \"{sel}\" lov = \"{[('id1', 'Label 1'), ('id2', Icon('/images/icon.png', 'Label 2'),('id3', 'Label 3')]}\" />","title":"Display a list of tuples"},{"location":"manuals/gui/viselements/tree/#display-with-filter-and-multiple-selection_1","text":"You can add a filter input field that lets you display only strings that match the filter value. Page content Markdown <|{value}|tree|lov=Item 1;Item 2;Item 3|multiple|filter|> HTML < taipy:tree lov = \"Item 1;Item 2;Item 3\" multiple = \"True\" filter = \"True\" > {value} </ taipy:tree >","title":"Display with filter and multiple selection"},{"location":"manuals/gui/viselements/tree/#manage-expanded-nodes","text":"The property expanded must be used to control the expanded/collapse state of the nodes. By default, the user can expand or collapse nodes. If expanded is set to False, there can be only one expanded node at any given level of the tree: if a node is expanded at a certain level and the user click on another node at the same level, the first node will be automatically collapsed. The expanded property can also hold a list of ids that are expanded. Page content Markdown <|{value}|tree|lov=Item 1;Item 2;Item 3|not expanded|> <|{value}|tree|lov=Item 1;Item 2;Item 3|expanded=Item 2|> HTML < taipy:tree value = \"{value}\" lov = \"Item 1;Item 2;Item 3\" expanded = \"False\" /> < taipy:tree value = \"{value}\" lov = \"Item 1;Item 2;Item 3\" expanded = \"Item 2\" />","title":"Manage expanded nodes"},{"location":"manuals/gui/viselements/tree/#display-a-list-of-objects","text":"Assuming your Python code has created a list of object: class User : def __init__ ( self , id , name , birth_year , children ): self . id , self . name , self . birth_year , self . children = ( id , name , birth_year , children ) users = [ User ( 231 , \"Johanna\" , 1987 , [ User ( 231.1 , \"Johanna's son\" , 2006 , [])]), User ( 125 , \"John\" , 1979 , []), User ( 4 , \"Peter\" , 1968 , []), User ( 31 , \"Mary\" , 1974 , []) ] user_sel = users [ 2 ] If you want to create a tree control that lets you pick a specific user, you can use the following fragment. Page content Markdown <|{user_sel}|tree|lov={users}|type=User|adapter={lambda u: (u.id, u.name, u.children)}|> HTML < taipy:tree lov = \"{users}\" type = \"User\" adapter = \"{lambda u: (u.id, u.name, u.children)}\" > {user_sel} </ taipy:tree > In this example, we are using the Python list users as the tree's list of values . Because the control needs a way to convert the list items (which are instances of the class User ) into a string that can be displayed, we are using an adapter : a function that converts an object, whose type must be provided to the type property, to a tuple. The first element of the tuple is used to reference the selection (therefore those elements should be unique among all the items) and the second element is the string that turns out to be displayed.","title":"Display a list of objects"},{"location":"manuals/gui/viselements/tree/#display-a-list-of-objects-with-built-in-adapter","text":"Objects with attributes id , label and children (as a list) can de dealt directly by the built-in lov adapter. Assuming your Python code has created a list of object: class User : def __init__ ( self , id , label , birth_year , children ): self . id , self . label , self . birth_year , self . children = ( id , label , birth_year , children ) users = [ User ( 231 , \"Johanna\" , 1987 , [ User ( 231.1 , \"Johanna's son\" , 2006 , [])]), User ( 125 , \"John\" , 1979 , []), User ( 4 , \"Peter\" , 1968 , []), User ( 31 , \"Mary\" , 1974 , []) ] user_sel = users [ 2 ] If you want to create a tree control that lets you pick a specific user, you can use the following fragment. Page content Markdown <|{user_sel}|tree|lov={users}|> HTML < taipy:tree lov = \"{users}\" value = \"{user_sel}\" />","title":"Display a list of objects with built-in adapter"},{"location":"manuals/gui/viselements/tree/#display-a-list-of-dictionary-with-built-in-adapter","text":"Dictionaries with keys id , label and children (as a list) can de dealt directly by the built-in lov adapter. Assuming your Python code has created a list of object: users = [ { \"id\" : \"231\" , \"label\" : \"Johanna\" , \"year\" : 1987 , \"children\" : [{ \"id\" : \"231.1\" , \"label\" : \"Johanna's son\" , \"year\" : 2006 }]}, { \"id\" : \"125\" , \"label\" : \"John\" , \"year\" : 1979 , \"children\" : []}, { \"id\" : \"4\" , \"label\" : \"Peter\" , \"year\" : 1968 , \"children\" : []}, { \"id\" : \"31\" , \"label\" : \"Mary\" , \"year\" : 1974 , \"children\" : []} ] user_sel = users [ 2 ] Displaying the data would be as simple as: Page content Markdown <|{user_sel}|tree|lov={users}|> HTML < taipy:tree lov = \"{users}\" value = \"{user_sel}\" />","title":"Display a list of dictionary with built-in adapter"},{"location":"manuals/gui/viselements/charts/bar/","text":"Bar charts \u00b6 Bar charts can be handy when you need to compare data points next to one another and look at a global change over time. Simple bar chart \u00b6 Here is an example of how to use bar charts in an application. You want to display the popular vote percentage for every presidential election in the US since 1852 (source Wikipedia ). The Python code will look like this: percentages = [( 1852 , 50.83 ), ( 1856 , 45.29 ), ... , ( 2016 , 46.09 ), ( 2020 , 51.31 )] data = pd . DataFrame ( percentages , columns = [ \"Year\" , \"%\" ]) A Pandas DataFrame is built from a list of tuples that hold the election year and the percentage of votes the winner has received globally. The definition of a bar chart that represents this data will look like this: Page content Markdown <|{data}|chart|type=bar|x=Year|y=%|> HTML < taipy:chart type = \"bar\" x = \"Year\" y = \"%\" > {data} </ taipy:chart > All we did is set the type property to \"bar\", and the following chart is displayed on the page (the blue color is not related to what party the elected president belongs to - it is just the default color that Plotly has picked up): Faint bars Plotly gives bars a low opacity unless they are selected. If you want to override that behavior and force a higher opacity, you can use the following rule in your CSS style sheet: . cartesianlayer . plot path { opacity : 0.8 !important ; } Multiple data sets \u00b6 Say you want to display the score of the winning side next to the score of the losing side. Starting with the same data set as above, you can write: percentages = [( 1852 , 50.83 ), ( 1856 , 45.29 ), ... , ( 2016 , 46.09 ), ( 2020 , 51.31 )] data = pd . DataFrame ( percentages , columns = [ \"Year\" , \"Won\" ]) data [ \"Lost\" ] = [ 100 - t [ 1 ] for t in percentages ] We add a new column to the DataFrame data , which is the complement to 100 of percentages . To represent it, we will change the definition of the cart control: Page content Markdown <|{data}|chart|type=bar|x=Year|y[1]=Won|y[2]=Lost|> HTML < taipy:chart type = \"bar\" x = \"Year\" y [ 1 ]=\" Won \" y [ 2 ]=\" Lost \" > {data} </ taipy:chart > Here is how this new data set is represented: Stacked bar chart \u00b6 When different data sets are available from the same set of x values, it may be relevant to stack those values in the same bar. We are reusing the same DataFrame as in the example above. To indicate that we want a stacked representation, you must create a layout dictionary: layout = { \"barmode\" : \"stack\" } And use this dictionary in the definition of the chart: Page content Markdown <|{data}|chart|type=bar|x=Year|y[1]=Won|y[2]=Lost|layout={layout}|> HTML < taipy:chart type = \"bar\" x = \"Year\" y [ 1 ]=\" Won \" y [ 2 ]=\" Lost \" layout = \"{layout}\" > {data} </ taipy:chart > Here is the resulting image: And each bar adds up to 100, as expected. Facing bar charts \u00b6 It's sometimes helpful to display two bar charts facing each other, so comparing data is more manageable. This example creates a chart that shows the ratio of men and women practicing certain activities as hobbies. We want a vertical scale representing the different hobbies and the proportion of individuals enjoying that activity on each side of a common vertical axis, represented as two horizontal bars facing each other. We have a DataFrame that holds the information we want to represent: data = pd . DataFrame ({ \"Hobbies\" : [ \"Archery\" , \"Tennis\" , \"Football\" , \"Basket\" , \"Volley\" , \"Golf\" , \"Video-Games\" , \"Reading\" , \"Singing\" , \"Music\" ], \"Female\" : [ 0.4 , ... , 0.63 ], \"Male\" : [ - 0.39 , ... , - 0.6 ] }) Note how we negated the values for the Male data, so they are properly located on the x axis. The chart control definition for this example is slightly more complex than for the previous examples. It is clearer to store the properties and their values in a dictionary, which we will later use as the value for the properties control property. Here is our property dictionary: properties = { \"y\" : \"Hobbies\" , \"x[1]\" : \"Female\" , \"color[1]\" : \"#c26391\" , \"orientation[1]\" : \"h\" , \"x[2]\" : \"Male\" , \"color[2]\" : \"#5c91de\" , \"orientation[2]\" : \"h\" , \"layout\" : { \"barmode\" : \"overlay\" , \"xaxis\" : { \"title\" : \"Gender\" }, \"showlegend\" : False } } Note how to define our two x sets of values (in x[1] and x[2] ). The orientation[] property is used to change the orientation of the bars in our chart. Also, note that the layout property is set as well: We indicate in its barmode property that the two charts should be displayed next to each other, and we hide the legend using the showlegend property. Now let's use this dictionary in the definition of the chart: Page content Markdown <|{data}|chart|type=bar|properties={properties}|> HTML < taipy:chart type = \"bar\" properties = \"{properties}\" > {data} </ taipy:chart > Here is the result: Histogram \u00b6 A histogram shows how often different values occur in a data set. Histograms are used to see the shape of the data's distribution. This example will show the histogram of temperature samples taken every day in a given location. A DataFrame column holds a temperature for each day: data = pd . DataFrame ({ \"Days\" : [ - 11.3 , - 6 , - 0.1 , ... , - 8.1 , 1.6 , - 4.8 ] }) And a layout dictionary decorates the x axis: layout = { \"xaxis\" : { \"title\" : \"Temperature \u00b0C\" } } The chart control definition uses the \"histogram\" value for the type property: Page content Markdown <|{data}|chart|type=histogram|y[1]=Days|layout={layout}|> HTML < taipy:chart type = \"histogram\" y [ 1 ]=\" Days \" layout = \"{layout}\" > {data} </ taipy:chart > Here is how the histogram is displayed: Comparing histograms \u00b6 You want to compare two histograms next to each other, sharing the same x axis. Imagine you have a daily sample of the temperatures in two cities. Showing their histogram next to each other can immediately help understand the difference between the two data sets. In this situation, you need to split your data sets into two distinct data frames, one for each city. Each DataFrame contains a column holding a temperature for each day. The two DataFrames are stored in an array: data = [ pd . DataFrame ({ \"City A\" : [ - 11.3 , - 6 , - 0.1 , ... , - 8.1 , 1.6 , - 4.8 ]}), pd . DataFrame ({ \"City B\" : [ - 7.1 , 5.1 , 11.8 , ... , 3.4 , 13.1 , - 0.5 ]}) ] Besides the label of the x axis, the layout dictionary must indicate that both data sets must share the same x axis: layout = { \"barmode\" : \"overlay\" , \"xaxis\" : { \"title\" : \"Temperature \u00b0C\" } } The chart control definition is the following: Page content Markdown <|{data}|chart|type=histogram|y[1]=0/City A|y[2]=1/City B|layout={layout}|> HTML < taipy:chart type = \"histogram\" y [ 1 ]=\" 0 / City A \" y [ 2 ]=\" 1 / City B \" layout = \"{layout}\" > {data} </ taipy:chart > Note how you indicate which data set must be used in the chart: When dealing with arrays of DataFrames, the syntax is ' index / column ' where index indicates the index in the data array where the DataFrame holding the column column is located. The resulting display will be:","title":"Bar"},{"location":"manuals/gui/viselements/charts/bar/#bar-charts","text":"Bar charts can be handy when you need to compare data points next to one another and look at a global change over time.","title":"Bar charts"},{"location":"manuals/gui/viselements/charts/bar/#simple-bar-chart","text":"Here is an example of how to use bar charts in an application. You want to display the popular vote percentage for every presidential election in the US since 1852 (source Wikipedia ). The Python code will look like this: percentages = [( 1852 , 50.83 ), ( 1856 , 45.29 ), ... , ( 2016 , 46.09 ), ( 2020 , 51.31 )] data = pd . DataFrame ( percentages , columns = [ \"Year\" , \"%\" ]) A Pandas DataFrame is built from a list of tuples that hold the election year and the percentage of votes the winner has received globally. The definition of a bar chart that represents this data will look like this: Page content Markdown <|{data}|chart|type=bar|x=Year|y=%|> HTML < taipy:chart type = \"bar\" x = \"Year\" y = \"%\" > {data} </ taipy:chart > All we did is set the type property to \"bar\", and the following chart is displayed on the page (the blue color is not related to what party the elected president belongs to - it is just the default color that Plotly has picked up): Faint bars Plotly gives bars a low opacity unless they are selected. If you want to override that behavior and force a higher opacity, you can use the following rule in your CSS style sheet: . cartesianlayer . plot path { opacity : 0.8 !important ; }","title":"Simple bar chart"},{"location":"manuals/gui/viselements/charts/bar/#multiple-data-sets","text":"Say you want to display the score of the winning side next to the score of the losing side. Starting with the same data set as above, you can write: percentages = [( 1852 , 50.83 ), ( 1856 , 45.29 ), ... , ( 2016 , 46.09 ), ( 2020 , 51.31 )] data = pd . DataFrame ( percentages , columns = [ \"Year\" , \"Won\" ]) data [ \"Lost\" ] = [ 100 - t [ 1 ] for t in percentages ] We add a new column to the DataFrame data , which is the complement to 100 of percentages . To represent it, we will change the definition of the cart control: Page content Markdown <|{data}|chart|type=bar|x=Year|y[1]=Won|y[2]=Lost|> HTML < taipy:chart type = \"bar\" x = \"Year\" y [ 1 ]=\" Won \" y [ 2 ]=\" Lost \" > {data} </ taipy:chart > Here is how this new data set is represented:","title":"Multiple data sets"},{"location":"manuals/gui/viselements/charts/bar/#stacked-bar-chart","text":"When different data sets are available from the same set of x values, it may be relevant to stack those values in the same bar. We are reusing the same DataFrame as in the example above. To indicate that we want a stacked representation, you must create a layout dictionary: layout = { \"barmode\" : \"stack\" } And use this dictionary in the definition of the chart: Page content Markdown <|{data}|chart|type=bar|x=Year|y[1]=Won|y[2]=Lost|layout={layout}|> HTML < taipy:chart type = \"bar\" x = \"Year\" y [ 1 ]=\" Won \" y [ 2 ]=\" Lost \" layout = \"{layout}\" > {data} </ taipy:chart > Here is the resulting image: And each bar adds up to 100, as expected.","title":"Stacked bar chart"},{"location":"manuals/gui/viselements/charts/bar/#facing-bar-charts","text":"It's sometimes helpful to display two bar charts facing each other, so comparing data is more manageable. This example creates a chart that shows the ratio of men and women practicing certain activities as hobbies. We want a vertical scale representing the different hobbies and the proportion of individuals enjoying that activity on each side of a common vertical axis, represented as two horizontal bars facing each other. We have a DataFrame that holds the information we want to represent: data = pd . DataFrame ({ \"Hobbies\" : [ \"Archery\" , \"Tennis\" , \"Football\" , \"Basket\" , \"Volley\" , \"Golf\" , \"Video-Games\" , \"Reading\" , \"Singing\" , \"Music\" ], \"Female\" : [ 0.4 , ... , 0.63 ], \"Male\" : [ - 0.39 , ... , - 0.6 ] }) Note how we negated the values for the Male data, so they are properly located on the x axis. The chart control definition for this example is slightly more complex than for the previous examples. It is clearer to store the properties and their values in a dictionary, which we will later use as the value for the properties control property. Here is our property dictionary: properties = { \"y\" : \"Hobbies\" , \"x[1]\" : \"Female\" , \"color[1]\" : \"#c26391\" , \"orientation[1]\" : \"h\" , \"x[2]\" : \"Male\" , \"color[2]\" : \"#5c91de\" , \"orientation[2]\" : \"h\" , \"layout\" : { \"barmode\" : \"overlay\" , \"xaxis\" : { \"title\" : \"Gender\" }, \"showlegend\" : False } } Note how to define our two x sets of values (in x[1] and x[2] ). The orientation[] property is used to change the orientation of the bars in our chart. Also, note that the layout property is set as well: We indicate in its barmode property that the two charts should be displayed next to each other, and we hide the legend using the showlegend property. Now let's use this dictionary in the definition of the chart: Page content Markdown <|{data}|chart|type=bar|properties={properties}|> HTML < taipy:chart type = \"bar\" properties = \"{properties}\" > {data} </ taipy:chart > Here is the result:","title":"Facing bar charts"},{"location":"manuals/gui/viselements/charts/bar/#histogram","text":"A histogram shows how often different values occur in a data set. Histograms are used to see the shape of the data's distribution. This example will show the histogram of temperature samples taken every day in a given location. A DataFrame column holds a temperature for each day: data = pd . DataFrame ({ \"Days\" : [ - 11.3 , - 6 , - 0.1 , ... , - 8.1 , 1.6 , - 4.8 ] }) And a layout dictionary decorates the x axis: layout = { \"xaxis\" : { \"title\" : \"Temperature \u00b0C\" } } The chart control definition uses the \"histogram\" value for the type property: Page content Markdown <|{data}|chart|type=histogram|y[1]=Days|layout={layout}|> HTML < taipy:chart type = \"histogram\" y [ 1 ]=\" Days \" layout = \"{layout}\" > {data} </ taipy:chart > Here is how the histogram is displayed:","title":"Histogram"},{"location":"manuals/gui/viselements/charts/bar/#comparing-histograms","text":"You want to compare two histograms next to each other, sharing the same x axis. Imagine you have a daily sample of the temperatures in two cities. Showing their histogram next to each other can immediately help understand the difference between the two data sets. In this situation, you need to split your data sets into two distinct data frames, one for each city. Each DataFrame contains a column holding a temperature for each day. The two DataFrames are stored in an array: data = [ pd . DataFrame ({ \"City A\" : [ - 11.3 , - 6 , - 0.1 , ... , - 8.1 , 1.6 , - 4.8 ]}), pd . DataFrame ({ \"City B\" : [ - 7.1 , 5.1 , 11.8 , ... , 3.4 , 13.1 , - 0.5 ]}) ] Besides the label of the x axis, the layout dictionary must indicate that both data sets must share the same x axis: layout = { \"barmode\" : \"overlay\" , \"xaxis\" : { \"title\" : \"Temperature \u00b0C\" } } The chart control definition is the following: Page content Markdown <|{data}|chart|type=histogram|y[1]=0/City A|y[2]=1/City B|layout={layout}|> HTML < taipy:chart type = \"histogram\" y [ 1 ]=\" 0 / City A \" y [ 2 ]=\" 1 / City B \" layout = \"{layout}\" > {data} </ taipy:chart > Note how you indicate which data set must be used in the chart: When dealing with arrays of DataFrames, the syntax is ' index / column ' where index indicates the index in the data array where the DataFrame holding the column column is located. The resulting display will be:","title":"Comparing histograms"},{"location":"manuals/gui/viselements/charts/basics/","text":"Basic concepts \u00b6 This section explains how data can be used by the chart control in different situations, as well as basic customization hints. Tracing a series of values \u00b6 Say you want to create a line chart connecting a series of values. The x values will be the index of each plotted value. Our example would plot the function y = x * x on a small range of x values. We can do that using inline Python code in the page definition: Page content Markdown <|{[x*x for x in range(0, 9)]}|chart|> HTML < taipy:chart > {[x*x for x in range(0, 9)]} </ taipy:chart > Here is how this chart is displayed: Decorating a chart \u00b6 In our previous example, you may have noticed the '0' sitting under the x axis. This is the 'name' of the axis. Because we are not using any DataFrame from which column names could be used, Taipy uses the index of the data series, which is 0, since we only have one dimension in our data. Let's make the chart slightly nicer by adding a real name to the axis. This involve the use of the layout property of the chart control. This property must be set to a dictionary (see the Plotly Reference for all the details) defined as follows: layout = { \"xaxis\" : { \"title\" : \"Our little range\" } } There are several settings that apply to axis. However in our case, we will only use the title property. The control definition is modified to use that dictionary: Page content Markdown <|{[x*x for x in range(0, 9)]}|chart|title=Plotting x squared|layout={layout}|> HTML < taipy:chart title = \"Plotting x squared\" layout = \"{layout}\" > {[x*x for x in range(0, 9)]} </ taipy:chart > As you can see, we also added a title to the chart. The result is the following: Defining the x axis \u00b6 So far the examples did not explicitly define a x axis: we have used the index of the y value in the input array. Let us create a dictionary that holds data for our two series: the x and the y values: x_range = range ( - 10 , 11 ) data = { \"x_values\" : [ x for x in x_range ], \"y_values\" : [ x * x for x in x_range ] } Page content Markdown <|{data}|chart|x=x_values|y=y_values|> HTML < taipy:chart x = \"x_values\" y = \"y_values\" > {data} </ taipy:chart > Taipy internally transforms data to a Pandas DataFrame. The x property indicates the name of the DataFrame column (\"x_values\") that holds the x axis values and the y values come from the the column \"y_values\". The result is the following: Note that the axis can now have relevant names. Adding a trace \u00b6 You will often want to display several traces in the same chart control. For each data series, we can add a column to the DataFrame and indicate which series to display: import pandas as pd x_range = range ( - 10 , 11 ) data = pd . DataFrame ({ \"x_s\" : [ x for x in x_range ], \"y1_s\" : [ x * x for x in x_range ], \"y2_s\" : [ 100 - x * x for x in x_range ] }) Page content Markdown <|{data}|chart|x=x_s|y[1]=y1_s|y[2]=y2_s|> HTML < taipy:chart x = \"x_s\" y [ 1 ]=\" y1_s \" y [ 2 ]=\" y2_s \" > {data} </ taipy:chart > Note that 'y[1]' or 'y[2]' are not valid HTML attribute names. Taipy allows this syntax nevertheless. And now our chart can display two traces, one for each y series: A legend is automatically added to the chart to indicate which trace represents which series. If you want to change the color of a trace, you can use the color property: setting color[2] to red will impact the color of the second trace so it is displayed in red. Adding a y axis \u00b6 Let us look at a situation where the two y series use ranges that are very different: data = pd . DataFrame ({ \"x_s\" : [ x for x in x_range ], \"y1_s\" : [ x * x for x in x_range ], \"y2_s\" : [( 100 - x * x ) / 100 for x in x_range ] }) Compared to the previous example, we have divided all the values of the second y series by 100, so that the trace is not readable any more: The chart control lets you define a second y axis that the second y series that use to make more sense of the data. To do this, you need to add the definition of a layout that describes this second axis: layout = { \"yaxis2\" : { \"overlaying\" : \"y\" , \"side\" : \"right\" , \"title\" : \"Second y axis\" } } So this axis will be in the 'y' direction, to the right of the graph, and will have a title. To attach our second trace to that axis, we need to change our control definition: Page content Markdown <|{data}|chart|x=x_s|y[1]=y1_s|y[2]=y2_s|yaxis[2]=y2|layout={layout}|> HTML < taipy:chart x = \"x_s\" y [ 1 ]=\" y1_s \" y [ 2 ]=\" y2_s \" yaxis [ 2 ]=\" y2 \" layout = \"{layout}\" > {data} </ taipy:chart > See how we leverage the property yaxis , indicating that the indexed trace (2) relies on the axis we have created in the chart layout. The resulting plot is far more relevant: Using a time series \u00b6 Many charts will represent data that is based on a timeline. Taipy allows you to define an x axis that represents a time range. Here is how you could display data based on time. In our example, we will use one random value for each hour of a given day: import pandas as pd import numpy as np data = pd . DataFrame ({ \"dates\" : pd . date_range ( \"2022-04-07\" , periods = 24 , freq = \"H\" ), \"values\" : pd . Series ( np . random . randn ( 24 )) }) Creating a chart that relies on the time series (in the dates column of the DataFrame) is pretty straightforward: Page content Markdown <|{data}|chart|x=dates|y=values|> HTML < taipy:chart x = \"dates\" y = \"values\" > {data} </ taipy:chart > And the result is exactly what you expect:","title":"Basics"},{"location":"manuals/gui/viselements/charts/basics/#basic-concepts","text":"This section explains how data can be used by the chart control in different situations, as well as basic customization hints.","title":"Basic concepts"},{"location":"manuals/gui/viselements/charts/basics/#tracing-a-series-of-values","text":"Say you want to create a line chart connecting a series of values. The x values will be the index of each plotted value. Our example would plot the function y = x * x on a small range of x values. We can do that using inline Python code in the page definition: Page content Markdown <|{[x*x for x in range(0, 9)]}|chart|> HTML < taipy:chart > {[x*x for x in range(0, 9)]} </ taipy:chart > Here is how this chart is displayed:","title":"Tracing a series of values"},{"location":"manuals/gui/viselements/charts/basics/#decorating-a-chart","text":"In our previous example, you may have noticed the '0' sitting under the x axis. This is the 'name' of the axis. Because we are not using any DataFrame from which column names could be used, Taipy uses the index of the data series, which is 0, since we only have one dimension in our data. Let's make the chart slightly nicer by adding a real name to the axis. This involve the use of the layout property of the chart control. This property must be set to a dictionary (see the Plotly Reference for all the details) defined as follows: layout = { \"xaxis\" : { \"title\" : \"Our little range\" } } There are several settings that apply to axis. However in our case, we will only use the title property. The control definition is modified to use that dictionary: Page content Markdown <|{[x*x for x in range(0, 9)]}|chart|title=Plotting x squared|layout={layout}|> HTML < taipy:chart title = \"Plotting x squared\" layout = \"{layout}\" > {[x*x for x in range(0, 9)]} </ taipy:chart > As you can see, we also added a title to the chart. The result is the following:","title":"Decorating a chart"},{"location":"manuals/gui/viselements/charts/basics/#defining-the-x-axis","text":"So far the examples did not explicitly define a x axis: we have used the index of the y value in the input array. Let us create a dictionary that holds data for our two series: the x and the y values: x_range = range ( - 10 , 11 ) data = { \"x_values\" : [ x for x in x_range ], \"y_values\" : [ x * x for x in x_range ] } Page content Markdown <|{data}|chart|x=x_values|y=y_values|> HTML < taipy:chart x = \"x_values\" y = \"y_values\" > {data} </ taipy:chart > Taipy internally transforms data to a Pandas DataFrame. The x property indicates the name of the DataFrame column (\"x_values\") that holds the x axis values and the y values come from the the column \"y_values\". The result is the following: Note that the axis can now have relevant names.","title":"Defining the x axis"},{"location":"manuals/gui/viselements/charts/basics/#adding-a-trace","text":"You will often want to display several traces in the same chart control. For each data series, we can add a column to the DataFrame and indicate which series to display: import pandas as pd x_range = range ( - 10 , 11 ) data = pd . DataFrame ({ \"x_s\" : [ x for x in x_range ], \"y1_s\" : [ x * x for x in x_range ], \"y2_s\" : [ 100 - x * x for x in x_range ] }) Page content Markdown <|{data}|chart|x=x_s|y[1]=y1_s|y[2]=y2_s|> HTML < taipy:chart x = \"x_s\" y [ 1 ]=\" y1_s \" y [ 2 ]=\" y2_s \" > {data} </ taipy:chart > Note that 'y[1]' or 'y[2]' are not valid HTML attribute names. Taipy allows this syntax nevertheless. And now our chart can display two traces, one for each y series: A legend is automatically added to the chart to indicate which trace represents which series. If you want to change the color of a trace, you can use the color property: setting color[2] to red will impact the color of the second trace so it is displayed in red.","title":"Adding a trace"},{"location":"manuals/gui/viselements/charts/basics/#adding-a-y-axis","text":"Let us look at a situation where the two y series use ranges that are very different: data = pd . DataFrame ({ \"x_s\" : [ x for x in x_range ], \"y1_s\" : [ x * x for x in x_range ], \"y2_s\" : [( 100 - x * x ) / 100 for x in x_range ] }) Compared to the previous example, we have divided all the values of the second y series by 100, so that the trace is not readable any more: The chart control lets you define a second y axis that the second y series that use to make more sense of the data. To do this, you need to add the definition of a layout that describes this second axis: layout = { \"yaxis2\" : { \"overlaying\" : \"y\" , \"side\" : \"right\" , \"title\" : \"Second y axis\" } } So this axis will be in the 'y' direction, to the right of the graph, and will have a title. To attach our second trace to that axis, we need to change our control definition: Page content Markdown <|{data}|chart|x=x_s|y[1]=y1_s|y[2]=y2_s|yaxis[2]=y2|layout={layout}|> HTML < taipy:chart x = \"x_s\" y [ 1 ]=\" y1_s \" y [ 2 ]=\" y2_s \" yaxis [ 2 ]=\" y2 \" layout = \"{layout}\" > {data} </ taipy:chart > See how we leverage the property yaxis , indicating that the indexed trace (2) relies on the axis we have created in the chart layout. The resulting plot is far more relevant:","title":"Adding a y axis"},{"location":"manuals/gui/viselements/charts/basics/#using-a-time-series","text":"Many charts will represent data that is based on a timeline. Taipy allows you to define an x axis that represents a time range. Here is how you could display data based on time. In our example, we will use one random value for each hour of a given day: import pandas as pd import numpy as np data = pd . DataFrame ({ \"dates\" : pd . date_range ( \"2022-04-07\" , periods = 24 , freq = \"H\" ), \"values\" : pd . Series ( np . random . randn ( 24 )) }) Creating a chart that relies on the time series (in the dates column of the DataFrame) is pretty straightforward: Page content Markdown <|{data}|chart|x=dates|y=values|> HTML < taipy:chart x = \"dates\" y = \"values\" > {data} </ taipy:chart > And the result is exactly what you expect:","title":"Using a time series"},{"location":"manuals/gui/viselements/charts/line/","text":"Line charts \u00b6 Line plots are a widely-used representation that connects distinct data points, showing trends. The Basics section already shows a handful of examples showing line charts. This section focuses on customizations that are relevant for this type of charts only. Styling lines \u00b6 You can style plots using the line[] and color[] properties. Say we have captured temperature measurements every day: the mean, maximum and minimum values for every day. This data set can easily be stored in a Pandas Data Frame: data = pd . DataFrame ( { \"Date\" : pd . date_range ( \"<start-date>\" , periods = 100 , freq = \"D\" ), \"Temp\u00b0C\" : [ - 15 , - 12.9 , .. .100 records total ... , 7.2 , 10.2 ], \"Min\" : [ - 22 , - 19.7 , .. .100 records total ... , 2.7 , 6.5 ], \"Max\" : [ - 8.6 , - 8.2 , .. .100 records total ... , 12. , 13.5 ] } ) We want to customize the style of the different traces, so the chart is easier to read. We will display the 'Max' trace in red, the 'Min' trace in blue, and apply a dash style to the 'regular' temperature plot. Here is the definition of the chart control: Page content Markdown <|{data}|chart|mode=lines|x=Date|y[1]=Temp\u00b0C|y[2]=Min|y[3]=Max|line[1]=dash|color[2]=blue|color[3]=red|> HTML < taipy:chart mode = \"lines\" x = \"Date\" y [ 1 ]=\" Temp \u00b0 C \" y [ 2 ]=\" Min \" y [ 3 ]=\" Max \" line [ 1 ]=\" dash \" color [ 2 ]=\" blue \" color [ 3 ]=\" red \" > {data} </ taipy:chart > The page now shows the following chart: Text above plot \u00b6 It is sometimes useful to provide textual information on top of a plot. Here is how to do that in the context of a line chart. We want to display, at the approximate location of a temperature data point, the index of the week we are plotting the data. We can reuse the dataset of the example above, and add a column to the DataFrame, holding the week number as a text: data = pd . DataFrame ({ ... \"WeekN\" : [ f \"W { i // 7 } \" if i % 7 == 0 else None for i in range ( 0 , 100 )] ... }) Note that this new column ( WeekN ) is mainly filled with None values. Let us use this column as a source for displaying text in our chart: Page content Markdown <|{data}|chart|x=Date|y[1]=Temp\u00b0C|y[2]=Max|mode[2]=text|text[2]=WeekN|> HTML < taipy:chart x = \"Date\" y [ 1 ]=\" Temp \u00b0 C \" mode [ 2 ]=\" text \" y [ 2 ]=\" Max \" text [ 2 ]=\" WeekN \" > {data} </ taipy:chart > This definition will allow to display the texts contained in the 'WeekN' column (the text[2] ) property, at the y coordinate indicated in the 'Max' column (the y[2] ), as raw text (the mode[2] property). Here is the resulting chart: Faint text You may find that your texts don't appear as clearly as they should. Plotly actually applies a low opacity to individual plot items to bring the opacity at a maximum value when the item is selected. If you have this problem and want to work it out, you can enforce a higher opacity value by default for all the text elements of your charts by adding the following lines to your application style sheets: . textpoint text { fill-opacity : 0.9 !important ; }","title":"Line"},{"location":"manuals/gui/viselements/charts/line/#line-charts","text":"Line plots are a widely-used representation that connects distinct data points, showing trends. The Basics section already shows a handful of examples showing line charts. This section focuses on customizations that are relevant for this type of charts only.","title":"Line charts"},{"location":"manuals/gui/viselements/charts/line/#styling-lines","text":"You can style plots using the line[] and color[] properties. Say we have captured temperature measurements every day: the mean, maximum and minimum values for every day. This data set can easily be stored in a Pandas Data Frame: data = pd . DataFrame ( { \"Date\" : pd . date_range ( \"<start-date>\" , periods = 100 , freq = \"D\" ), \"Temp\u00b0C\" : [ - 15 , - 12.9 , .. .100 records total ... , 7.2 , 10.2 ], \"Min\" : [ - 22 , - 19.7 , .. .100 records total ... , 2.7 , 6.5 ], \"Max\" : [ - 8.6 , - 8.2 , .. .100 records total ... , 12. , 13.5 ] } ) We want to customize the style of the different traces, so the chart is easier to read. We will display the 'Max' trace in red, the 'Min' trace in blue, and apply a dash style to the 'regular' temperature plot. Here is the definition of the chart control: Page content Markdown <|{data}|chart|mode=lines|x=Date|y[1]=Temp\u00b0C|y[2]=Min|y[3]=Max|line[1]=dash|color[2]=blue|color[3]=red|> HTML < taipy:chart mode = \"lines\" x = \"Date\" y [ 1 ]=\" Temp \u00b0 C \" y [ 2 ]=\" Min \" y [ 3 ]=\" Max \" line [ 1 ]=\" dash \" color [ 2 ]=\" blue \" color [ 3 ]=\" red \" > {data} </ taipy:chart > The page now shows the following chart:","title":"Styling lines"},{"location":"manuals/gui/viselements/charts/line/#text-above-plot","text":"It is sometimes useful to provide textual information on top of a plot. Here is how to do that in the context of a line chart. We want to display, at the approximate location of a temperature data point, the index of the week we are plotting the data. We can reuse the dataset of the example above, and add a column to the DataFrame, holding the week number as a text: data = pd . DataFrame ({ ... \"WeekN\" : [ f \"W { i // 7 } \" if i % 7 == 0 else None for i in range ( 0 , 100 )] ... }) Note that this new column ( WeekN ) is mainly filled with None values. Let us use this column as a source for displaying text in our chart: Page content Markdown <|{data}|chart|x=Date|y[1]=Temp\u00b0C|y[2]=Max|mode[2]=text|text[2]=WeekN|> HTML < taipy:chart x = \"Date\" y [ 1 ]=\" Temp \u00b0 C \" mode [ 2 ]=\" text \" y [ 2 ]=\" Max \" text [ 2 ]=\" WeekN \" > {data} </ taipy:chart > This definition will allow to display the texts contained in the 'WeekN' column (the text[2] ) property, at the y coordinate indicated in the 'Max' column (the y[2] ), as raw text (the mode[2] property). Here is the resulting chart: Faint text You may find that your texts don't appear as clearly as they should. Plotly actually applies a low opacity to individual plot items to bring the opacity at a maximum value when the item is selected. If you have this problem and want to work it out, you can enforce a higher opacity value by default for all the text elements of your charts by adding the following lines to your application style sheets: . textpoint text { fill-opacity : 0.9 !important ; }","title":"Text above plot"},{"location":"manuals/gui/viselements/charts/others/","text":"Other features \u00b6 Pie charts \u00b6 Pie charts is a circular graphic divided into slices that represent a numerical quantity. The arc length of each slice is proportional to the quantity it represents. Here this example, we want to represent how much area is covered by forest in countries in the world. Only the first few countries are represented since too many would make the chart unreadable. Our data set, where the area is provided as thousands of hectares in 2020, comes from FAO and is defined as follows: data = pd . DataFrame ({ \"Country\" : [ \"Rest of the world\" , \"Russian Federation\" , ... , \"Peru\" ], \"Area\" : [ 1445674.66 , 815312 , ... , 72330.4 ] }) We can indicate the color of each individual slice using the layout property of the chart: layout = { \"piecolorway\" : [ \"B05080\" , \"#f5f5f5\" , ... , \"#800000\" ], } And the chart definition is the following: Page content Markdown <|{data}|chart|type=pie|x=Area|label=Country|layout={layout}|> HTML < taipy:chart type = \"pie\" x = \"Area\" label = \"Country\" layout = \"{layout}\" > {data} </ taipy:chart > Here is the resulting chart: Multiple charts \u00b6 You may want to plot different data sets in the same chart. In the following example, data holds a data frame where two sets of values are stored in columns y1 and y2 that you want to represent in a chart where the abscissa values can be found in column x . Labels for the charts can be found in columns l1 and l2 . Furthermore, we want the second dataset to be displayed in red. Page content Markdown <|{data}|chart|x=x|y[1]=y1|label[1]=l1|y[2]=y2|label[2]=l2|color[2]=red|xaxis[2]=x2|> Note how we refer to the different y value sources, using indices. HTML < taipy:chart x = \"x\" y [ 1 ]=\" y1 \" label [ 1 ]=\" l1 \" y [ 2 ]=\" y2 \" label [ 2 ]=\" l2 \" mode [ 2 ]=\" markers \" color [ 2 ]=\" red \" type [ 2 ]=\" scatter \" xaxis [ 2 ]=\" x2 \" > {data} </ taipy:chart > Multiple charts with different lengths \u00b6 In the following example, the value holds an array of dataframe of different length [data1, data2] . We want to show a first chart with columns Col A and Col B from the first dataframe and a second chart with columns Col D and Col F : the columns names needs to be prefixed by the index of the dataframe in the array. Page content Markdown <|{[data1, data2]}|chart|x[1]=0/Col A|y[1]=0/Col B|x[2]=1/Col D|y[2]=1/Col F|> <|{[[26, 34, 46],[34,34],[16, 46, 20, 6]]}|chart|> In this second example, we draw 3 charts with x the index of the y value from each array. HTML < taipy:chart x [ 1 ]=\" 0 / Col A \" y [ 1 ]=\" 0 / Col B \" x [ 2 ]=\" 1 / Col D \" y [ 2 ]=\" 1 / Col F \" > {[data1, data2]} </ taipy:chart > Tracking selection \u00b6 If points selection is enabled in the chart, you can keep track of which point indices are selected in a variable. Page content Markdown <|{data}|chart|selected={selected_indices}|...|> HTML < taipy:chart selected = \"{selected_indices}\" ... > {data} </ taipy:chart > Tracking range \u00b6 By specifying a function for on_range_change , you can be made aware of chart zoom changes. Page content Markdown <|{data}|chart|on_range_change=range_change_function_name|...|> HTML < taipy:chart on_range_change = \"range_change_function_name\" ... > {data} </ taipy:chart > Sampling data \u00b6 By specifying limit_rows as True, charts will adapt the number of points to the viewable area. Depending on the algorithm, Some specific points might not be shown on the chart. Page content Markdown <|{data}|chart|limit_rows|...|> HTML < taipy:chart limit_rows = \"true\" ... > {data} </ taipy:chart > Responsive chart \u00b6 By specifying plot_config responsive key, chart will be responsive ie chart will resize automatically to adapt to its container width (especially usefull on mobile devices). Please get more information at Plotly.js responsive . pconf = { \"responsive\" : True } Page content Markdown <|{data}|chart|plot_config={pconf}|...|> HTML < taipy:chart plot_config = \"{pconf}\" ... > {data} </ taipy:chart >","title":"Others"},{"location":"manuals/gui/viselements/charts/others/#other-features","text":"","title":"Other features"},{"location":"manuals/gui/viselements/charts/others/#pie-charts","text":"Pie charts is a circular graphic divided into slices that represent a numerical quantity. The arc length of each slice is proportional to the quantity it represents. Here this example, we want to represent how much area is covered by forest in countries in the world. Only the first few countries are represented since too many would make the chart unreadable. Our data set, where the area is provided as thousands of hectares in 2020, comes from FAO and is defined as follows: data = pd . DataFrame ({ \"Country\" : [ \"Rest of the world\" , \"Russian Federation\" , ... , \"Peru\" ], \"Area\" : [ 1445674.66 , 815312 , ... , 72330.4 ] }) We can indicate the color of each individual slice using the layout property of the chart: layout = { \"piecolorway\" : [ \"B05080\" , \"#f5f5f5\" , ... , \"#800000\" ], } And the chart definition is the following: Page content Markdown <|{data}|chart|type=pie|x=Area|label=Country|layout={layout}|> HTML < taipy:chart type = \"pie\" x = \"Area\" label = \"Country\" layout = \"{layout}\" > {data} </ taipy:chart > Here is the resulting chart:","title":"Pie charts"},{"location":"manuals/gui/viselements/charts/others/#multiple-charts","text":"You may want to plot different data sets in the same chart. In the following example, data holds a data frame where two sets of values are stored in columns y1 and y2 that you want to represent in a chart where the abscissa values can be found in column x . Labels for the charts can be found in columns l1 and l2 . Furthermore, we want the second dataset to be displayed in red. Page content Markdown <|{data}|chart|x=x|y[1]=y1|label[1]=l1|y[2]=y2|label[2]=l2|color[2]=red|xaxis[2]=x2|> Note how we refer to the different y value sources, using indices. HTML < taipy:chart x = \"x\" y [ 1 ]=\" y1 \" label [ 1 ]=\" l1 \" y [ 2 ]=\" y2 \" label [ 2 ]=\" l2 \" mode [ 2 ]=\" markers \" color [ 2 ]=\" red \" type [ 2 ]=\" scatter \" xaxis [ 2 ]=\" x2 \" > {data} </ taipy:chart >","title":"Multiple charts"},{"location":"manuals/gui/viselements/charts/others/#multiple-charts-with-different-lengths","text":"In the following example, the value holds an array of dataframe of different length [data1, data2] . We want to show a first chart with columns Col A and Col B from the first dataframe and a second chart with columns Col D and Col F : the columns names needs to be prefixed by the index of the dataframe in the array. Page content Markdown <|{[data1, data2]}|chart|x[1]=0/Col A|y[1]=0/Col B|x[2]=1/Col D|y[2]=1/Col F|> <|{[[26, 34, 46],[34,34],[16, 46, 20, 6]]}|chart|> In this second example, we draw 3 charts with x the index of the y value from each array. HTML < taipy:chart x [ 1 ]=\" 0 / Col A \" y [ 1 ]=\" 0 / Col B \" x [ 2 ]=\" 1 / Col D \" y [ 2 ]=\" 1 / Col F \" > {[data1, data2]} </ taipy:chart >","title":"Multiple charts with different lengths"},{"location":"manuals/gui/viselements/charts/others/#tracking-selection","text":"If points selection is enabled in the chart, you can keep track of which point indices are selected in a variable. Page content Markdown <|{data}|chart|selected={selected_indices}|...|> HTML < taipy:chart selected = \"{selected_indices}\" ... > {data} </ taipy:chart >","title":"Tracking selection"},{"location":"manuals/gui/viselements/charts/others/#tracking-range","text":"By specifying a function for on_range_change , you can be made aware of chart zoom changes. Page content Markdown <|{data}|chart|on_range_change=range_change_function_name|...|> HTML < taipy:chart on_range_change = \"range_change_function_name\" ... > {data} </ taipy:chart >","title":"Tracking range"},{"location":"manuals/gui/viselements/charts/others/#sampling-data","text":"By specifying limit_rows as True, charts will adapt the number of points to the viewable area. Depending on the algorithm, Some specific points might not be shown on the chart. Page content Markdown <|{data}|chart|limit_rows|...|> HTML < taipy:chart limit_rows = \"true\" ... > {data} </ taipy:chart >","title":"Sampling data"},{"location":"manuals/gui/viselements/charts/others/#responsive-chart","text":"By specifying plot_config responsive key, chart will be responsive ie chart will resize automatically to adapt to its container width (especially usefull on mobile devices). Please get more information at Plotly.js responsive . pconf = { \"responsive\" : True } Page content Markdown <|{data}|chart|plot_config={pconf}|...|> HTML < taipy:chart plot_config = \"{pconf}\" ... > {data} </ taipy:chart >","title":"Responsive chart"},{"location":"manuals/gui/viselements/charts/scatter/","text":"Scatter charts \u00b6 Scatter charts represent data points as dots or other symbols. They are useful to see relationships between groups of data points. Classification \u00b6 Using a scatter chart to represent the result of the classification of samples is really relevant: you can use different colors to represent different classes that data points belong to. Here is an example where we have two series of samples, based on the same x axis: samples are stored in one series or the other depending on a classification algorithm. The result is three numerical arrays: The values on the x axis. The y values for the samples that belong to the class 'A'. The value is set to Nan if it does not belong to class 'A'. The y values for the samples that belong to the class 'B'. The value is set to Nan if it does not belong to class 'B'. x_range = [ 0.64 , 1.05 , .. .1000 values ... , - 0.7 , - 1.2 ] a_values = [ nan , nan , 1.04 , - 1.01 , .. .1000 values ... , 1.6 , 1.45 , nan ] b_values = [ - 2.1 , - 0.99 , nan , nan , .. .1000 values ... , nan , nan , 2.12 ] data = pd . DataFrame ({ \"x\" : x_range , \"Class A\" : class_A , \"Class B\" : class_B }) The chart definition looks like this: Page content Markdown <|{data}|chart|mode=markers|x=x|y[1]=Class A|y[2]=Class B|> HTML < taipy:chart mode = \"markers\" x = \"x\" y [ 1 ]=\" Class A \" y [ 2 ]=\" Class B \" > {data} </ taipy:chart > And the resulting chart is: Customizing a scatter chart \u00b6 A common problem with scatter chart is that individual markers can be displayed on top of each other. This may result in markers being hidden by others, and the display may not reflect the density of markers. This is why it is usually not a good idea to use scatter charts where markers are completely opaque. It is easy to change the marker parameters if needed. The available parameters are listed in the Plotly scatter documentation page. Here is how we can change the size and shape of the markers that are used in our previous example (with fewer data points). We need to create two dictionaries that hold the values we want to impact: marker_A = { \"symbol\" : \"arrow-down\" , \"size\" : 20 } marker_B = { \"symbol\" : \"triangle-up-dot\" , \"size\" : 20 } We are requesting bigger markers, with one shape per series. To have Taipy use those styles, we must modify the chart definition: Page content Markdown <|{data}|chart|mode=markers|x=x|y[1]=Class A|marker[1]={marker_A}|y[2]=Class B|marker[2]={marker_B}> HTML < taipy:chart mode = \"markers\" x = \"x\" y [ 1 ]=\" Class A \" marker [ 1 ]=\"{ marker_A }\" y [ 2 ]=\" Class B \" marker [ 2 ]=\"{ marker_B }\" > {data} </ taipy:chart > That generates the following chart: Regression \u00b6 Regression is an excellent use case for using scatter charts: on top of samples data points, you can trace the plot of a function that best fits the data points. Here is an example of linear regression, where we can use a line plot on top of markers. The chart will represent an array of two Data Frames: one for the original data points and one for the computed regression line. Here is the code that defines the source data for the chart: data = [ pd . DataFrame ({ \"x\" : [ 0.13 , - 0.49 , ... , 1.89 , - 0.97 ], \"y\" : [ 22.23 , - 51.77 , ... , 135.76 , - 77.33 ] }), pd . DataFrame ({ \"x\" : [ - 3.53 , 2.95 ], \"Regression\" : [ - 237.48 , 200 ] }) ] The chart definition uses the two Data Frames and their columns: Page content Markdown <|{data}|chart|mode[1]=markers|x[1]=0/x|y[1]=0/y|mode[2]=line|x[2]=1/x|y[2]=1/Regression|> HTML < taipy:chart mode [ 1 ]=\" markers \" x [ 1 ]=\" 0 / x \" y [ 1 ]=\" 0 / y \" mode [ 2 ]=\" line \" x [ 2 ]=\" 1 / x \" y [ 2 ]=\" 1 / Regression \" > {data} </ taipy:chart > See how, using the mode[] , x[] , and y[] properties, the two plots are defined. The chart representing the linear regression result is the following:","title":"Scatter"},{"location":"manuals/gui/viselements/charts/scatter/#scatter-charts","text":"Scatter charts represent data points as dots or other symbols. They are useful to see relationships between groups of data points.","title":"Scatter charts"},{"location":"manuals/gui/viselements/charts/scatter/#classification","text":"Using a scatter chart to represent the result of the classification of samples is really relevant: you can use different colors to represent different classes that data points belong to. Here is an example where we have two series of samples, based on the same x axis: samples are stored in one series or the other depending on a classification algorithm. The result is three numerical arrays: The values on the x axis. The y values for the samples that belong to the class 'A'. The value is set to Nan if it does not belong to class 'A'. The y values for the samples that belong to the class 'B'. The value is set to Nan if it does not belong to class 'B'. x_range = [ 0.64 , 1.05 , .. .1000 values ... , - 0.7 , - 1.2 ] a_values = [ nan , nan , 1.04 , - 1.01 , .. .1000 values ... , 1.6 , 1.45 , nan ] b_values = [ - 2.1 , - 0.99 , nan , nan , .. .1000 values ... , nan , nan , 2.12 ] data = pd . DataFrame ({ \"x\" : x_range , \"Class A\" : class_A , \"Class B\" : class_B }) The chart definition looks like this: Page content Markdown <|{data}|chart|mode=markers|x=x|y[1]=Class A|y[2]=Class B|> HTML < taipy:chart mode = \"markers\" x = \"x\" y [ 1 ]=\" Class A \" y [ 2 ]=\" Class B \" > {data} </ taipy:chart > And the resulting chart is:","title":"Classification"},{"location":"manuals/gui/viselements/charts/scatter/#customizing-a-scatter-chart","text":"A common problem with scatter chart is that individual markers can be displayed on top of each other. This may result in markers being hidden by others, and the display may not reflect the density of markers. This is why it is usually not a good idea to use scatter charts where markers are completely opaque. It is easy to change the marker parameters if needed. The available parameters are listed in the Plotly scatter documentation page. Here is how we can change the size and shape of the markers that are used in our previous example (with fewer data points). We need to create two dictionaries that hold the values we want to impact: marker_A = { \"symbol\" : \"arrow-down\" , \"size\" : 20 } marker_B = { \"symbol\" : \"triangle-up-dot\" , \"size\" : 20 } We are requesting bigger markers, with one shape per series. To have Taipy use those styles, we must modify the chart definition: Page content Markdown <|{data}|chart|mode=markers|x=x|y[1]=Class A|marker[1]={marker_A}|y[2]=Class B|marker[2]={marker_B}> HTML < taipy:chart mode = \"markers\" x = \"x\" y [ 1 ]=\" Class A \" marker [ 1 ]=\"{ marker_A }\" y [ 2 ]=\" Class B \" marker [ 2 ]=\"{ marker_B }\" > {data} </ taipy:chart > That generates the following chart:","title":"Customizing a scatter chart"},{"location":"manuals/gui/viselements/charts/scatter/#regression","text":"Regression is an excellent use case for using scatter charts: on top of samples data points, you can trace the plot of a function that best fits the data points. Here is an example of linear regression, where we can use a line plot on top of markers. The chart will represent an array of two Data Frames: one for the original data points and one for the computed regression line. Here is the code that defines the source data for the chart: data = [ pd . DataFrame ({ \"x\" : [ 0.13 , - 0.49 , ... , 1.89 , - 0.97 ], \"y\" : [ 22.23 , - 51.77 , ... , 135.76 , - 77.33 ] }), pd . DataFrame ({ \"x\" : [ - 3.53 , 2.95 ], \"Regression\" : [ - 237.48 , 200 ] }) ] The chart definition uses the two Data Frames and their columns: Page content Markdown <|{data}|chart|mode[1]=markers|x[1]=0/x|y[1]=0/y|mode[2]=line|x[2]=1/x|y[2]=1/Regression|> HTML < taipy:chart mode [ 1 ]=\" markers \" x [ 1 ]=\" 0 / x \" y [ 1 ]=\" 0 / y \" mode [ 2 ]=\" line \" x [ 2 ]=\" 1 / x \" y [ 2 ]=\" 1 / Regression \" > {data} </ taipy:chart > See how, using the mode[] , x[] , and y[] properties, the two plots are defined. The chart representing the linear regression result is the following:","title":"Regression"},{"location":"manuals/reference/pkg_taipy.core.config/","text":"Package: taipy.core.config \u00b6 Classes \u00b6 DataNodeConfig : Configuration fields needed to instantiate an actual DataNode^ from the DataNodeConfig. GlobalAppConfig : Configuration fields related to the global application. Issue : An issue detected in the configuration. IssueCollector : A collection of issues (instances of class Issue^ ). JobConfig : Configuration fields related to the jobs' executions. PipelineConfig : Configuration fields needed to instantiate an actual Pipeline^ from the PipelineConfig. ScenarioConfig : Holds all the configuration fields needed to instantiate an actual Scenario^ from the ScenarioConfig . TaskConfig : Holds all the configuration fields needed to create an actual Task^ from the TaskConfig .","title":"taipy.core.config"},{"location":"manuals/reference/pkg_taipy.core.config/#package-taipycoreconfig","text":"","title":"Package: taipy.core.config"},{"location":"manuals/reference/pkg_taipy.core.config/#classes","text":"DataNodeConfig : Configuration fields needed to instantiate an actual DataNode^ from the DataNodeConfig. GlobalAppConfig : Configuration fields related to the global application. Issue : An issue detected in the configuration. IssueCollector : A collection of issues (instances of class Issue^ ). JobConfig : Configuration fields related to the jobs' executions. PipelineConfig : Configuration fields needed to instantiate an actual Pipeline^ from the PipelineConfig. ScenarioConfig : Holds all the configuration fields needed to instantiate an actual Scenario^ from the ScenarioConfig . TaskConfig : Holds all the configuration fields needed to create an actual Task^ from the TaskConfig .","title":"Classes"},{"location":"manuals/reference/pkg_taipy.core.data/","text":"Package: taipy.core.data \u00b6 Classes \u00b6 CSVDataNode : Data Node stored as a CSV file. ExcelDataNode : Data Node stored as an Excel file. GenericDataNode : Generic Data Node that uses custom read and write functions. InMemoryDataNode : Data Node stored in memory. PickleDataNode : Data Node stored as a pickle file. SQLDataNode : Data Node stored in a SQL database.","title":"taipy.core.data"},{"location":"manuals/reference/pkg_taipy.core.data/#package-taipycoredata","text":"","title":"Package: taipy.core.data"},{"location":"manuals/reference/pkg_taipy.core.data/#classes","text":"CSVDataNode : Data Node stored as a CSV file. ExcelDataNode : Data Node stored as an Excel file. GenericDataNode : Generic Data Node that uses custom read and write functions. InMemoryDataNode : Data Node stored in memory. PickleDataNode : Data Node stored as a pickle file. SQLDataNode : Data Node stored in a SQL database.","title":"Classes"},{"location":"manuals/reference/pkg_taipy.core.data.operator/","text":"Package: taipy.core.data.operator \u00b6 Classes \u00b6 JoinOperator : Enumeration of join operators for Data Node filtering. The possible values are AND and OR . Operator : Enumeration of operators for Data Node filtering.","title":"taipy.core.data.operator"},{"location":"manuals/reference/pkg_taipy.core.data.operator/#package-taipycoredataoperator","text":"","title":"Package: taipy.core.data.operator"},{"location":"manuals/reference/pkg_taipy.core.data.operator/#classes","text":"JoinOperator : Enumeration of join operators for Data Node filtering. The possible values are AND and OR . Operator : Enumeration of operators for Data Node filtering.","title":"Classes"},{"location":"manuals/reference/pkg_taipy.core.exceptions.exceptions/","text":"Package: taipy.core.exceptions.exceptions \u00b6 Classes \u00b6 ConfigurationIssueError : Raised if an inconsistency has been detected in the configuration. CycleAlreadyExists : Raised if it is trying to create a Cycle that has already exists. DataNodeWritingError : Raised if an error happens during the writing in a data node. DeletingPrimaryScenario : Raised if a primary scenario is deleted. DependencyNotInstalled : Raised if a package is missing. DifferentScenarioConfigs : Raised if scenario comparison is requested on scenarios with different scenario configs. DoesNotBelongToACycle : Raised if a scenario without any cycle is promoted as primary scenario. InconsistentEnvVariableError : Inconsistency value has been detected in an environment variable referenced by the configuration. InsufficientScenarioToCompare : Raised if too few scenarios are requested to be compared. InvalidConfigurationId : Configuration id is not valid. InvalidDataNodeType : Raised if a data node storage type does not exist. InvalidSubscriber : Raised if we try to load a function that is not valid. JobNotDeletedException : Raised if we try to delete a job that cannot be deleted. LoadingError : Raised if an error occurs while loading the configuration file. MissingEnvVariableError : Environment variable referenced in configuration is missing. MissingReadFunction : Raised if no read function is provided for the GenericDataNode. MissingRequiredProperty : Raised if a required property is missing when creating a Data Node. MissingWriteFunction : Raised if no write function is provided for the GenericDataNode. ModelNotFound : Raised when trying to fetch a non-existent model. MultipleDataNodeFromSameConfigWithSameParent : Raised if there are multiple data nodes from the same data node configuration and the same parent identifier. MultiplePipelineFromSameConfigWithSameParent : Raised if it exists multiple pipelines from the same pipeline config and with the same parent_id . MultipleTaskFromSameConfigWithSameParent : Raised if there are multiple tasks from the same task configuration and the same parent identifier. NoData : Raised if a data node is read before it has been written. NonExistingComparator : Raised if a scenario comparator does not exist. NonExistingCycle : Raised if we request a cycle not known by the cycle manager. NonExistingDataNode : Raised if a requested DataNode is not known by the DataNode Manager. NonExistingExcelSheet : Raised if a requested Sheet name does not exist in the provided Excel file. NonExistingJob : Raised if we try to get a job that does not exist. NonExistingPipeline : Raised if a requested Pipeline is not known by the Pipeline Manager. NonExistingPipelineConfig : Raised if a requested Pipeline configuration is not known by the Pipeline Manager. NonExistingScenario : Raised if a requested scenario is not known by the Scenario Manager. NonExistingScenarioConfig : Raised if a requested scenario configuration is not known by the Scenario Manager. NonExistingTask : Raised if a requested task is not known by the Task Manager. NonExistingTaskConfig : Raised if a requested task configuration is not known by the Task Manager. NotMatchSheetNameAndCustomObject : Raised if a provided list of sheet names does not match with the provided list of custom objects. UnauthorizedTagError : Must provide an authorized tag. UnknownDatabaseEngine : Raised if the database engine is not known when creating a connection with a SQLDataNode.","title":"taipy.core.exceptions.exceptions"},{"location":"manuals/reference/pkg_taipy.core.exceptions.exceptions/#package-taipycoreexceptionsexceptions","text":"","title":"Package: taipy.core.exceptions.exceptions"},{"location":"manuals/reference/pkg_taipy.core.exceptions.exceptions/#classes","text":"ConfigurationIssueError : Raised if an inconsistency has been detected in the configuration. CycleAlreadyExists : Raised if it is trying to create a Cycle that has already exists. DataNodeWritingError : Raised if an error happens during the writing in a data node. DeletingPrimaryScenario : Raised if a primary scenario is deleted. DependencyNotInstalled : Raised if a package is missing. DifferentScenarioConfigs : Raised if scenario comparison is requested on scenarios with different scenario configs. DoesNotBelongToACycle : Raised if a scenario without any cycle is promoted as primary scenario. InconsistentEnvVariableError : Inconsistency value has been detected in an environment variable referenced by the configuration. InsufficientScenarioToCompare : Raised if too few scenarios are requested to be compared. InvalidConfigurationId : Configuration id is not valid. InvalidDataNodeType : Raised if a data node storage type does not exist. InvalidSubscriber : Raised if we try to load a function that is not valid. JobNotDeletedException : Raised if we try to delete a job that cannot be deleted. LoadingError : Raised if an error occurs while loading the configuration file. MissingEnvVariableError : Environment variable referenced in configuration is missing. MissingReadFunction : Raised if no read function is provided for the GenericDataNode. MissingRequiredProperty : Raised if a required property is missing when creating a Data Node. MissingWriteFunction : Raised if no write function is provided for the GenericDataNode. ModelNotFound : Raised when trying to fetch a non-existent model. MultipleDataNodeFromSameConfigWithSameParent : Raised if there are multiple data nodes from the same data node configuration and the same parent identifier. MultiplePipelineFromSameConfigWithSameParent : Raised if it exists multiple pipelines from the same pipeline config and with the same parent_id . MultipleTaskFromSameConfigWithSameParent : Raised if there are multiple tasks from the same task configuration and the same parent identifier. NoData : Raised if a data node is read before it has been written. NonExistingComparator : Raised if a scenario comparator does not exist. NonExistingCycle : Raised if we request a cycle not known by the cycle manager. NonExistingDataNode : Raised if a requested DataNode is not known by the DataNode Manager. NonExistingExcelSheet : Raised if a requested Sheet name does not exist in the provided Excel file. NonExistingJob : Raised if we try to get a job that does not exist. NonExistingPipeline : Raised if a requested Pipeline is not known by the Pipeline Manager. NonExistingPipelineConfig : Raised if a requested Pipeline configuration is not known by the Pipeline Manager. NonExistingScenario : Raised if a requested scenario is not known by the Scenario Manager. NonExistingScenarioConfig : Raised if a requested scenario configuration is not known by the Scenario Manager. NonExistingTask : Raised if a requested task is not known by the Task Manager. NonExistingTaskConfig : Raised if a requested task configuration is not known by the Task Manager. NotMatchSheetNameAndCustomObject : Raised if a provided list of sheet names does not match with the provided list of custom objects. UnauthorizedTagError : Must provide an authorized tag. UnknownDatabaseEngine : Raised if the database engine is not known when creating a connection with a SQLDataNode.","title":"Classes"},{"location":"manuals/reference/pkg_taipy.gui.page/","text":"Package: taipy.gui.page \u00b6 Classes \u00b6 Page : Generic page generator.","title":"taipy.gui.page"},{"location":"manuals/reference/pkg_taipy.gui.page/#package-taipyguipage","text":"","title":"Package: taipy.gui.page"},{"location":"manuals/reference/pkg_taipy.gui.page/#classes","text":"Page : Generic page generator.","title":"Classes"},{"location":"manuals/reference/pkg_taipy.gui.partial/","text":"Package: taipy.gui.partial \u00b6 Classes \u00b6 Partial : Re-usable Page content.","title":"taipy.gui.partial"},{"location":"manuals/reference/pkg_taipy.gui.partial/#package-taipyguipartial","text":"","title":"Package: taipy.gui.partial"},{"location":"manuals/reference/pkg_taipy.gui.partial/#classes","text":"Partial : Re-usable Page content.","title":"Classes"},{"location":"manuals/reference/pkg_taipy/","text":"Package: taipy \u00b6 Types \u00b6 CycleId : Type that holds a Cycle^ identifier. DataNodeId : Type that holds a DataNode^ identifier. JobId : Type that holds a Job^ identifier. PipelineId : Type that holds a Pipeline^ identifier. ScenarioId : Type that holds a Scenario^ identifier. TaskId : Type that holds a Task^ identifier. Functions \u00b6 clean_all_entities() : Delete all entities from the Taipy data folder. compare_scenarios() : Compare the data nodes of several scenarios. create_pipeline() : Create and return a new pipeline from a pipeline configuration. create_scenario() : Create and return a new scenario from a scenario configuration. delete() : Delete an entity and its nested entities. delete_job() : Delete a job. delete_jobs() : Delete all jobs. get() : Get an entity from its identifier. get_cycles() : Return the list of all existing cycles. get_data_nodes() : Return all the existing data nodes. get_jobs() : Return all the existing jobs. get_latest_job() : Return the latest job of a task. get_pipelines() : Return all existing pipelines. get_primary() : Return the primary scenario of a cycle. get_primary_scenarios() : Return the list of all primary scenarios. get_scenarios() : Return the list of all existing scenarios filtered by a cycle or a tag. get_tasks() : Return the list of all existing tasks. set() : Save or update an entity. set_primary() : Promote a scenario as the primary scenario of its cycle. submit() : Submit an entity for execution. subscribe_pipeline() : Subscribe a function to be called on job status change. subscribe_scenario() : Subscribe a function to be called on job status change. tag() : Add a tag to a scenario. unsubscribe_pipeline() : Unsubscribe a function that is called when the status of a Job changes. unsubscribe_scenario() : Unsubscribe a function that is called when the status of a Job^ changes. untag() : Remove a tag from a scenario. Classes \u00b6 Config : Configuration singleton. Cycle : An iteration of a recurrent work pattern. DataNode : Reference to a dataset. Frequency : Frequency of the recurrence of Cycle^ and Scenario^ objects. Job : Execution of a Task^ . Pipeline : List of Task^ s and additional attributes representing a set of data processing elements connected as a direct acyclic graph. Scenario : Instance of a Business case to solve. Scope : Scope of a DataNode^ . Status : Execution status of a Job^ . Task : Hold a user function that will be executed, its parameters and the results.","title":"taipy"},{"location":"manuals/reference/pkg_taipy/#package-taipy","text":"","title":"Package: taipy"},{"location":"manuals/reference/pkg_taipy/#types","text":"CycleId : Type that holds a Cycle^ identifier. DataNodeId : Type that holds a DataNode^ identifier. JobId : Type that holds a Job^ identifier. PipelineId : Type that holds a Pipeline^ identifier. ScenarioId : Type that holds a Scenario^ identifier. TaskId : Type that holds a Task^ identifier.","title":"Types"},{"location":"manuals/reference/pkg_taipy/#functions","text":"clean_all_entities() : Delete all entities from the Taipy data folder. compare_scenarios() : Compare the data nodes of several scenarios. create_pipeline() : Create and return a new pipeline from a pipeline configuration. create_scenario() : Create and return a new scenario from a scenario configuration. delete() : Delete an entity and its nested entities. delete_job() : Delete a job. delete_jobs() : Delete all jobs. get() : Get an entity from its identifier. get_cycles() : Return the list of all existing cycles. get_data_nodes() : Return all the existing data nodes. get_jobs() : Return all the existing jobs. get_latest_job() : Return the latest job of a task. get_pipelines() : Return all existing pipelines. get_primary() : Return the primary scenario of a cycle. get_primary_scenarios() : Return the list of all primary scenarios. get_scenarios() : Return the list of all existing scenarios filtered by a cycle or a tag. get_tasks() : Return the list of all existing tasks. set() : Save or update an entity. set_primary() : Promote a scenario as the primary scenario of its cycle. submit() : Submit an entity for execution. subscribe_pipeline() : Subscribe a function to be called on job status change. subscribe_scenario() : Subscribe a function to be called on job status change. tag() : Add a tag to a scenario. unsubscribe_pipeline() : Unsubscribe a function that is called when the status of a Job changes. unsubscribe_scenario() : Unsubscribe a function that is called when the status of a Job^ changes. untag() : Remove a tag from a scenario.","title":"Functions"},{"location":"manuals/reference/pkg_taipy/#classes","text":"Config : Configuration singleton. Cycle : An iteration of a recurrent work pattern. DataNode : Reference to a dataset. Frequency : Frequency of the recurrence of Cycle^ and Scenario^ objects. Job : Execution of a Task^ . Pipeline : List of Task^ s and additional attributes representing a set of data processing elements connected as a direct acyclic graph. Scenario : Instance of a Business case to solve. Scope : Scope of a DataNode^ . Status : Execution status of a Job^ . Task : Hold a user function that will be executed, its parameters and the results.","title":"Classes"},{"location":"manuals/reference/taipy.Config/","text":"Configuration singleton. check () classmethod \u00b6 Check configuration. This method logs issue messages and returns an issue collector. Returns: Type Description IssueCollector^ Collector containing the info, warning and error issues. configure_csv_data_node ( id , path , has_header = True , scope =< Scope . SCENARIO : 2 > , ** properties ) classmethod \u00b6 Configure a new CSV data node configuration. Parameters: Name Type Description Default id str The unique identifier of the new CSV data node configuration. required path str The path of the CSV file. required has_header bool If True, indicates that the CSV file has a header. True scope Scope^ The scope of the CSV data node configuration. The default value is Scope.SCENARIO . <Scope.SCENARIO: 2> **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description DataNodeConfig^ The new CSV data node configuration. configure_data_node ( id , storage_type = 'pickle' , scope =< Scope . SCENARIO : 2 > , ** properties ) classmethod \u00b6 Configure a new data node configuration. Parameters: Name Type Description Default id str The unique identifier of the new data node configuration. required storage_type str The data node configuration storage type. The possible values are \"pickle\" (which the default value, unless it has been overloaded by the storage_type value set in the default data node configuration (see (Config.)configure_default_data_node()^ )), \"csv\" , \"excel\" , \"sql\" , \"in_memory\" , or \"generic\" . 'pickle' scope Scope^ The scope of the data node configuration. The default value is Scope.SCENARIO (or the one specified in (Config.)configure_default_data_node()^ ). <Scope.SCENARIO: 2> **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description DataNodeConfig^ The new data node configuration. configure_default_data_node ( storage_type , scope =< Scope . SCENARIO : 2 > , ** properties ) classmethod \u00b6 Configure the default values for data node configurations. This function creates the default data node configuration object, where all data node configuration objects will find their default values when needed. Parameters: Name Type Description Default storage_type str The default storage type for all data node configurations. The possible values are \"pickle\" (the default value), \"csv\" , \"excel\" , \"sql\" , \"in_memory\" , or \"generic\" . required scope Scope^ The default scope fot all data node configurations. The default value is Scope.SCENARIO . <Scope.SCENARIO: 2> **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description DataNodeConfig^ The default data node configuration. configure_default_pipeline ( task_configs , ** properties ) classmethod \u00b6 Configure the default values for pipeline configurations. This function creates the default pipeline configuration object, where all pipeline configuration objects will find their default values when needed. Parameters: Name Type Description Default task_configs Union[TaskConfig^, List[TaskConfig^]] The list of the task configurations that make the default pipeline configuration. This can be a single task configuration object is this pipeline holds a single task. required **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description PipelineConfig^ The default pipeline configuration. configure_default_scenario ( pipeline_configs , frequency = None , comparators = None , ** properties ) classmethod \u00b6 Configure the default values for scenario configurations. This function creates the default scenario configuration object, where all scenario configuration objects will find their default values when needed. Parameters: Name Type Description Default pipeline_configs List[PipelineConfig^] The list of pipeline configurations used by this scenario configuration. required frequency Optional[Frequency^] The scenario frequency. It corresponds to the recurrence of the scenarios instantiated from this configuration. Based on this frequency each scenario will be attached to the relevant cycle. None comparators Optional[Dict[str, Union[List[Callable], Callable]]] The list of functions used to compare scenarios. A comparator function is attached to a scenario's data node configuration. The key of the dictionary parameter corresponds to the data node configuration id. During the scenarios' comparison, each comparator is applied to all the data nodes instantiated from the data node configuration attached to the comparator. See taipy.compare_scenarios()^ more more details. None **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description ScenarioConfig^ The default scenario configuration. configure_default_task ( function , input = None , output = None , ** properties ) classmethod \u00b6 Configure the default values for task configurations. This function creates the default task configuration object, where all task configuration objects will find their default values when needed. Parameters: Name Type Description Default function Callable The python function called by Taipy to run the task. required input Optional[Union[DataNodeConfig^, List[DataNodeConfig^]]] The list of the input data node configurations. This can be a unique data node configuration if there is a single input data node, or None if there are none. None output Optional[Union[DataNodeConfig^, List[DataNodeConfig^]]] The list of the output data node configurations. This can be a unique data node configuration if there is a single output data node, or None if there are none. None **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description TaskConfig^ The default task configuration. configure_excel_data_node ( id , path , has_header = True , sheet_name = None , scope =< Scope . SCENARIO : 2 > , ** properties ) classmethod \u00b6 Configure a new Excel data node configuration. Parameters: Name Type Description Default id str The unique identifier of the new Excel data node configuration. required path str The path of the Excel file. required has_header bool If True, indicates that the Excel file has a header. True sheet_name Union[List[str], str] The list of sheet names to be used. This can be a unique name. None scope Scope^ The scope of the Excel data node configuration. The default value is Scope.SCENARIO . <Scope.SCENARIO: 2> **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description DataNodeConfig^ The new CSV data node configuration. configure_generic_data_node ( id , read_fct = None , write_fct = None , read_fct_params = None , write_fct_params = None , scope =< Scope . SCENARIO : 2 > , ** properties ) classmethod \u00b6 Configure a new generic data node configuration. Parameters: Name Type Description Default id str The unique identifier of the new generic data node configuration. required read_fct Optional[Callable] The Python function called to read the data. None write_fct Optional[Callable] The Python function called to write the data. The provided function must have at least one parameter that receives the data to be written. None read_fct_params Optional[List] The parameters that are passed to read_fct to read the data. None write_fct_params Optional[List] The parameters that are passed to write_fct to write the data. None scope Optional[Scope^] The scope of the Generic data node configuration. The default value is Scope.SCENARIO . <Scope.SCENARIO: 2> **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description DataNodeConfig^ The new Generic data node configuration. configure_global_app ( root_folder = None , storage_folder = None , clean_entities_enabled = None , ** properties ) classmethod \u00b6 Configure the global application. Parameters: Name Type Description Default root_folder Optional[str] The path of the base folder for the Taipy application. None storage_folder Optional[str] The folder name used to store Taipy data. It is used in conjunction with the root_folder field: the storage path is \" \". None clean_entities_enabled Optional[str] The field to activate or deactivate the 'clean entities' feature. The default value is False. None Returns: Type Description GlobalAppConfig^ The global application configuration. configure_in_memory_data_node ( id , default_data = None , scope =< Scope . SCENARIO : 2 > , ** properties ) classmethod \u00b6 Configure a new in_memory data node configuration. Parameters: Name Type Description Default id str The unique identifier of the new in_memory data node configuration. required default_data Optional[Any] The default data of the data nodes instantiated from this in_memory data node configuration. None scope Scope^ The scope of the in_memory data node configuration. The default value is Scope.SCENARIO . <Scope.SCENARIO: 2> **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description DataNodeConfig^ The new in_memory data node configuration. configure_job_executions ( mode = None , nb_of_workers = None , ** properties ) classmethod \u00b6 Configure job execution. Parameters: Name Type Description Default mode Optional[str] The job execution mode. Possible values are: \"standalone\" (the default value) or \"airflow\" (Enterprise version only). None nb_of_workers Optional[int, str] The maximum number of jobs able to run in parallel. The default value is 1. A string can be provided to dynamically set the value using an environment variable. The string must follow the pattern: ENV[&lt;env_var&gt;] where &lt;env_var&gt; is the name of environment variable. None Returns: Type Description JobConfig^ The job execution configuration. configure_pickle_data_node ( id , default_data = None , scope =< Scope . SCENARIO : 2 > , ** properties ) classmethod \u00b6 Configure a new pickle data node configuration. Parameters: Name Type Description Default id str The unique identifier of the new pickle data node configuration. required default_data Optional[Any] The default data of the data nodes instantiated from this pickle data node configuration. None scope Scope^ The scope of the pickle data node configuration. The default value is Scope.SCENARIO . <Scope.SCENARIO: 2> **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description DataNodeConfig^ The new pickle data node configuration. configure_pipeline ( id , task_configs , ** properties ) classmethod \u00b6 Configure a new pipeline configuration. Parameters: Name Type Description Default id str The unique identifier of the new pipeline configuration. required task_configs Union[TaskConfig^, List[TaskConfig^]] The list of the task configurations that make this new pipeline. This can be a single task configuration object is this pipeline holds a single task. required **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description PipelineConfig^ The new pipeline configuration. configure_scenario ( id , pipeline_configs , frequency = None , comparators = None , ** properties ) classmethod \u00b6 Configure a new scenario configuration. Parameters: Name Type Description Default id str The unique identifier of the new scenario configuration. required pipeline_configs List[PipelineConfig^] The list of pipeline configurations used by this new scenario configuration. required frequency Optional[Frequency^] The scenario frequency. It corresponds to the recurrence of the scenarios instantiated from this configuration. Based on this frequency each scenario will be attached to the relevant cycle. None comparators Optional[Dict[str, Union[List[Callable], Callable]]] The list of functions used to compare scenarios. A comparator function is attached to a scenario's data node configuration. The key of the dictionary parameter corresponds to the data node configuration id. During the scenarios' comparison, each comparator is applied to all the data nodes instantiated from the data node configuration attached to the comparator. See (taipy.)compare_scenarios()^ more more details. None **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description ScenarioConfig^ The new scenario configuration. configure_scenario_from_tasks ( id , task_configs , frequency = None , comparators = None , pipeline_id = None , ** properties ) classmethod \u00b6 Configure a new scenario configuration made of a single new pipeline configuration. A new pipeline configuration is created as well. If pipeline_id is not provided, the new pipeline configuration identifier is set to the scenario configuration identifier post-fixed by '_pipeline'. Parameters: Name Type Description Default id str The unique identifier of the scenario configuration. required task_configs List[TaskConfig^] The list of task configurations used by the new pipeline configuration that is created. required frequency Optional[Frequency^] The scenario frequency. It corresponds to the recurrence of the scenarios instantiated from this configuration. Based on this frequency each scenario will be attached to the relevant cycle. None comparators Optional[Dict[str, Union[List[Callable], Callable]]] The list of functions used to compare scenarios. A comparator function is attached to a scenario's data node configuration. The key of the dictionary parameter corresponds to the data node configuration id. During the scenarios' comparison, each comparator is applied to all the data nodes instantiated from the data node configuration attached to the comparator. See (taipy.)compare_scenarios() more more details. None pipeline_id str The identifier of the new pipeline configuration to be configured. None **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description ScenarioConfig^ The new scenario configuration. configure_sql_data_node ( id , db_username , db_password , db_name , db_engine , read_query , write_table = None , db_port = 1433 , db_host = 'localhost' , db_driver = 'ODBC Driver 17 for SQL Server' , scope =< Scope . SCENARIO : 2 > , ** properties ) classmethod \u00b6 Configure a new SQL data node configuration. Parameters: Name Type Description Default id str The unique identifier of the new SQL data node configuration. required db_username str The database username. required db_password str The database password. required db_name str The database name. required db_engine str The database engine. Possible values are \"sqlite\" or \"mssql\" . required read_query str The SQL query string used to read the data from the database. required write_table str The name of the table in the database to write the data to. None db_port int The database port. The default value is 1433. 1433 db_host str The database host. The default value is \"localhost\" . 'localhost' db_driver str The database driver. The default value is \"ODBC Driver 17 for SQL Server\" . 'ODBC Driver 17 for SQL Server' scope Scope^ The scope of the SQL data node configuration. The default value is Scope.SCENARIO . <Scope.SCENARIO: 2> **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description DataNodeConfig^ The new SQL data node configuration. configure_task ( id , function , input = None , output = None , ** properties ) classmethod \u00b6 Configure a new task configuration. Parameters: Name Type Description Default id str The unique identifier of this task configuration. required function Callable The python function called by Taipy to run the task. required input Optional[Union[DataNodeConfig^, List[DataNodeConfig^]]] The list of the function input data node configurations. This can be a unique data node configuration if there is a single input data node, or None if there are none. None output Optional[Union[DataNodeConfig^, List[DataNodeConfig^]]] The list of the function output data node configurations. This can be a unique data node configuration if there is a single output data node, or None if there are none. None **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description TaskConfig^ The new task configuration. export ( filename ) classmethod \u00b6 Export a configuration. The export is done in a toml file. The exported configuration is a compilation from the three possible methods to configure the application: the python code configuration, the file configuration and the environment configuration. Parameters: Name Type Description Default filename Union[str, Path] The path of the file to export. required Note If filename already exists, it is overwritten. load ( filename ) classmethod \u00b6 Load a configuration file. Parameters: Name Type Description Default filename Union[str, Path] The path of the toml configuration file to load. required","title":"taipy.Config"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.check","text":"Check configuration. This method logs issue messages and returns an issue collector. Returns: Type Description IssueCollector^ Collector containing the info, warning and error issues.","title":"check()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.configure_csv_data_node","text":"Configure a new CSV data node configuration. Parameters: Name Type Description Default id str The unique identifier of the new CSV data node configuration. required path str The path of the CSV file. required has_header bool If True, indicates that the CSV file has a header. True scope Scope^ The scope of the CSV data node configuration. The default value is Scope.SCENARIO . <Scope.SCENARIO: 2> **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description DataNodeConfig^ The new CSV data node configuration.","title":"configure_csv_data_node()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.configure_data_node","text":"Configure a new data node configuration. Parameters: Name Type Description Default id str The unique identifier of the new data node configuration. required storage_type str The data node configuration storage type. The possible values are \"pickle\" (which the default value, unless it has been overloaded by the storage_type value set in the default data node configuration (see (Config.)configure_default_data_node()^ )), \"csv\" , \"excel\" , \"sql\" , \"in_memory\" , or \"generic\" . 'pickle' scope Scope^ The scope of the data node configuration. The default value is Scope.SCENARIO (or the one specified in (Config.)configure_default_data_node()^ ). <Scope.SCENARIO: 2> **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description DataNodeConfig^ The new data node configuration.","title":"configure_data_node()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.configure_default_data_node","text":"Configure the default values for data node configurations. This function creates the default data node configuration object, where all data node configuration objects will find their default values when needed. Parameters: Name Type Description Default storage_type str The default storage type for all data node configurations. The possible values are \"pickle\" (the default value), \"csv\" , \"excel\" , \"sql\" , \"in_memory\" , or \"generic\" . required scope Scope^ The default scope fot all data node configurations. The default value is Scope.SCENARIO . <Scope.SCENARIO: 2> **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description DataNodeConfig^ The default data node configuration.","title":"configure_default_data_node()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.configure_default_pipeline","text":"Configure the default values for pipeline configurations. This function creates the default pipeline configuration object, where all pipeline configuration objects will find their default values when needed. Parameters: Name Type Description Default task_configs Union[TaskConfig^, List[TaskConfig^]] The list of the task configurations that make the default pipeline configuration. This can be a single task configuration object is this pipeline holds a single task. required **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description PipelineConfig^ The default pipeline configuration.","title":"configure_default_pipeline()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.configure_default_scenario","text":"Configure the default values for scenario configurations. This function creates the default scenario configuration object, where all scenario configuration objects will find their default values when needed. Parameters: Name Type Description Default pipeline_configs List[PipelineConfig^] The list of pipeline configurations used by this scenario configuration. required frequency Optional[Frequency^] The scenario frequency. It corresponds to the recurrence of the scenarios instantiated from this configuration. Based on this frequency each scenario will be attached to the relevant cycle. None comparators Optional[Dict[str, Union[List[Callable], Callable]]] The list of functions used to compare scenarios. A comparator function is attached to a scenario's data node configuration. The key of the dictionary parameter corresponds to the data node configuration id. During the scenarios' comparison, each comparator is applied to all the data nodes instantiated from the data node configuration attached to the comparator. See taipy.compare_scenarios()^ more more details. None **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description ScenarioConfig^ The default scenario configuration.","title":"configure_default_scenario()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.configure_default_task","text":"Configure the default values for task configurations. This function creates the default task configuration object, where all task configuration objects will find their default values when needed. Parameters: Name Type Description Default function Callable The python function called by Taipy to run the task. required input Optional[Union[DataNodeConfig^, List[DataNodeConfig^]]] The list of the input data node configurations. This can be a unique data node configuration if there is a single input data node, or None if there are none. None output Optional[Union[DataNodeConfig^, List[DataNodeConfig^]]] The list of the output data node configurations. This can be a unique data node configuration if there is a single output data node, or None if there are none. None **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description TaskConfig^ The default task configuration.","title":"configure_default_task()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.configure_excel_data_node","text":"Configure a new Excel data node configuration. Parameters: Name Type Description Default id str The unique identifier of the new Excel data node configuration. required path str The path of the Excel file. required has_header bool If True, indicates that the Excel file has a header. True sheet_name Union[List[str], str] The list of sheet names to be used. This can be a unique name. None scope Scope^ The scope of the Excel data node configuration. The default value is Scope.SCENARIO . <Scope.SCENARIO: 2> **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description DataNodeConfig^ The new CSV data node configuration.","title":"configure_excel_data_node()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.configure_generic_data_node","text":"Configure a new generic data node configuration. Parameters: Name Type Description Default id str The unique identifier of the new generic data node configuration. required read_fct Optional[Callable] The Python function called to read the data. None write_fct Optional[Callable] The Python function called to write the data. The provided function must have at least one parameter that receives the data to be written. None read_fct_params Optional[List] The parameters that are passed to read_fct to read the data. None write_fct_params Optional[List] The parameters that are passed to write_fct to write the data. None scope Optional[Scope^] The scope of the Generic data node configuration. The default value is Scope.SCENARIO . <Scope.SCENARIO: 2> **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description DataNodeConfig^ The new Generic data node configuration.","title":"configure_generic_data_node()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.configure_global_app","text":"Configure the global application. Parameters: Name Type Description Default root_folder Optional[str] The path of the base folder for the Taipy application. None storage_folder Optional[str] The folder name used to store Taipy data. It is used in conjunction with the root_folder field: the storage path is \" \". None clean_entities_enabled Optional[str] The field to activate or deactivate the 'clean entities' feature. The default value is False. None Returns: Type Description GlobalAppConfig^ The global application configuration.","title":"configure_global_app()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.configure_in_memory_data_node","text":"Configure a new in_memory data node configuration. Parameters: Name Type Description Default id str The unique identifier of the new in_memory data node configuration. required default_data Optional[Any] The default data of the data nodes instantiated from this in_memory data node configuration. None scope Scope^ The scope of the in_memory data node configuration. The default value is Scope.SCENARIO . <Scope.SCENARIO: 2> **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description DataNodeConfig^ The new in_memory data node configuration.","title":"configure_in_memory_data_node()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.configure_job_executions","text":"Configure job execution. Parameters: Name Type Description Default mode Optional[str] The job execution mode. Possible values are: \"standalone\" (the default value) or \"airflow\" (Enterprise version only). None nb_of_workers Optional[int, str] The maximum number of jobs able to run in parallel. The default value is 1. A string can be provided to dynamically set the value using an environment variable. The string must follow the pattern: ENV[&lt;env_var&gt;] where &lt;env_var&gt; is the name of environment variable. None Returns: Type Description JobConfig^ The job execution configuration.","title":"configure_job_executions()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.configure_pickle_data_node","text":"Configure a new pickle data node configuration. Parameters: Name Type Description Default id str The unique identifier of the new pickle data node configuration. required default_data Optional[Any] The default data of the data nodes instantiated from this pickle data node configuration. None scope Scope^ The scope of the pickle data node configuration. The default value is Scope.SCENARIO . <Scope.SCENARIO: 2> **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description DataNodeConfig^ The new pickle data node configuration.","title":"configure_pickle_data_node()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.configure_pipeline","text":"Configure a new pipeline configuration. Parameters: Name Type Description Default id str The unique identifier of the new pipeline configuration. required task_configs Union[TaskConfig^, List[TaskConfig^]] The list of the task configurations that make this new pipeline. This can be a single task configuration object is this pipeline holds a single task. required **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description PipelineConfig^ The new pipeline configuration.","title":"configure_pipeline()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.configure_scenario","text":"Configure a new scenario configuration. Parameters: Name Type Description Default id str The unique identifier of the new scenario configuration. required pipeline_configs List[PipelineConfig^] The list of pipeline configurations used by this new scenario configuration. required frequency Optional[Frequency^] The scenario frequency. It corresponds to the recurrence of the scenarios instantiated from this configuration. Based on this frequency each scenario will be attached to the relevant cycle. None comparators Optional[Dict[str, Union[List[Callable], Callable]]] The list of functions used to compare scenarios. A comparator function is attached to a scenario's data node configuration. The key of the dictionary parameter corresponds to the data node configuration id. During the scenarios' comparison, each comparator is applied to all the data nodes instantiated from the data node configuration attached to the comparator. See (taipy.)compare_scenarios()^ more more details. None **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description ScenarioConfig^ The new scenario configuration.","title":"configure_scenario()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.configure_scenario_from_tasks","text":"Configure a new scenario configuration made of a single new pipeline configuration. A new pipeline configuration is created as well. If pipeline_id is not provided, the new pipeline configuration identifier is set to the scenario configuration identifier post-fixed by '_pipeline'. Parameters: Name Type Description Default id str The unique identifier of the scenario configuration. required task_configs List[TaskConfig^] The list of task configurations used by the new pipeline configuration that is created. required frequency Optional[Frequency^] The scenario frequency. It corresponds to the recurrence of the scenarios instantiated from this configuration. Based on this frequency each scenario will be attached to the relevant cycle. None comparators Optional[Dict[str, Union[List[Callable], Callable]]] The list of functions used to compare scenarios. A comparator function is attached to a scenario's data node configuration. The key of the dictionary parameter corresponds to the data node configuration id. During the scenarios' comparison, each comparator is applied to all the data nodes instantiated from the data node configuration attached to the comparator. See (taipy.)compare_scenarios() more more details. None pipeline_id str The identifier of the new pipeline configuration to be configured. None **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description ScenarioConfig^ The new scenario configuration.","title":"configure_scenario_from_tasks()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.configure_sql_data_node","text":"Configure a new SQL data node configuration. Parameters: Name Type Description Default id str The unique identifier of the new SQL data node configuration. required db_username str The database username. required db_password str The database password. required db_name str The database name. required db_engine str The database engine. Possible values are \"sqlite\" or \"mssql\" . required read_query str The SQL query string used to read the data from the database. required write_table str The name of the table in the database to write the data to. None db_port int The database port. The default value is 1433. 1433 db_host str The database host. The default value is \"localhost\" . 'localhost' db_driver str The database driver. The default value is \"ODBC Driver 17 for SQL Server\" . 'ODBC Driver 17 for SQL Server' scope Scope^ The scope of the SQL data node configuration. The default value is Scope.SCENARIO . <Scope.SCENARIO: 2> **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description DataNodeConfig^ The new SQL data node configuration.","title":"configure_sql_data_node()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.configure_task","text":"Configure a new task configuration. Parameters: Name Type Description Default id str The unique identifier of this task configuration. required function Callable The python function called by Taipy to run the task. required input Optional[Union[DataNodeConfig^, List[DataNodeConfig^]]] The list of the function input data node configurations. This can be a unique data node configuration if there is a single input data node, or None if there are none. None output Optional[Union[DataNodeConfig^, List[DataNodeConfig^]]] The list of the function output data node configurations. This can be a unique data node configuration if there is a single output data node, or None if there are none. None **properties Dict[str, Any] A keyworded variable length list of additional arguments. {} Returns: Type Description TaskConfig^ The new task configuration.","title":"configure_task()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.export","text":"Export a configuration. The export is done in a toml file. The exported configuration is a compilation from the three possible methods to configure the application: the python code configuration, the file configuration and the environment configuration. Parameters: Name Type Description Default filename Union[str, Path] The path of the file to export. required Note If filename already exists, it is overwritten.","title":"export()"},{"location":"manuals/reference/taipy.Config/#taipy.core.config.config.Config.load","text":"Load a configuration file. Parameters: Name Type Description Default filename Union[str, Path] The path of the toml configuration file to load. required","title":"load()"},{"location":"manuals/reference/taipy.Cycle/","text":"An iteration of a recurrent work pattern. Attributes: Name Type Description id str The unique identifier of the cycle. frequency Frequency^ The frequency of this cycle. creation_date datetime The date and time of the creation of this cycle. start_date datetime The date and time of the start of this cycle. end_date datetime The date and time of the end of this cycle. name str The name of this cycle. properties dict[str, Any] A dictionary of additional properties.","title":"taipy.Cycle"},{"location":"manuals/reference/taipy.DataNode/","text":"Reference to a dataset. A Data Node holds metadata related to the dataset it refers to. In particular, a data node holds the name, the scope, the parent identifier, the last edition date, and some additional properties of the data. A Data Node also contains information and methods needed to access the dataset. This information depends on the type of storage, and it is held by subclasses (such as SQL Data Node, CSV Data Node, ...). Note It is recommended not to instantiate subclasses of DataNode directly. Attributes: Name Type Description config_id str Identifier of the data node configuration. It must be a valid Python identifier. scope Scope^ The scope of this data node. id str The unique identifier of this data node. name str A user-readable name of this data node. parent_id str The identifier of the parent (pipeline_id, scenario_id, cycle_id) or None. last_edition_date datetime The date and time of the last edition. job_ids List[str] The ordered list of jobs that have written this data node. validity_period Optional[timedelta] The validity period of a cacheable data node. Implemented as a timedelta. If validity_period is set to None, the data_node is always up-to-date. edition_in_progress bool True if a task computing the data node has been submitted and not completed yet. False otherwise. kwargs A dictionary of additional properties. is_ready_for_reading property readonly \u00b6 Indicate if this data node is ready for reading. Returns: Type Description bool False if the data is locked for edition or if the data has never been written. True otherwise. filter ( self , operators , join_operator =< JoinOperator . AND : 1 > ) \u00b6 Read the data referenced by the data node, appying a filter. The data is filtered by the provided list of 3-tuples (key, value, Operator^ ). If multiple filter operators are provided, filtered data will be joined based on the join operator ( AND or OR ). Parameters: Name Type Description Default operators Union[List[Tuple], Tuple] TODO required join_operator JoinOperator^ The operator used to join the multiple filter 3-tuples. <JoinOperator.AND: 1> lock_edition ( self ) \u00b6 Lock the edition of this data node. Note The data node can be unlocked with the method (DataNode.)unlock_edition()^ . read ( self ) \u00b6 Read the data referenced by this data node. Returns: Type Description Any The data referenced by this data node. None if the data has not been written yet. read_or_raise ( self ) \u00b6 Read the data referenced by this data node. Returns: Type Description Any The data referenced by this data node. Exceptions: Type Description NoData^ If the data has not been written yet. unlock_edition ( self , at = None , job_id = None ) \u00b6 Unlocks the edition of the data node. The last_edition_date is updated. Parameters: Name Type Description Default at datetime The optional datetime of the last edition. If no at datetime is provided, the current datetime is used. None job_id JobId^ An optional identifier of the writer. None Note The data node can be locked with the method (DataNode.)lock_edition()^ . write ( self , data , job_id = None ) \u00b6 Write some data to this data node. Parameters: Name Type Description Default data Any The data to write to this data node. required job_id JobId^ An optional identifier of the writer. None","title":"taipy.DataNode"},{"location":"manuals/reference/taipy.DataNode/#taipy.core.data.data_node.DataNode.is_ready_for_reading","text":"Indicate if this data node is ready for reading. Returns: Type Description bool False if the data is locked for edition or if the data has never been written. True otherwise.","title":"is_ready_for_reading"},{"location":"manuals/reference/taipy.DataNode/#taipy.core.data.data_node.DataNode.filter","text":"Read the data referenced by the data node, appying a filter. The data is filtered by the provided list of 3-tuples (key, value, Operator^ ). If multiple filter operators are provided, filtered data will be joined based on the join operator ( AND or OR ). Parameters: Name Type Description Default operators Union[List[Tuple], Tuple] TODO required join_operator JoinOperator^ The operator used to join the multiple filter 3-tuples. <JoinOperator.AND: 1>","title":"filter()"},{"location":"manuals/reference/taipy.DataNode/#taipy.core.data.data_node.DataNode.lock_edition","text":"Lock the edition of this data node. Note The data node can be unlocked with the method (DataNode.)unlock_edition()^ .","title":"lock_edition()"},{"location":"manuals/reference/taipy.DataNode/#taipy.core.data.data_node.DataNode.read","text":"Read the data referenced by this data node. Returns: Type Description Any The data referenced by this data node. None if the data has not been written yet.","title":"read()"},{"location":"manuals/reference/taipy.DataNode/#taipy.core.data.data_node.DataNode.read_or_raise","text":"Read the data referenced by this data node. Returns: Type Description Any The data referenced by this data node. Exceptions: Type Description NoData^ If the data has not been written yet.","title":"read_or_raise()"},{"location":"manuals/reference/taipy.DataNode/#taipy.core.data.data_node.DataNode.unlock_edition","text":"Unlocks the edition of the data node. The last_edition_date is updated. Parameters: Name Type Description Default at datetime The optional datetime of the last edition. If no at datetime is provided, the current datetime is used. None job_id JobId^ An optional identifier of the writer. None Note The data node can be locked with the method (DataNode.)lock_edition()^ .","title":"unlock_edition()"},{"location":"manuals/reference/taipy.DataNode/#taipy.core.data.data_node.DataNode.write","text":"Write some data to this data node. Parameters: Name Type Description Default data Any The data to write to this data node. required job_id JobId^ An optional identifier of the writer. None","title":"write()"},{"location":"manuals/reference/taipy.Frequency/","text":"Frequency of the recurrence of Cycle^ and Scenario^ objects. The frequency must be provided in the ScenarioConfig^ . Each recurrent scenario is attached to the cycle corresponding to the creation date and the frequency. In other words, each cycle represents an iteration and contains the various scenarios created during this iteration. For instance, when scenarios have a MONTHLY frequency, one cycle will be created for each month (January, February, March, etc.). A new scenario created on February 10th, gets attached to the February cycle. The frequency is implemented as an enumeration with the following possible values: With a DAILY frequency, a new cycle is created for each day. With a WEEKLY frequency, a new cycle is created for each week (from Monday to Sunday). With a MONTHLY frequency, a new cycle is created for each month. With a QUARTERLY frequency, a new cycle is created for each quarter. With a YEARLY frequency, a new cycle is created for each year.","title":"taipy.Frequency"},{"location":"manuals/reference/taipy.Job/","text":"Execution of a Task^ . A job handles the status of the execution, contains the stacktrace of exceptions that were raised during the execution, and notifies subscribers on status change. Attributes: Name Type Description id str The identifier of this job. task Task^ The task of this job. force bool Enforce the job's execution whatever the output data nodes are in cache or not. status Status^ The current status of this job. creation_date datetime The date of this job's creation. stacktrace List[str] The list of stacktraces of the exceptions raised during the execution. is_blocked ( self ) \u00b6 Indicate if the job is blocked. Returns: Type Description bool True if the job is blocked. is_cancelled ( self ) \u00b6 Indicate if the job was cancelled. Returns: Type Description bool True if the job was cancelled. is_completed ( self ) \u00b6 Indicate if the job has completed. Returns: Type Description bool True if the job has completed. is_failed ( self ) \u00b6 Indicate if the job has failed. Returns: Type Description bool True if the job has failed. is_finished ( self ) \u00b6 Indicate if the job is finished. Returns: Type Description bool True if the job is finished. is_pending ( self ) \u00b6 Indicate if the job is pending. Returns: Type Description bool True if the job is pending. is_running ( self ) \u00b6 Indicate if the job is running. Returns: Type Description bool True if the job is running. is_skipped ( self ) \u00b6 Indicate if the job was skipped. Returns: Type Description bool True if the job was skipped. is_submitted ( self ) \u00b6 Indicate if the job is submitted. Returns: Type Description bool True if the job is submitted. update_status ( self , ft ) \u00b6 Update the job status based on the success or the failure of its execution.","title":"taipy.Job"},{"location":"manuals/reference/taipy.Job/#taipy.core.job.job.Job.is_blocked","text":"Indicate if the job is blocked. Returns: Type Description bool True if the job is blocked.","title":"is_blocked()"},{"location":"manuals/reference/taipy.Job/#taipy.core.job.job.Job.is_cancelled","text":"Indicate if the job was cancelled. Returns: Type Description bool True if the job was cancelled.","title":"is_cancelled()"},{"location":"manuals/reference/taipy.Job/#taipy.core.job.job.Job.is_completed","text":"Indicate if the job has completed. Returns: Type Description bool True if the job has completed.","title":"is_completed()"},{"location":"manuals/reference/taipy.Job/#taipy.core.job.job.Job.is_failed","text":"Indicate if the job has failed. Returns: Type Description bool True if the job has failed.","title":"is_failed()"},{"location":"manuals/reference/taipy.Job/#taipy.core.job.job.Job.is_finished","text":"Indicate if the job is finished. Returns: Type Description bool True if the job is finished.","title":"is_finished()"},{"location":"manuals/reference/taipy.Job/#taipy.core.job.job.Job.is_pending","text":"Indicate if the job is pending. Returns: Type Description bool True if the job is pending.","title":"is_pending()"},{"location":"manuals/reference/taipy.Job/#taipy.core.job.job.Job.is_running","text":"Indicate if the job is running. Returns: Type Description bool True if the job is running.","title":"is_running()"},{"location":"manuals/reference/taipy.Job/#taipy.core.job.job.Job.is_skipped","text":"Indicate if the job was skipped. Returns: Type Description bool True if the job was skipped.","title":"is_skipped()"},{"location":"manuals/reference/taipy.Job/#taipy.core.job.job.Job.is_submitted","text":"Indicate if the job is submitted. Returns: Type Description bool True if the job is submitted.","title":"is_submitted()"},{"location":"manuals/reference/taipy.Job/#taipy.core.job.job.Job.update_status","text":"Update the job status based on the success or the failure of its execution.","title":"update_status()"},{"location":"manuals/reference/taipy.Pipeline/","text":"List of Task^ s and additional attributes representing a set of data processing elements connected as a direct acyclic graph. Attributes: Name Type Description config_id str The identifier of the PipelineConfig^ . properties dict[str, Any] A dictionary of additional properties. tasks List[Task^] The list of Task s. pipeline_id str The Unique identifier of the pipeline. parent_id str The identifier of the parent (scenario_id, cycle_id) or None. submit ( self , callbacks = None , force = False ) \u00b6 Submit the pipeline for execution. All the Task^ s of the pipeline will be submitted for execution. Parameters: Name Type Description Default callbacks List[Callable] The list of callable functions to be called on status change. None force bool Force execution even if the data nodes are in cache. False subscribe ( self , callback ) \u00b6 Subscribe a function to be called on Job^ status change. The subscription is applied to all jobs created from the pipeline's execution. Parameters: Name Type Description Default callback Callable[[Pipeline^, Job^], None] The callable function to be called on status change. required Note Notification will be available only for jobs created after this subscription. unsubscribe ( self , callback ) \u00b6 Unsubscribe a function that is called when the status of a Job^ changes. Parameters: Name Type Description Default callback Callable[[Pipeline^, Job^], None] The callable function to unsubscribe. required Note The function will continue to be called for ongoing jobs.","title":"taipy.Pipeline"},{"location":"manuals/reference/taipy.Pipeline/#taipy.core.pipeline.pipeline.Pipeline.submit","text":"Submit the pipeline for execution. All the Task^ s of the pipeline will be submitted for execution. Parameters: Name Type Description Default callbacks List[Callable] The list of callable functions to be called on status change. None force bool Force execution even if the data nodes are in cache. False","title":"submit()"},{"location":"manuals/reference/taipy.Pipeline/#taipy.core.pipeline.pipeline.Pipeline.subscribe","text":"Subscribe a function to be called on Job^ status change. The subscription is applied to all jobs created from the pipeline's execution. Parameters: Name Type Description Default callback Callable[[Pipeline^, Job^], None] The callable function to be called on status change. required Note Notification will be available only for jobs created after this subscription.","title":"subscribe()"},{"location":"manuals/reference/taipy.Pipeline/#taipy.core.pipeline.pipeline.Pipeline.unsubscribe","text":"Unsubscribe a function that is called when the status of a Job^ changes. Parameters: Name Type Description Default callback Callable[[Pipeline^, Job^], None] The callable function to unsubscribe. required Note The function will continue to be called for ongoing jobs.","title":"unsubscribe()"},{"location":"manuals/reference/taipy.Scenario/","text":"Instance of a Business case to solve. A scenario holds a list of pipelines (instances of Pipeline^ class) to submit for execution in order to solve the Business case. Attributes: Name Type Description config_id str The identifier of the ScenarioConfig^ . pipelines List[Pipeline^] The list of pipelines. properties dict[str, Any] A dictionary of additional properties. scenario_id str The unique identifier of this scenario. creation_date datetime The date and time of the scenario's creation. is_primary bool True if the scenario is the primary of its cycle. False otherwise. cycle Cycle^ The cycle of the scenario. subscribers Set[Callable] The set of callbacks to be called on Job^ 's status change. tags Set[str] The list of scenario's tags. add_tag ( self , tag ) \u00b6 Add a tag to this scenario. If the scenario's cycle already have another scenario tagged with tag the other scenario will be untagged. Parameters: Name Type Description Default tag str The tag to add to this scenario. required has_tag ( self , tag ) \u00b6 Indicate if the scenario has a given tag. Parameters: Name Type Description Default tag str The tag to search among the set of scenario's tags. required Returns: Type Description bool True if the scenario has the tag given as parameter. False otherwise. remove_tag ( self , tag ) \u00b6 Remove a tag from this scenario. Parameters: Name Type Description Default tag str The tag to remove from the set of the scenario's tags. required set_primary ( self ) \u00b6 Promote the scenario as the primary scenario of its cycle. If the cycle already has a primary scenario, it will be demoted, and it will no longer be primary for the cycle. submit ( self , force = False ) \u00b6 Submit this scenario for execution. All the Task^ s of the scenario will be submitted for execution. Parameters: Name Type Description Default force bool Force execution even if the data nodes are in cache. False subscribe ( self , callback ) \u00b6 Subscribe a function to be called on Job^ status change. The subscription is applied to all jobs created from the scenario's execution. Parameters: Name Type Description Default callback Callable[[Scenario^, Job^], None] The callable function to be called on status change. required Note Notification will be available only for jobs created after this subscription. unsubscribe ( self , callback ) \u00b6 Unsubscribe a function that is called when the status of a Job^ changes. Parameters: Name Type Description Default callback Callable[[Scenario^, Job^], None] The callable function to unsubscribe. required Note The function will continue to be called for ongoing jobs.","title":"taipy.Scenario"},{"location":"manuals/reference/taipy.Scenario/#taipy.core.scenario.scenario.Scenario.add_tag","text":"Add a tag to this scenario. If the scenario's cycle already have another scenario tagged with tag the other scenario will be untagged. Parameters: Name Type Description Default tag str The tag to add to this scenario. required","title":"add_tag()"},{"location":"manuals/reference/taipy.Scenario/#taipy.core.scenario.scenario.Scenario.has_tag","text":"Indicate if the scenario has a given tag. Parameters: Name Type Description Default tag str The tag to search among the set of scenario's tags. required Returns: Type Description bool True if the scenario has the tag given as parameter. False otherwise.","title":"has_tag()"},{"location":"manuals/reference/taipy.Scenario/#taipy.core.scenario.scenario.Scenario.remove_tag","text":"Remove a tag from this scenario. Parameters: Name Type Description Default tag str The tag to remove from the set of the scenario's tags. required","title":"remove_tag()"},{"location":"manuals/reference/taipy.Scenario/#taipy.core.scenario.scenario.Scenario.set_primary","text":"Promote the scenario as the primary scenario of its cycle. If the cycle already has a primary scenario, it will be demoted, and it will no longer be primary for the cycle.","title":"set_primary()"},{"location":"manuals/reference/taipy.Scenario/#taipy.core.scenario.scenario.Scenario.submit","text":"Submit this scenario for execution. All the Task^ s of the scenario will be submitted for execution. Parameters: Name Type Description Default force bool Force execution even if the data nodes are in cache. False","title":"submit()"},{"location":"manuals/reference/taipy.Scenario/#taipy.core.scenario.scenario.Scenario.subscribe","text":"Subscribe a function to be called on Job^ status change. The subscription is applied to all jobs created from the scenario's execution. Parameters: Name Type Description Default callback Callable[[Scenario^, Job^], None] The callable function to be called on status change. required Note Notification will be available only for jobs created after this subscription.","title":"subscribe()"},{"location":"manuals/reference/taipy.Scenario/#taipy.core.scenario.scenario.Scenario.unsubscribe","text":"Unsubscribe a function that is called when the status of a Job^ changes. Parameters: Name Type Description Default callback Callable[[Scenario^, Job^], None] The callable function to unsubscribe. required Note The function will continue to be called for ongoing jobs.","title":"unsubscribe()"},{"location":"manuals/reference/taipy.Scope/","text":"Scope of a DataNode^ . This enumeration can have the following values: GLOBAL CYCLE SCENARIO PIPELINE","title":"taipy.Scope"},{"location":"manuals/reference/taipy.Status/","text":"Execution status of a Job^ . It is implemented as an enumeration. The possible values are: SUBMITTED : A SUBMITTED job has been submitted for execution but not processed yet by the scheduler. PENDING : A PENDING job has been enqueued by the scheduler. It is waiting for an executor to be available for its execution. BLOCKED : A BLOCKED job has been blocked because its input data nodes are not ready yet. It is waiting for the completion of another Job^ RUNNING : A RUNNING job is currently executed by a dedicated executor. CANCELLED : A CANCELLED job has been submitted but its execution has been cancelled. FAILED : A FAILED job raised an exception during its execution. COMPLETED : A COMPLETED job has successfully been executed. SKIPPED : A SKIPPED job has not been executed because its outputs were already computed.","title":"taipy.Status"},{"location":"manuals/reference/taipy.Task/","text":"Hold a user function that will be executed, its parameters and the results. A Task brings together the user code as function, the inputs and the outputs as data nodes (instances of the DataNode^ class). Attributes: Name Type Description config_id str The identifier of the TaskConfig^ . function callable The python function to execute. The function must take as parameter the data referenced by inputs data nodes, and must return the data referenced by outputs data nodes. input Union[DataNode^, List[DataNode^]] The list of inputs. output Union[DataNode^, List[DataNode^]] The list of outputs. id str The unique identifier of the task. parent_id str The identifier of the parent (pipeline_id, scenario_id, cycle_id) or None. scope : Scope property readonly \u00b6 Retrieve the lowest scope of the task based on its data nodes. Returns: Type Description Scope^ Lowest scope present in input and output data nodes or GLOBAL if there are either no input or no output. submit ( self , callbacks = None , force = False ) \u00b6 Submit the task for execution. Parameters: Name Type Description Default callbacks List[Callable] The list of callable functions to be called on status change. None force bool Force execution even if the data nodes are in cache. False","title":"taipy.Task"},{"location":"manuals/reference/taipy.Task/#taipy.core.task.task.Task.scope","text":"Retrieve the lowest scope of the task based on its data nodes. Returns: Type Description Scope^ Lowest scope present in input and output data nodes or GLOBAL if there are either no input or no output.","title":"scope"},{"location":"manuals/reference/taipy.Task/#taipy.core.task.task.Task.submit","text":"Submit the task for execution. Parameters: Name Type Description Default callbacks List[Callable] The list of callable functions to be called on status change. None force bool Force execution even if the data nodes are in cache. False","title":"submit()"},{"location":"manuals/reference/taipy.clean_all_entities/","text":"Delete all entities from the Taipy data folder. Important Invoking this function is only recommended for development purposes. Returns: Type Description bool True if the operation succeeded, False otherwise.","title":"Taipy.clean all entities"},{"location":"manuals/reference/taipy.compare_scenarios/","text":"Compare the data nodes of several scenarios. You can specify which data node config identifier should the comparison be performed on. Parameters: Name Type Description Default scenarios *Scenario^ The list of the scenarios to compare. () data_node_config_id Optional[str] Config identifier of the DataNode to compare scenarios. if datanode_config_id is None, the scenarios are compared based on all the defined comparators. None Returns: Type Description Dict[str, Any] The comparison results. The key is the data node config identifier that is compared. Exceptions: Type Description InsufficientScenarioToCompare^ Only one or no scenario for comparison is provided. NonExistingComparator^ The scenario comparator does not exist. DifferentScenarioConfigs^ scenarios do not share the same scenario config. NonExistingScenarioConfig^ The scenario config of the provided scenarios could not be found.","title":"Taipy.compare scenarios"},{"location":"manuals/reference/taipy.core.config.DataNodeConfig/","text":"Configuration fields needed to instantiate an actual DataNode^ from the DataNodeConfig. A Data Node config is made to be used as a generator for actual data nodes. It holds configuration information needed to create an actual data node. Attributes: Name Type Description id str Unique identifier of the data node config. It must be a valid Python variable name. storage_type str Storage type of the data nodes created from the data node config. The possible values are : \"csv\", \"excel\", \"pickle\", \"sql\", \"generic\" and \"In_memory\". The default value is \"pickle\". Note that the \"in_memory\" value can only be used when JobConfig^ .mode is \"standalone\". scope Scope^ The Scope^ of the data nodes instantiated from the data node config. The default value is SCENARIO. **properties A dictionary of additional properties.","title":"taipy.core.config.DataNodeConfig"},{"location":"manuals/reference/taipy.core.config.GlobalAppConfig/","text":"Configuration fields related to the global application. Parameters: Name Type Description Default root_folder str Path of the base folder for the taipy application. The default value is \"./taipy/\" None storage_folder str Folder name used to store Taipy data. The default value is \".data/\". It is used in conjunction with the root_folder field. That means the storage path is (The Default path is \"./taipy/.data/\"). None clean_entities_enabled bool Boolean field to activate/deactivate the clean entities feature. Default: false None **properties A dictionary of additional properties. {}","title":"taipy.core.config.GlobalAppConfig"},{"location":"manuals/reference/taipy.core.config.Issue/","text":"An issue detected in the configuration. Attributes: Name Type Description level str Level of the issue among ERROR, WARNING, INFO. field str Configuration field on which the issue has been detected. value Any Value of the field on which the issue has been detected. message str Human readable message to help the user fix the issue. tag Optional[str] Optional tag to be used to filter issues.","title":"taipy.core.config.Issue"},{"location":"manuals/reference/taipy.core.config.IssueCollector/","text":"A collection of issues (instances of class Issue^ ). Attributes: Name Type Description errors List[Issue^] List of ERROR issues collected. warnings List[Issue^] List WARNING issues collected. infos List[Issue^] List INFO issues collected. all List[Issue^] List of all issues collected ordered by decreasing level (ERROR, WARNING and INFO).","title":"taipy.core.config.IssueCollector"},{"location":"manuals/reference/taipy.core.config.JobConfig/","text":"Configuration fields related to the jobs' executions. Parameters: Name Type Description Default mode str The Taipy operating mode. By default, the \"standalone\" mode is set. On Taipy enterprise, the \"airflow\" mode is available. None nb_of_workers int The maximum number of running workers to execute jobs. It must be a positive integer. The default value is 1. None **properties A dictionary of additional properties. {} is_multiprocess : bool property readonly \u00b6 True if the config is set to standalone execution and nb_of_workers is greater than 1 is_standalone : bool property readonly \u00b6 True if the config is set to standalone execution","title":"taipy.core.config.JobConfig"},{"location":"manuals/reference/taipy.core.config.JobConfig/#taipy.core.config.job_config.JobConfig.is_multiprocess","text":"True if the config is set to standalone execution and nb_of_workers is greater than 1","title":"is_multiprocess"},{"location":"manuals/reference/taipy.core.config.JobConfig/#taipy.core.config.job_config.JobConfig.is_standalone","text":"True if the config is set to standalone execution","title":"is_standalone"},{"location":"manuals/reference/taipy.core.config.PipelineConfig/","text":"Configuration fields needed to instantiate an actual Pipeline^ from the PipelineConfig. Attributes: Name Type Description id str Identifier of the pipeline configuration. It must be a valid Python variable name. task_configs `TaskConfig^` or List[`TaskConfig^`] List of task configs. The default value is []. **properties A dictionary of additional properties.","title":"taipy.core.config.PipelineConfig"},{"location":"manuals/reference/taipy.core.config.ScenarioConfig/","text":"Holds all the configuration fields needed to instantiate an actual Scenario^ from the ScenarioConfig . Attributes: Name Type Description id str Identifier of the scenario config. It must be a valid Python variable name. pipeline_configs `PipelineConfig^` or List[`PipelineConfig^`] List of pipeline configs. The default value is []. **properties A dictionary of additional properties.","title":"taipy.core.config.ScenarioConfig"},{"location":"manuals/reference/taipy.core.config.TaskConfig/","text":"Holds all the configuration fields needed to create an actual Task^ from the TaskConfig . Attributes: Name Type Description id str Identifier of the task config. Must be a valid Python variable name. inputs DataNodeConfig or List[DataNodeConfig] The optional list of DataNodeConfig^ inputs. The default value is []. outputs DataNodeConfig or List[DataNodeConfig] The optional list of DataNodeConfig^ outputs. The default value is []. function Callable User function taking as inputs some parameters compatible with the exposed types (exposed_type field) of the input data nodes and returning results compatible with the exposed types (exposed_type field) of the outputs list. The default value is None. **properties A dictionary of additional properties.","title":"taipy.core.config.TaskConfig"},{"location":"manuals/reference/taipy.core.data.CSVDataNode/","text":"Data Node stored as a CSV file. Attributes: Name Type Description config_id str Identifier of the data node configuration. This string must be a valid Python identifier. scope Scope^ The scope of this data node. id str The unique identifier of this data node. name str A user-readable name of this data node. parent_id str The identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date datetime The date and time of the last edition. job_ids List[str] The ordered list of jobs that have written this data node. validity_period Optional[timedelta] The validity period of a cacheable data node. Implemented as a timedelta. If validity_period is set to None, the data_node is always up-to-date. edition_in_progress bool True if a task computing the data node has been submitted and not completed yet. False otherwise. properties dict[str, Any] A dictionary of additional properties. Note that the properties parameter must at least contain a \"path\" entry representing the path of the CSV file. write_with_column_names ( self , data , columns = None , job_id = None ) \u00b6 Write a selection of columns. Parameters: Name Type Description Default data Any The data to write. required columns List[str] The list of column names to write. None job_id JobId^ An optional identifier of the writer. None","title":"taipy.core.data.CSVDataNode"},{"location":"manuals/reference/taipy.core.data.CSVDataNode/#taipy.core.data.csv.CSVDataNode.write_with_column_names","text":"Write a selection of columns. Parameters: Name Type Description Default data Any The data to write. required columns List[str] The list of column names to write. None job_id JobId^ An optional identifier of the writer. None","title":"write_with_column_names()"},{"location":"manuals/reference/taipy.core.data.ExcelDataNode/","text":"Data Node stored as an Excel file. The Excel file format is xlsx . Attributes: Name Type Description config_id str Identifier of this data node configuration. It must be a valid Python identifier. scope Scope^ The scope of this data node. id str The unique identifier of this data node. name str A user-readable name of this data node. parent_id str The identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date datetime The date and time of the last edition. job_ids List[str] The ordered list of jobs that have written this data node. validity_period Optional[timedelta] The validity period of a cacheable data node. Implemented as a timedelta. If validity_period is set to None, the data node is always up-to-date. edition_in_progress bool True if a task computing the data node has been submitted and not completed yet. False otherwise. properties dict[str, Any] A dictionary of additional properties. Note that the properties parameter must at least contain a \"path\" entry representing the path of the Excel file (xlsx format). write_with_column_names ( self , data , columns = None , job_id = None ) \u00b6 Write a set of columns. Parameters: Name Type Description Default data Any The data to write. required columns List[str] The list of column names to write. None job_id JobId^ An optional identifier of the writer. None","title":"taipy.core.data.ExcelDataNode"},{"location":"manuals/reference/taipy.core.data.ExcelDataNode/#taipy.core.data.excel.ExcelDataNode.write_with_column_names","text":"Write a set of columns. Parameters: Name Type Description Default data Any The data to write. required columns List[str] The list of column names to write. None job_id JobId^ An optional identifier of the writer. None","title":"write_with_column_names()"},{"location":"manuals/reference/taipy.core.data.GenericDataNode/","text":"Generic Data Node that uses custom read and write functions. The read and write function for this data node type can be implemented is Python. Attributes: Name Type Description config_id str Identifier of the data node configuration. It must be a valid Python identifier. scope Scope^ The scope of this data node. id str The unique identifier of the data node. name str A user-readable name of the data node. parent_id str The identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date datetime The date and time of the last edition. job_ids List[str] The ordered list of jobs that have written this data node. validity_period Optional[timedelta] The validity period of a cacheable data node. Implemented as a timedelta. If validity_period is set to None, the data node is always up-to-date. edition_in_progress bool True if a task computing the data node has been submitted and not completed yet. False otherwise. properties dict[str, Any] A dictionary of additional properties. Note that the properties parameter must at least contain an entry for \"read_fct\" or \"write_fct\" representing the read and write functions. Entries for \"read_fct_params\" and \"write_fct_params\" respectively represent potential parameters for the \"read_fct\" and \"write_fct\" functions.","title":"taipy.core.data.GenericDataNode"},{"location":"manuals/reference/taipy.core.data.InMemoryDataNode/","text":"Data Node stored in memory. Warning This Data Node implementation is not compatible with a parallel execution of taipy tasks, but only with a Synchronous task executor. The purpose of InMemoryDataNode is to be used for development or debugging. Attributes: Name Type Description config_id str Identifier of the data node configuration. It must be a valid Python identifier. scope Scope^ The scope of this data node. id str The unique identifier of this data node. name str A user-readable name of this data node. parent_id str The identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date datetime The date and time of the last edition. job_ids List[str] The ordered list of jobs that have written this data node. validity_period Optional[timedelta] The validity period of a cacheable data node. Implemented as a timedelta. If validity_period is set to None, the data_node is always up-to-date. edition_in_progress bool True if a task computing the data node has been submitted and not completed yet. False otherwise. properties dict[str, Any] A dictionary of additional properties. When creating an In Memory data node, if the properties dictionary contains a \"default_data\" entry, the data node is automatically written with the corresponding \"default_data\" value.","title":"taipy.core.data.InMemoryDataNode"},{"location":"manuals/reference/taipy.core.data.PickleDataNode/","text":"Data Node stored as a pickle file. Attributes: Name Type Description config_id str Identifier of the data node configuration. It must be a valid Python identifer. scope Scope^ The scope of this data node. id str The unique identifier of this data node. name str A user-readable name of this data node. parent_id str The identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date datetime The date and time of the last edition. job_ids List[str] The ordered list of jobs that have written this data node. validity_period Optional[timedelta] The validity period of a cacheable data node. Implemented as a timedelta. If validity_period is set to None, the data_node is always up-to-date. edition_in_progress bool True if a task computing the data node has been submitted and not completed yet. False otherwise. properties dict[str, Any] A dictionary of additional properties. When creating a pickle data node, if the properties dictionary contains a \"default_data\" entry, the data node is automatically written with the corresponding \"default_data\" value. If the properties dictionary contains a \"path\" entry, the data will be stored using the corresponding value as the name of the pickle file.","title":"taipy.core.data.PickleDataNode"},{"location":"manuals/reference/taipy.core.data.SQLDataNode/","text":"Data Node stored in a SQL database. Attributes: Name Type Description config_id str Identifier of the data node configuration. It must be a valid Python identifier. scope Scope^ The scope of this data node. id str The unique identifier of this data node. name str A user-readable name of this data node. parent_id str The identifier of the parent (pipeline_id, scenario_id, cycle_id) or None. last_edition_date datetime The date and time of the last edition. job_ids List[str] The ordered list of jobs that have written this data node. validity_period Optional[timedelta] The validity period of a cacheable data node. Implemented as a timedelta. If validity_period is set to None, the data_node is always up-to-date. edition_in_progress bool True if a task computing the data node has been submitted and not completed yet. False otherwise. properties dict[str, Any] A dictionary of additional properties. Note that the properties parameter must at least contain an entry for \"db_username\" , \"db_password\" , \"db_name\" , \"db_engine\" , \"read_query\" , and \"write_table\" . For now, the accepted values for the \"db_engine\" property are \"mssql\" and \"sqlite\" .","title":"taipy.core.data.SQLDataNode"},{"location":"manuals/reference/taipy.core.data.operator.JoinOperator/","text":"Enumeration of join operators for Data Node filtering. The possible values are AND and OR .","title":"taipy.core.data.operator.JoinOperator"},{"location":"manuals/reference/taipy.core.data.operator.Operator/","text":"Enumeration of operators for Data Node filtering. The possible values are: EQUAL NOT_EQUAL LESS_THAN LESS_OR_EQUAL GREATER_THAN GREATER_OR_EQUAL","title":"taipy.core.data.operator.Operator"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.ConfigurationIssueError/","text":"Raised if an inconsistency has been detected in the configuration.","title":"taipy.core.exceptions.exceptions.ConfigurationIssueError"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.CycleAlreadyExists/","text":"Raised if it is trying to create a Cycle that has already exists.","title":"taipy.core.exceptions.exceptions.CycleAlreadyExists"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.DataNodeWritingError/","text":"Raised if an error happens during the writing in a data node.","title":"taipy.core.exceptions.exceptions.DataNodeWritingError"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.DeletingPrimaryScenario/","text":"Raised if a primary scenario is deleted.","title":"taipy.core.exceptions.exceptions.DeletingPrimaryScenario"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.DependencyNotInstalled/","text":"Raised if a package is missing.","title":"taipy.core.exceptions.exceptions.DependencyNotInstalled"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.DifferentScenarioConfigs/","text":"Raised if scenario comparison is requested on scenarios with different scenario configs. This exception can be raised by taipy.compare_scenarios()^ .","title":"taipy.core.exceptions.exceptions.DifferentScenarioConfigs"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.DoesNotBelongToACycle/","text":"Raised if a scenario without any cycle is promoted as primary scenario.","title":"taipy.core.exceptions.exceptions.DoesNotBelongToACycle"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.InconsistentEnvVariableError/","text":"Inconsistency value has been detected in an environment variable referenced by the configuration.","title":"taipy.core.exceptions.exceptions.InconsistentEnvVariableError"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.InsufficientScenarioToCompare/","text":"Raised if too few scenarios are requested to be compared. Scenario comparison need at least two scenarios to compare. This exception can be raised by taipy.compare_scenarios()^ .","title":"taipy.core.exceptions.exceptions.InsufficientScenarioToCompare"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.InvalidConfigurationId/","text":"Configuration id is not valid.","title":"taipy.core.exceptions.exceptions.InvalidConfigurationId"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.InvalidDataNodeType/","text":"Raised if a data node storage type does not exist.","title":"taipy.core.exceptions.exceptions.InvalidDataNodeType"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.InvalidSubscriber/","text":"Raised if we try to load a function that is not valid.","title":"taipy.core.exceptions.exceptions.InvalidSubscriber"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.JobNotDeletedException/","text":"Raised if we try to delete a job that cannot be deleted. This exception can be raised by taipy.delete_job()^ .","title":"taipy.core.exceptions.exceptions.JobNotDeletedException"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.LoadingError/","text":"Raised if an error occurs while loading the configuration file.","title":"taipy.core.exceptions.exceptions.LoadingError"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.MissingEnvVariableError/","text":"Environment variable referenced in configuration is missing.","title":"taipy.core.exceptions.exceptions.MissingEnvVariableError"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.MissingReadFunction/","text":"Raised if no read function is provided for the GenericDataNode.","title":"taipy.core.exceptions.exceptions.MissingReadFunction"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.MissingRequiredProperty/","text":"Raised if a required property is missing when creating a Data Node.","title":"taipy.core.exceptions.exceptions.MissingRequiredProperty"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.MissingWriteFunction/","text":"Raised if no write function is provided for the GenericDataNode.","title":"taipy.core.exceptions.exceptions.MissingWriteFunction"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.ModelNotFound/","text":"Raised when trying to fetch a non-existent model. This exception can be raised by taipy.get()^ and taipy.delete()^ .","title":"taipy.core.exceptions.exceptions.ModelNotFound"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.MultipleDataNodeFromSameConfigWithSameParent/","text":"Raised if there are multiple data nodes from the same data node configuration and the same parent identifier.","title":"taipy.core.exceptions.exceptions.MultipleDataNodeFromSameConfigWithSameParent"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.MultiplePipelineFromSameConfigWithSameParent/","text":"Raised if it exists multiple pipelines from the same pipeline config and with the same parent_id .","title":"taipy.core.exceptions.exceptions.MultiplePipelineFromSameConfigWithSameParent"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.MultipleTaskFromSameConfigWithSameParent/","text":"Raised if there are multiple tasks from the same task configuration and the same parent identifier.","title":"taipy.core.exceptions.exceptions.MultipleTaskFromSameConfigWithSameParent"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.NoData/","text":"Raised if a data node is read before it has been written. This exception can be raised by DataNode.read_or_raise()^ .","title":"taipy.core.exceptions.exceptions.NoData"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.NonExistingComparator/","text":"Raised if a scenario comparator does not exist. This exception can be raised by taipy.compare_scenarios()^ .","title":"taipy.core.exceptions.exceptions.NonExistingComparator"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.NonExistingCycle/","text":"Raised if we request a cycle not known by the cycle manager.","title":"taipy.core.exceptions.exceptions.NonExistingCycle"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.NonExistingDataNode/","text":"Raised if a requested DataNode is not known by the DataNode Manager.","title":"taipy.core.exceptions.exceptions.NonExistingDataNode"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.NonExistingExcelSheet/","text":"Raised if a requested Sheet name does not exist in the provided Excel file.","title":"taipy.core.exceptions.exceptions.NonExistingExcelSheet"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.NonExistingJob/","text":"Raised if we try to get a job that does not exist.","title":"taipy.core.exceptions.exceptions.NonExistingJob"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.NonExistingPipeline/","text":"Raised if a requested Pipeline is not known by the Pipeline Manager.","title":"taipy.core.exceptions.exceptions.NonExistingPipeline"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.NonExistingPipelineConfig/","text":"Raised if a requested Pipeline configuration is not known by the Pipeline Manager.","title":"taipy.core.exceptions.exceptions.NonExistingPipelineConfig"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.NonExistingScenario/","text":"Raised if a requested scenario is not known by the Scenario Manager.","title":"taipy.core.exceptions.exceptions.NonExistingScenario"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.NonExistingScenarioConfig/","text":"Raised if a requested scenario configuration is not known by the Scenario Manager. This exception can be raised by taipy.compare_scenarios()^ .","title":"taipy.core.exceptions.exceptions.NonExistingScenarioConfig"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.NonExistingTask/","text":"Raised if a requested task is not known by the Task Manager.","title":"taipy.core.exceptions.exceptions.NonExistingTask"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.NonExistingTaskConfig/","text":"Raised if a requested task configuration is not known by the Task Manager.","title":"taipy.core.exceptions.exceptions.NonExistingTaskConfig"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.NotMatchSheetNameAndCustomObject/","text":"Raised if a provided list of sheet names does not match with the provided list of custom objects.","title":"taipy.core.exceptions.exceptions.NotMatchSheetNameAndCustomObject"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.UnauthorizedTagError/","text":"Must provide an authorized tag.","title":"taipy.core.exceptions.exceptions.UnauthorizedTagError"},{"location":"manuals/reference/taipy.core.exceptions.exceptions.UnknownDatabaseEngine/","text":"Raised if the database engine is not known when creating a connection with a SQLDataNode.","title":"taipy.core.exceptions.exceptions.UnknownDatabaseEngine"},{"location":"manuals/reference/taipy.create_pipeline/","text":"Create and return a new pipeline from a pipeline configuration. Parameters: Name Type Description Default config PipelineConfig^ The pipeline configuration. required Returns: Type Description Pipeline^ The new pipeline.","title":"Taipy.create pipeline"},{"location":"manuals/reference/taipy.create_scenario/","text":"Create and return a new scenario from a scenario configuration. If the scenario belongs to a work cycle, a cycle (corresponding to the creation_date and the configuration frequency attribute) is created if it does not exist yet. Parameters: Name Type Description Default config ScenarioConfig^ The scenario configuration. required creation_date Optional[datetime.datetime] The creation date of the scenario. If None, the current date time is used. None name Optional[str] The displayable name of the scenario. None Returns: Type Description Scenario^ The new scenario.","title":"Taipy.create scenario"},{"location":"manuals/reference/taipy.delete/","text":"Delete an entity and its nested entities. The given entity is deleted. The deletion is propagated to all nested entities that are not shared by another entity. If a CycleId^ is provided, the nested scenarios, pipelines, data nodes, and jobs are deleted. If a ScenarioId^ is provided, the nested pipelines, tasks, data nodes, and jobs are deleted. If a PipelineId^ is provided, the nested tasks, data nodes, and jobs are deleted. If a TaskId^ is provided, the nested data nodes, and jobs are deleted. Parameters: Name Type Description Default entity_id Union[TaskId^, DataNodeId^, PipelineId^, ScenarioId^, JobId^, CycleId^] The identifier of the entity to delete. required Exceptions: Type Description ModelNotFound^ No entity corresponds to entity_id .","title":"Taipy.delete"},{"location":"manuals/reference/taipy.delete_job/","text":"Delete a job. Parameters: Name Type Description Default job Job^ The job to delete. required force Optional[bool] If True, forces the deletion of job , even if it is not completed yet. False Exceptions: Type Description JobNotDeletedException^ If the job is not finished.","title":"Taipy.delete job"},{"location":"manuals/reference/taipy.delete_jobs/","text":"Delete all jobs.","title":"Taipy.delete jobs"},{"location":"manuals/reference/taipy.get/","text":"Get an entity from its identifier. Parameters: Name Type Description Default entity_id Union[TaskId^, DataNodeId^, PipelineId^, ScenarioId^] The identifier of the entity to get. It must match the identifier pattern of one of the entities ( Task^ , DataNode^ , Pipeline^ or Scenario^ ). required Returns: Type Description Union[Task^, DataNode^, Pipeline^, Scenario^, Job^, Cycle^] The entity matching the corresponding identifier. None if no entity is found. Exceptions: Type Description ModelNotFound^ If entity_id does not match a correct entity pattern.","title":"Taipy.get"},{"location":"manuals/reference/taipy.get_cycles/","text":"Return the list of all existing cycles. Returns: Type Description List[Cycle^] The list of all cycles.","title":"Taipy.get cycles"},{"location":"manuals/reference/taipy.get_data_nodes/","text":"Return all the existing data nodes. Returns: Type Description List[DataNode^] The list of all data nodes.","title":"Taipy.get data nodes"},{"location":"manuals/reference/taipy.get_jobs/","text":"Return all the existing jobs. Returns: Type Description List[Job^] The list of all jobs.","title":"Taipy.get jobs"},{"location":"manuals/reference/taipy.get_latest_job/","text":"Return the latest job of a task. Parameters: Name Type Description Default task Task^ The task to retrieve the latest job from. required Returns: Type Description Optional[Job^] The latest job created from task . This is None if no job has been created from task .","title":"Taipy.get latest job"},{"location":"manuals/reference/taipy.get_pipelines/","text":"Return all existing pipelines. Returns: Type Description List[Pipeline^] The list of all pipelines.","title":"Taipy.get pipelines"},{"location":"manuals/reference/taipy.get_primary/","text":"Return the primary scenario of a cycle. Parameters: Name Type Description Default cycle Cycle^ The cycle of the primary scenario to return. required Returns: Type Description Optional[Scenario^] The primary scenario of the cycle cycle . If the cycle has no primary scenario, this method returns None.","title":"Taipy.get primary"},{"location":"manuals/reference/taipy.get_primary_scenarios/","text":"Return the list of all primary scenarios. Returns: Type Description List[Scenario^] The list of all primary scenarios.","title":"Taipy.get primary scenarios"},{"location":"manuals/reference/taipy.get_scenarios/","text":"Return the list of all existing scenarios filtered by a cycle or a tag. If both cycle and tag are provided, the returned list contains scenarios that belong to cycle and that hold the tag tag . Parameters: Name Type Description Default cycle Optional[Cycle^] Cycle of the scenarios to return. None tag Optional[str] Tag of the scenarios to return. None Returns: Type Description List[Scenario^] The list of scenarios filtered by cycle or tag.","title":"Taipy.get scenarios"},{"location":"manuals/reference/taipy.get_tasks/","text":"Return the list of all existing tasks. Returns: Type Description List[Task^] The list of tasks.","title":"Taipy.get tasks"},{"location":"manuals/reference/taipy.gui.Gui/","text":"Entry point for the Graphical User Interface generation. Attributes: Name Type Description on_action Callable The function that is called when a control triggers an action, as the result of an interaction with the end-user. It defaults to the on_action() global function defined in the Python application. If there is no such function, actions will not trigger anything. on_change Callable The function that is called when a control modifies variables it is bound to, as the result of an interaction with the end-user. It defaults to the on_change() global function defined in the Python application. If there is no such function, user interactions will not trigger anything. on_init Callable The function that is called on the first connection of a new user. It defaults to the on_init() global function defined in the Python application. state State^ Only defined when running in an IPython notebook context. The unique instance of State^ that you can use to change bound variables directly, potentially impacting the interface in real-time. Note This class belong to and is documented in the taipy.gui package but it is accessible from the top taipy package to simplify its access, allowing to use: from taipy import Gui __init__ ( self , page = None , pages = None , css_file = '__main__' , path_mapping = {}, env_filename = None , flask = None ) special \u00b6 Initialize a new Gui instance. Parameters: Name Type Description Default page Optional[Union[str, Page^]] An optional Page^ instance that is used when there is a single page in this interface, referenced as the root page (located at / ). If page is a raw string and if it holds a path to a readable file then a Markdown^ page is built from the content of that file. If page is a string that does not indicate a path to readable file then a Markdown^ page is built from that string. Note that if pages is provided, those pages are added as well. None pages Optional[dict] Used if you want to initialize this instance with a set of pages. The method (Gui.)add_pages(pages)^ is called if pages is not None. You can find details on the possible values of this argument in the documentation for this method. None css_file str An optional pathname to a CSS file that gets used as a style sheet in all the pages. The default value is a file that has the same base name as the Python file defining the main function, sitting next to this Python file, with the .css extension. '__main__' path_mapping Optional[dict] A dictionary that associates a URL prefix to a path in the server filesystem. If the assets of your application are located in /home/me/app_assets and you want to access them with just assets in your application, you can set path_mapping={\"assets\": \"/home/me/app_assets\"} . If your application then requests the file \"/assets/images/logo.png\" , the server searches for the file \"/home/me/app_assets/images/logo.png\" . {} env_filename Optional[str] An optional file from which to load application configuration variables (see the Configuration section of the User Manual for details.) The default value is \"taipy.gui.env\" None flask Optional[Flask] An optional instance of a Flask application object. If this argument is set, this Gui instance will use the value of this argument as the underlying server. If omitted or set to None, this Gui will create its own Flask application instance and use it to serve the pages. None add_page ( self , name , page , style = '' ) \u00b6 Add a page to the graphical User Interface. Parameters: Name Type Description Default name str The name of the page. required page Union[str, Page^] The content of the page. It can be an instance of Markdown^ or Html^ . If page is a string, then: If page is set to the pathname of a readable file, the page content is read as Markdown input text. If it is not, the page content is read from this string as Markdown text. required style Optional[str] Additional CSS style to apply to this page. if there is style associated with a page, it is used at a global level if there is no style associated with the page, the style is cleared at a global level if the page is embedded in a block control, the style is ignored '' Note that page names cannot start with the slash ('/') character and that each page must have a unique name. add_pages ( self , pages = None ) \u00b6 Add several pages to the graphical User Interface. Parameters: Name Type Description Default pages Union[dict[str, Union[str, Page^]], str] The pages to add. If pages is a dictionnary, a page is added to this Gui instance for each of the entries in pages : The entry key is used as the page name. The entry value is used as the page content: The value can can be an instance of Markdown^ or Html^ , then it is used as the page definition. If entry value is a string, then: If it is set to the pathname of a readable file, the page content is read as Markdown input text. If it is not, the page content is read from this string as Markdown text. If pages is a string that contains the path to a directory, then this directory is traversed, looking for filenames that have the .md extention, TODO None Reading pages from a directory If pages is a string that holds the path to a readable directory, then this directory is traversed, recursively, to find files that Taipy can build pages from. For every new directory that is traversed, a new hierarchical level for pages is created. For every file that is found: If the filename extention is .md , it is read as Markdown content and a new page is created with the base name of this filename. If the filename extention is .html , it is read as HTML content and a new page is created with the base name of this filename. For example, say you have the following directory structure: reports \u251c\u2500\u2500 home.html \u251c\u2500\u2500 budget/ \u2502 \u251c\u2500\u2500 expenses/ \u2502 \u2502 \u251c\u2500\u2500 marketing.md \u2502 \u2502 \u2514\u2500\u2500 production.md \u2502 \u2514\u2500\u2500 revenue/ \u2502 \u251c\u2500\u2500 EMAE.md \u2502 \u251c\u2500\u2500 USA.md \u2502 \u2514\u2500\u2500 ASIA.md \u2514\u2500\u2500 cashflow/ \u251c\u2500\u2500 weekly.md \u251c\u2500\u2500 monthly.md \u2514\u2500\u2500 yearly.md Calling gui.add_pages('reports') is equivalent to calling: gui . add_pages ({ \"reports/home\" , Html ( \"reports/home.html\" ), \"reports/budget/expenses/marketing\" , Markdown ( \"reports/budget/expenses/marketing.md\" ), \"reports/budget/expenses/production\" , Markdown ( \"reports/budget/expenses/production.md\" ), \"reports/budget/revenue/EMAE\" , Markdown ( \"reports/budget/revenue/EMAE.md\" ), \"reports/budget/revenue/USA\" , Markdown ( \"reports/budget/revenue/USA.md\" ), \"reports/budget/revenue/ASIA\" , Markdown ( \"reports/budget/revenue/ASIA.md\" ), \"reports/cashflow/weekly\" , Markdown ( \"reports/cashflow/weekly.md\" ), \"reports/cashflow/monthly\" , Markdown ( \"reports/cashflow/monthly.md\" ), \"reports/cashflow/yearly\" , Markdown ( \"reports/cashflow/yearly.md\" ) }) add_partial ( self , page ) \u00b6 Create a new Partial^ . The User Manual section on Partials gives details on when and how to use this class. Parameters: Name Type Description Default page Union[str, Page^] The page to create a new Partial from. It can be an instance of Markdown^ or Html^ . If page is a string, then: If page is set to the pathname of a readable file, the content of the new Partial is read as Markdown input text. If it is not, the content of the new Partial is read from this string as Markdown text. required Returns: Type Description Partial The new Partial object defined by page . get_flask_app ( self ) \u00b6 Get the internal Flask application. Returns: Type Description Flask the Flask instance used. run ( self , run_server = True , run_in_thread = False , ssl_context = None , ** kwargs ) \u00b6 Starts the server that delivers pages to Web clients. Once you enter run() , users can run Web browsers and point to the Web server URL that Gui serves. The default is to listen to the localhost address (127.0.0.1) on the port number 5000. However, the configuration of this Gui object may impact that (see the Configuration section of the User Manual for details). Parameters: Name Type Description Default run_server bool Whether or not to run a Web server locally. If set to False , a Web server is not created and started. True run_in_thread bool Whether or not to run a Web server in a separated thread. If set to True , the Web server is run is a separated thread. Note that if you are running in an IPython notebook context, the Web server is always run in a separate thread. False ssl_context Optional[Union[ssl.SSLContext, Tuple[str, Optional[str]], te.Literal['adhoc']]] Configure TLS to serve over HTTPS. Can be an ssl.SSLContext object, a (cert_file, key_file) tuple to create a typical context, or the string 'adhoc' to generate a temporary self-signed certificate. The default value is None. None kwargs Additional keywords that configure how this Gui is run. Please refer to the Configuration section in the User Manual for more information. {} Returns: Type Description t.Optional[Flask] The Flask instance if run_server is False else None . stop ( self ) \u00b6 Stops the Web server. This function stops the underlying Web server only in the situation where it was run in a separated thread: the run_in_thread parameter to the (Gui.)run^ method was set to True, or you are running in an IPython notebook context.","title":"taipy.gui.Gui"},{"location":"manuals/reference/taipy.gui.Gui/#taipy.gui.gui.Gui.__init__","text":"Initialize a new Gui instance. Parameters: Name Type Description Default page Optional[Union[str, Page^]] An optional Page^ instance that is used when there is a single page in this interface, referenced as the root page (located at / ). If page is a raw string and if it holds a path to a readable file then a Markdown^ page is built from the content of that file. If page is a string that does not indicate a path to readable file then a Markdown^ page is built from that string. Note that if pages is provided, those pages are added as well. None pages Optional[dict] Used if you want to initialize this instance with a set of pages. The method (Gui.)add_pages(pages)^ is called if pages is not None. You can find details on the possible values of this argument in the documentation for this method. None css_file str An optional pathname to a CSS file that gets used as a style sheet in all the pages. The default value is a file that has the same base name as the Python file defining the main function, sitting next to this Python file, with the .css extension. '__main__' path_mapping Optional[dict] A dictionary that associates a URL prefix to a path in the server filesystem. If the assets of your application are located in /home/me/app_assets and you want to access them with just assets in your application, you can set path_mapping={\"assets\": \"/home/me/app_assets\"} . If your application then requests the file \"/assets/images/logo.png\" , the server searches for the file \"/home/me/app_assets/images/logo.png\" . {} env_filename Optional[str] An optional file from which to load application configuration variables (see the Configuration section of the User Manual for details.) The default value is \"taipy.gui.env\" None flask Optional[Flask] An optional instance of a Flask application object. If this argument is set, this Gui instance will use the value of this argument as the underlying server. If omitted or set to None, this Gui will create its own Flask application instance and use it to serve the pages. None","title":"__init__()"},{"location":"manuals/reference/taipy.gui.Gui/#taipy.gui.gui.Gui.add_page","text":"Add a page to the graphical User Interface. Parameters: Name Type Description Default name str The name of the page. required page Union[str, Page^] The content of the page. It can be an instance of Markdown^ or Html^ . If page is a string, then: If page is set to the pathname of a readable file, the page content is read as Markdown input text. If it is not, the page content is read from this string as Markdown text. required style Optional[str] Additional CSS style to apply to this page. if there is style associated with a page, it is used at a global level if there is no style associated with the page, the style is cleared at a global level if the page is embedded in a block control, the style is ignored '' Note that page names cannot start with the slash ('/') character and that each page must have a unique name.","title":"add_page()"},{"location":"manuals/reference/taipy.gui.Gui/#taipy.gui.gui.Gui.add_pages","text":"Add several pages to the graphical User Interface. Parameters: Name Type Description Default pages Union[dict[str, Union[str, Page^]], str] The pages to add. If pages is a dictionnary, a page is added to this Gui instance for each of the entries in pages : The entry key is used as the page name. The entry value is used as the page content: The value can can be an instance of Markdown^ or Html^ , then it is used as the page definition. If entry value is a string, then: If it is set to the pathname of a readable file, the page content is read as Markdown input text. If it is not, the page content is read from this string as Markdown text. If pages is a string that contains the path to a directory, then this directory is traversed, looking for filenames that have the .md extention, TODO None Reading pages from a directory If pages is a string that holds the path to a readable directory, then this directory is traversed, recursively, to find files that Taipy can build pages from. For every new directory that is traversed, a new hierarchical level for pages is created. For every file that is found: If the filename extention is .md , it is read as Markdown content and a new page is created with the base name of this filename. If the filename extention is .html , it is read as HTML content and a new page is created with the base name of this filename. For example, say you have the following directory structure: reports \u251c\u2500\u2500 home.html \u251c\u2500\u2500 budget/ \u2502 \u251c\u2500\u2500 expenses/ \u2502 \u2502 \u251c\u2500\u2500 marketing.md \u2502 \u2502 \u2514\u2500\u2500 production.md \u2502 \u2514\u2500\u2500 revenue/ \u2502 \u251c\u2500\u2500 EMAE.md \u2502 \u251c\u2500\u2500 USA.md \u2502 \u2514\u2500\u2500 ASIA.md \u2514\u2500\u2500 cashflow/ \u251c\u2500\u2500 weekly.md \u251c\u2500\u2500 monthly.md \u2514\u2500\u2500 yearly.md Calling gui.add_pages('reports') is equivalent to calling: gui . add_pages ({ \"reports/home\" , Html ( \"reports/home.html\" ), \"reports/budget/expenses/marketing\" , Markdown ( \"reports/budget/expenses/marketing.md\" ), \"reports/budget/expenses/production\" , Markdown ( \"reports/budget/expenses/production.md\" ), \"reports/budget/revenue/EMAE\" , Markdown ( \"reports/budget/revenue/EMAE.md\" ), \"reports/budget/revenue/USA\" , Markdown ( \"reports/budget/revenue/USA.md\" ), \"reports/budget/revenue/ASIA\" , Markdown ( \"reports/budget/revenue/ASIA.md\" ), \"reports/cashflow/weekly\" , Markdown ( \"reports/cashflow/weekly.md\" ), \"reports/cashflow/monthly\" , Markdown ( \"reports/cashflow/monthly.md\" ), \"reports/cashflow/yearly\" , Markdown ( \"reports/cashflow/yearly.md\" ) })","title":"add_pages()"},{"location":"manuals/reference/taipy.gui.Gui/#taipy.gui.gui.Gui.add_partial","text":"Create a new Partial^ . The User Manual section on Partials gives details on when and how to use this class. Parameters: Name Type Description Default page Union[str, Page^] The page to create a new Partial from. It can be an instance of Markdown^ or Html^ . If page is a string, then: If page is set to the pathname of a readable file, the content of the new Partial is read as Markdown input text. If it is not, the content of the new Partial is read from this string as Markdown text. required Returns: Type Description Partial The new Partial object defined by page .","title":"add_partial()"},{"location":"manuals/reference/taipy.gui.Gui/#taipy.gui.gui.Gui.get_flask_app","text":"Get the internal Flask application. Returns: Type Description Flask the Flask instance used.","title":"get_flask_app()"},{"location":"manuals/reference/taipy.gui.Gui/#taipy.gui.gui.Gui.run","text":"Starts the server that delivers pages to Web clients. Once you enter run() , users can run Web browsers and point to the Web server URL that Gui serves. The default is to listen to the localhost address (127.0.0.1) on the port number 5000. However, the configuration of this Gui object may impact that (see the Configuration section of the User Manual for details). Parameters: Name Type Description Default run_server bool Whether or not to run a Web server locally. If set to False , a Web server is not created and started. True run_in_thread bool Whether or not to run a Web server in a separated thread. If set to True , the Web server is run is a separated thread. Note that if you are running in an IPython notebook context, the Web server is always run in a separate thread. False ssl_context Optional[Union[ssl.SSLContext, Tuple[str, Optional[str]], te.Literal['adhoc']]] Configure TLS to serve over HTTPS. Can be an ssl.SSLContext object, a (cert_file, key_file) tuple to create a typical context, or the string 'adhoc' to generate a temporary self-signed certificate. The default value is None. None kwargs Additional keywords that configure how this Gui is run. Please refer to the Configuration section in the User Manual for more information. {} Returns: Type Description t.Optional[Flask] The Flask instance if run_server is False else None .","title":"run()"},{"location":"manuals/reference/taipy.gui.Gui/#taipy.gui.gui.Gui.stop","text":"Stops the Web server. This function stops the underlying Web server only in the situation where it was run in a separated thread: the run_in_thread parameter to the (Gui.)run^ method was set to True, or you are running in an IPython notebook context.","title":"stop()"},{"location":"manuals/reference/taipy.gui.Html/","text":"Page generator for HTML text. Taipy can use HTML code to create pages that are the base of user interfaces. You can find details on HTML-specific constructs and how to add Taipy Visual Elements in the section on HTML of the User Manual. __init__ ( self , content ) special \u00b6 Initialize a new Html page. Parameters: Name Type Description Default content str The text content or the path to the file holding the HTML text to be transformed. If content is a path to a readable file, the file is read as the HTML template content. required","title":"taipy.gui.Html"},{"location":"manuals/reference/taipy.gui.Html/#taipy.gui.renderers.Html.__init__","text":"Initialize a new Html page. Parameters: Name Type Description Default content str The text content or the path to the file holding the HTML text to be transformed. If content is a path to a readable file, the file is read as the HTML template content. required","title":"__init__()"},{"location":"manuals/reference/taipy.gui.Icon/","text":"Small image in the User Interface. Icons are typically used in controls like button or items in a menu . Attributes: Name Type Description path str The path to the image file. text Optional[str] The text associated to the image or None if there is none. If a text is associated to an icon, it is rendered by the visual elements that uses this Icon. __init__ ( self , path , text = None ) special \u00b6 Initialize a new Icon. Parameters: Name Type Description Default path str The path to an image file. required text Optional[str] The text associated to the image. If text is None, there is no text associated to this image. None","title":"taipy.gui.Icon"},{"location":"manuals/reference/taipy.gui.Icon/#taipy.gui.icon.Icon.__init__","text":"Initialize a new Icon. Parameters: Name Type Description Default path str The path to an image file. required text Optional[str] The text associated to the image. If text is None, there is no text associated to this image. None","title":"__init__()"},{"location":"manuals/reference/taipy.gui.Markdown/","text":"Page generator for Markdown text. Taipy can use Markdown text to create pages that are the base of user interfaces. You can find details on the Taipy Markdown-specific syntax and how to add Taipy Visual Elements in the section on HTML of the User Manual. __init__ ( self , content ) special \u00b6 Initialize a new Markdown page. Parameters: Name Type Description Default content str The text content or the path to the file holding the Markdown text to be transformed. If content is a path to a readable file, the file is read as the Markdown template content. required","title":"taipy.gui.Markdown"},{"location":"manuals/reference/taipy.gui.Markdown/#taipy.gui.renderers.Markdown.__init__","text":"Initialize a new Markdown page. Parameters: Name Type Description Default content str The text content or the path to the file holding the Markdown text to be transformed. If content is a path to a readable file, the file is read as the Markdown template content. required","title":"__init__()"},{"location":"manuals/reference/taipy.gui.State/","text":"Accessor to the bound variables from callbacks. State is used when you need to access the value of variables bound to visual elements (see Binding ). Because each browser connected to the application server may represent and modify any variable at any moment as the result of user interaction, each connection holds its own set of variables along with their values. We call the set of these the application variables the application state , as seen by a given client. Each callback (see Callbacks )) receives a specific instance of the State class, where you can find all the variables bound to visual elements in your application. Note that State also is a Python Context Manager: In situations where you have several variables to update, it is more clear and more efficient to assign the variable values in a with construct: def my_callback ( state , ... ): ... with state as s : s . var1 = value1 s . var2 = value2 ... You cannot set a variable in the context of a lambda function because Python prevents any use of the assignment operator. You can, however, use the assign() method on the state that the lambda function receives, so you can work around this limitation: Here is how you could define a button that changes the value of a variable directly in the Markdown code: <|Set variable|button|on_action={lambda s: s.assign(\"var_name\", new_value}|> This would be strictly similar to the Markdown line: <|Set variable|button|on_action=change_variable|> with the Python code: def change_variable ( state ): state . var_name = new_value assign ( self , name , value ) \u00b6 Assign a value to a state variable. This should be used only from within a lambda function used as a callback in a visual element. Parameters: Name Type Description Default name str The variable name to assign to. required value Any The new variable value. required Returns: Type Description Any The previous value of the variable.","title":"taipy.gui.State"},{"location":"manuals/reference/taipy.gui.State/#taipy.gui.state.State.assign","text":"Assign a value to a state variable. This should be used only from within a lambda function used as a callback in a visual element. Parameters: Name Type Description Default name str The variable name to assign to. required value Any The new variable value. required Returns: Type Description Any The previous value of the variable.","title":"assign()"},{"location":"manuals/reference/taipy.gui.download/","text":"Download content to the client. Parameters: Name Type Description Default state State^ The current user state as received in any callback. required content Any File path or file content. required name Optional[str] File name for the content on the client browser (default to content name). '' on_action Optional[str] Function called when the download starts. ''","title":"Taipy.gui.download"},{"location":"manuals/reference/taipy.gui.hold_control/","text":"Hold the User Interface actions. When the User Interface is held, users cannot interact with visual elements. The application must call resume_control()^ so that users can interact again with the visual elements. Parameters: Name Type Description Default state State^ The current user state as received in any callback. required callback Optional[Union[str, Callable]] the function to be called if the user chooses to cancel. If empty or None, no cancel action is provided to the user. None message Optional[str] the message to show. 'Work in Progress...'","title":"Taipy.gui.hold control"},{"location":"manuals/reference/taipy.gui.navigate/","text":"Navigate to a page. Parameters: Name Type Description Default state State^ The current user state as received in any callback. required to Optional[str] The name of the page to navigate to. This must be a valid page identifier. If ommitted, the application navigates to the root page. ''","title":"Taipy.gui.navigate"},{"location":"manuals/reference/taipy.gui.notify/","text":"Send a notification to the user interface. Parameters: Name Type Description Default state State^ The current user state as received in any callback. required notification_type str The notification type. This can be one of \"success\" , \"info\" , \"warning\" , or \"error\" . To remove the last notification, set this parameter to the empty string. 'I' message str The text message to display. '' system_notification Optional[bool] If True, the system will also show the notification. If not specified or set to None, this parameter will use the value of configuration[system_notification] . None duration Optional[int] The time, in milliseconds, during which the notification is shown. If not specified or set to None, this parameter will use the value of configuration[notification_duration] . None Note that you can also call this function with notification_type set to the first letter or the alert type (ie setting notification_type to \"i\" is equivalent to setting it to \"info\"). If system_notification is set to True, then the browser requests the system to display a notification as well. They usually appear in small windows that fly out of the system tray. The first time your browser is requested to show such a system notification for Taipy applications, you may be prompted to authorize the browser to do so. Please refer to your browser documentation for details on how to allow or prevent this feature.","title":"Taipy.gui.notify"},{"location":"manuals/reference/taipy.gui.page.Page/","text":"Generic page generator. The Page class transforms template text into actual pages that can be displayed on a Web browser. When a page is requested to be displayed, it is converted into HTML code that can be sent to the client. All control placeholders are replaced by their respective graphical component so you can show your application variables and interact with them. __init__ ( self , content ) special \u00b6 Initialize a new Page with the indicated content. Parameters: Name Type Description Default content str The text content or the path to the file holding the text to be transformed. required If content is a path to a readable file, the file is read entirely as the text template. set_content ( self , content ) \u00b6 Set a new page content. Reads the new page content and reinitializes the page to reflect the change. Important This function can only be used an IPython notebook context. Parameters: Name Type Description Default content str The text content or the path to the file holding the text to be transformed. If content is a path to a readable file, the file is read entirely as the text template. required Exceptions: Type Description RuntimeError If this method is called outside an IPython notebook context.","title":"taipy.gui.page.Page"},{"location":"manuals/reference/taipy.gui.page.Page/#taipy.gui.page.Page.__init__","text":"Initialize a new Page with the indicated content. Parameters: Name Type Description Default content str The text content or the path to the file holding the text to be transformed. required If content is a path to a readable file, the file is read entirely as the text template.","title":"__init__()"},{"location":"manuals/reference/taipy.gui.page.Page/#taipy.gui.page.Page.set_content","text":"Set a new page content. Reads the new page content and reinitializes the page to reflect the change. Important This function can only be used an IPython notebook context. Parameters: Name Type Description Default content str The text content or the path to the file holding the text to be transformed. If content is a path to a readable file, the file is read entirely as the text template. required Exceptions: Type Description RuntimeError If this method is called outside an IPython notebook context.","title":"set_content()"},{"location":"manuals/reference/taipy.gui.partial.Partial/","text":"Re-usable Page content. Partials are used when you need to use a partial page content in different and not related pages. This allows not to have to repeat yourself when creating your page templates. Visual elements such as part , dialog or pane can use Partials. Note that Partial has no constructor (no __init__() method): to create a Partial , you must call the Gui.add_partial()^ function. Partials can be really handy if you want to modify a section of a page: the update_content() method dynamically update pages that make use of this Partial therefore making it easy to change the content of any page, at any moment. update_content ( self , state , content ) \u00b6 Update partial content. Parameters: Name Type Description Default state State^ The current user state as received in any callback. required content str The new content to use and display. required","title":"taipy.gui.partial.Partial"},{"location":"manuals/reference/taipy.gui.partial.Partial/#taipy.gui.partial.Partial.update_content","text":"Update partial content. Parameters: Name Type Description Default state State^ The current user state as received in any callback. required content str The new content to use and display. required","title":"update_content()"},{"location":"manuals/reference/taipy.gui.resume_control/","text":"Resume the User Interface actions. This function must be called after hold_control()^ was invoked, when interaction must be allowed again for the user. Parameters: Name Type Description Default state State^ The current user state as received in any callback. required","title":"Taipy.gui.resume control"},{"location":"manuals/reference/taipy.set/","text":"Save or update an entity. Parameters: Name Type Description Default entity Union[DataNode^, Task^, Job^, Pipeline^, Scenario^, Cycle^] The entity to save. required","title":"Taipy.set"},{"location":"manuals/reference/taipy.set_primary/","text":"Promote a scenario as the primary scenario of its cycle. If the cycle of scenario already has a primary scenario, it is demoted and is no longer the primary scenario for its cycle. Parameters: Name Type Description Default scenario Scenario^ The scenario to promote as primary . required","title":"Taipy.set primary"},{"location":"manuals/reference/taipy.submit/","text":"Submit an entity for execution. If the entity is a pipeline or a scenario, all the tasks of the entity are submitted for execution. Parameters: Name Type Description Default entity Union[Scenario^, Pipeline^, Task^] The entity to submit. required force bool If True, the execution is forced even if the data nodes are in cache. False","title":"Taipy.submit"},{"location":"manuals/reference/taipy.subscribe_pipeline/","text":"Subscribe a function to be called on job status change. The subscription is applied to all jobs created for the execution of pipeline . Parameters: Name Type Description Default callback Callable[[Pipeline^, Job^], None] The callable function to be called on status change. required pipeline Optional[Pipeline^] The pipeline to subscribe on. If None, the subscription is actived for all pipelines. None Note Notifications are applied only for jobs created after this subscription.","title":"Taipy.subscribe pipeline"},{"location":"manuals/reference/taipy.subscribe_scenario/","text":"Subscribe a function to be called on job status change. The subscription is applied to all jobs created for the execution of scenario . If no scenario is provided, the subscription applies to all scenarios. Parameters: Name Type Description Default callback Callable[[Scenario^, Job^], None] The function to be called on status change. required scenario Optional[Scenario^] The scenario that subscribes to callback . If None, the subscription is registered for all scenarios. None Note Notifications are applied only for jobs created after this subscription.","title":"Taipy.subscribe scenario"},{"location":"manuals/reference/taipy.tag/","text":"Add a tag to a scenario. If the scenario 's cycle already has another scenario tagged with tag , then this other scenario is untagged. Parameters: Name Type Description Default scenario Scenario^ The scenario to tag. required tag str The tag to apply to the scenario. required","title":"Taipy.tag"},{"location":"manuals/reference/taipy.unsubscribe_pipeline/","text":"Unsubscribe a function that is called when the status of a Job changes. Parameters: Name Type Description Default callback Callable[[Pipeline^, Job^], None] The callable function to be called on status change. required pipeline Optional[Pipeline^] The pipeline to unsubscribe to. If None, all pipelines unsubscribe to callback . None Note The function will continue to be called for ongoing jobs.","title":"Taipy.unsubscribe pipeline"},{"location":"manuals/reference/taipy.unsubscribe_scenario/","text":"Unsubscribe a function that is called when the status of a Job^ changes. If scenario is not provided, the subscription is removed for all scenarios. Parameters: Name Type Description Default callback Callable[[Scenario^, Job^], None] The function to unsubscribe to. required scenario Optional[Scenario^] The scenario to unsubscribe to. If None, all scenarios unsubscribe to callback . None Note The function will continue to be called for ongoing jobs.","title":"Taipy.unsubscribe scenario"},{"location":"manuals/reference/taipy.untag/","text":"Remove a tag from a scenario. Parameters: Name Type Description Default scenario Scenario^ The scenario to remove the tag from. required tag str The tag to remove from scenario . required","title":"Taipy.untag"},{"location":"manuals/reference/pkg_taipy.gui/","text":"Package: taipy.gui \u00b6 Taipy Graphical User Interface generator. \u00b6 The Taipy Gui package provides User Interface generation based on page templates. It can run a Web server that a Web browser can connect to. The pages are generated by a Web server that allows Web clients to connect, display and interact with the page content through visual elements. Each page can contain regular text and images, as well as Taipy controls that are typically linked to some value that is managed by the whole Taipy application. Here is how you can create your first Taipy User Interface: Create a Python source file. Copy these two lines into a file called taipy_app.py . from taipy import Gui Gui ( \"# Hello Taipy!\" ) . run () Install Taipy: pip install taipy Run your application: python taipy_app.py Your browser opens a new page, showing the content of your graphical application. Functions \u00b6 download() : Download content to the client. hold_control() : Hold the User Interface actions. navigate() : Navigate to a page. notify() : Send a notification to the user interface. resume_control() : Resume the User Interface actions. Classes \u00b6 Gui : Entry point for the Graphical User Interface generation. Html : Page generator for HTML text. Icon : Small image in the User Interface. Markdown : Page generator for Markdown text. State : Accessor to the bound variables from callbacks.","title":"Index"},{"location":"manuals/reference/pkg_taipy.gui/#package-taipygui","text":"","title":"Package: taipy.gui"},{"location":"manuals/reference/pkg_taipy.gui/#taipy-graphical-user-interface-generator","text":"The Taipy Gui package provides User Interface generation based on page templates. It can run a Web server that a Web browser can connect to. The pages are generated by a Web server that allows Web clients to connect, display and interact with the page content through visual elements. Each page can contain regular text and images, as well as Taipy controls that are typically linked to some value that is managed by the whole Taipy application. Here is how you can create your first Taipy User Interface: Create a Python source file. Copy these two lines into a file called taipy_app.py . from taipy import Gui Gui ( \"# Hello Taipy!\" ) . run () Install Taipy: pip install taipy Run your application: python taipy_app.py Your browser opens a new page, showing the content of your graphical application.","title":"Taipy Graphical User Interface generator."},{"location":"manuals/reference/pkg_taipy.gui/#functions","text":"download() : Download content to the client. hold_control() : Hold the User Interface actions. navigate() : Navigate to a page. notify() : Send a notification to the user interface. resume_control() : Resume the User Interface actions.","title":"Functions"},{"location":"manuals/reference/pkg_taipy.gui/#classes","text":"Gui : Entry point for the Graphical User Interface generation. Html : Page generator for HTML text. Icon : Small image in the User Interface. Markdown : Page generator for Markdown text. State : Accessor to the bound variables from callbacks.","title":"Classes"},{"location":"manuals/rest/","text":"Taipy REST API \u00b6 The Taipy REST package is a python library built on top of Taipy Core . Its purpose is to automate the use of Taipy Core features by providing a runnable application exposing REST APIs. It is particularly useful when it comes to integrating a Taipy application in a more complex IT ecosystem. What is a Taipy REST API \u00b6 Taipy REST API allows developers to create, read, update, run and remove Taipy entities (including scenarios, pipelines, tasks, data nodes) through REST APIs. For more details about Taipy entities, please refer to Core concepts documentation . How it works \u00b6 Configure your Taipy Core application. For more details on Taipy Core configuration, please refer to the Core configuration documentation . Configure Taipy REST environment FLASK_ENV : Can be set to \"development\" to set the server to debug mode. SECRET_KEY : The secret key of the server. Run Taipy REST import taipy as tp rest_service = tp.Rest() rest_service.run()","title":"Taipy REST API"},{"location":"manuals/rest/#taipy-rest-api","text":"The Taipy REST package is a python library built on top of Taipy Core . Its purpose is to automate the use of Taipy Core features by providing a runnable application exposing REST APIs. It is particularly useful when it comes to integrating a Taipy application in a more complex IT ecosystem.","title":"Taipy REST API"},{"location":"manuals/rest/#what-is-a-taipy-rest-api","text":"Taipy REST API allows developers to create, read, update, run and remove Taipy entities (including scenarios, pipelines, tasks, data nodes) through REST APIs. For more details about Taipy entities, please refer to Core concepts documentation .","title":"What is a Taipy REST API"},{"location":"manuals/rest/#how-it-works","text":"Configure your Taipy Core application. For more details on Taipy Core configuration, please refer to the Core configuration documentation . Configure Taipy REST environment FLASK_ENV : Can be set to \"development\" to set the server to debug mode. SECRET_KEY : The secret key of the server. Run Taipy REST import taipy as tp rest_service = tp.Rest() rest_service.run()","title":"How it works"},{"location":"manuals/rest/endpoints/","text":"Taipy Rest v1.0.0 Scroll down for example requests and responses. api get__api_v1_datanodes_{datanode_id} \u00b6 Code samples GET /api/v1/datanodes/{datanode_id} Get a datanode Get a single datanode by ID Parameters Name In Type Required Description datanode_id path string true none Example responses 200 Response { \"datanode\" : { \"config_id\" : \"string\" , \"edition_in_progress\" : true , \"id\" : \"string\" , \"job_ids\" : [ \"string\" ], \"last_edition_date\" : \"string\" , \"name\" : \"string\" , \"parent_id\" : \"string\" , \"properties\" : {}, \"scope\" : \"string\" , \"storage_type\" : \"string\" , \"validity_days\" : 0 , \"validity_seconds\" : 0 } } Responses Status Meaning Description Schema 200 OK none Inline 404 Not Found datanode does not exist None Response Schema Status Code 200 Name Type Required Restrictions Description \u00bb datanode DataNodeSchema false none none \u00bb\u00bb config_id string false none none \u00bb\u00bb edition_in_progress boolean false none none \u00bb\u00bb id string false none none \u00bb\u00bb job_ids [string] false none none \u00bb\u00bb last_edition_date string false none none \u00bb\u00bb name string false none none \u00bb\u00bb parent_id string false none none \u00bb\u00bb properties object false none none \u00bb\u00bb scope string false none none \u00bb\u00bb storage_type string false none none \u00bb\u00bb validity_days number false none none \u00bb\u00bb validity_seconds number false none none This operation does not require authentication delete__api_v1_datanodes_{datanode_id} \u00b6 Code samples DELETE /api/v1/datanodes/{datanode_id} Delete a datanode Delete a single datanode by ID Parameters Name In Type Required Description datanode_id path integer true none Example responses 200 Response { \"msg\" : \"datanode deleted\" } Responses Status Meaning Description Schema 200 OK none Inline 404 Not Found datanode does not exist None Response Schema Status Code 200 Name Type Required Restrictions Description \u00bb msg string false none none This operation does not require authentication get__api_v1_datanodes \u00b6 Code samples GET /api/v1/datanodes Get a list of datanodes Get a list of paginated datanodes Example responses 200 Response { \"results\" : [ { \"config_id\" : \"string\" , \"edition_in_progress\" : true , \"id\" : \"string\" , \"job_ids\" : [ \"string\" ], \"last_edition_date\" : \"string\" , \"name\" : \"string\" , \"parent_id\" : \"string\" , \"properties\" : {}, \"scope\" : \"string\" , \"storage_type\" : \"string\" , \"validity_days\" : 0 , \"validity_seconds\" : 0 } ] } Responses Status Meaning Description Schema 200 OK none Inline Response Schema Status Code 200 Name Type Required Restrictions Description \u00bb results [ DataNodeSchema ] false none none \u00bb\u00bb config_id string false none none \u00bb\u00bb edition_in_progress boolean false none none \u00bb\u00bb id string false none none \u00bb\u00bb job_ids [string] false none none \u00bb\u00bb last_edition_date string false none none \u00bb\u00bb name string false none none \u00bb\u00bb parent_id string false none none \u00bb\u00bb properties object false none none \u00bb\u00bb scope string false none none \u00bb\u00bb storage_type string false none none \u00bb\u00bb validity_days number false none none \u00bb\u00bb validity_seconds number false none none This operation does not require authentication post__api_v1_datanodes \u00b6 Code samples POST /api/v1/datanodes Create a datanode Create a new datanode Body parameter { \"name\" : \"string\" , \"scope\" : 0 , \"storage_type\" : \"string\" } Parameters Name In Type Required Description body body DataNodeConfig false none Example responses 201 Response { \"datanode\" : { \"name\" : \"string\" , \"scope\" : 0 , \"storage_type\" : \"string\" }, \"msg\" : \"datanode created\" } Responses Status Meaning Description Schema 201 Created none Inline Response Schema Status Code 201 Name Type Required Restrictions Description \u00bb datanode DataNodeConfig false none none \u00bb\u00bb name string false none none \u00bb\u00bb scope integer false none none \u00bb\u00bb storage_type string false none none \u00bb msg string false none none This operation does not require authentication get__api_v1_tasks_{task_id} \u00b6 Code samples GET /api/v1/tasks/{task_id} Get a task Get a single task by ID Parameters Name In Type Required Description task_id path string true none Example responses 200 Response { \"task\" : { \"config_id\" : \"string\" , \"function_module\" : \"string\" , \"function_name\" : \"string\" , \"id\" : \"string\" , \"input_ids\" : [ \"string\" ], \"output_ids\" : [ \"string\" ], \"parent_id\" : \"string\" } } Responses Status Meaning Description Schema 200 OK none Inline 404 Not Found task does not exist None Response Schema Status Code 200 Name Type Required Restrictions Description \u00bb task TaskSchema false none none \u00bb\u00bb config_id string false none none \u00bb\u00bb function_module string false none none \u00bb\u00bb function_name string false none none \u00bb\u00bb id string false none none \u00bb\u00bb input_ids [string] false none none \u00bb\u00bb output_ids [string] false none none \u00bb\u00bb parent_id string false none none This operation does not require authentication delete__api_v1_tasks_{task_id} \u00b6 Code samples DELETE /api/v1/tasks/{task_id} Delete a task Delete a single task by ID Parameters Name In Type Required Description task_id path integer true none Example responses 200 Response { \"msg\" : \"task deleted\" } Responses Status Meaning Description Schema 200 OK none Inline 404 Not Found task does not exist None Response Schema Status Code 200 Name Type Required Restrictions Description \u00bb msg string false none none This operation does not require authentication get__api_v1_tasks \u00b6 Code samples GET /api/v1/tasks Get a list of tasks Get a list of paginated tasks Example responses 200 Response { \"results\" : [ { \"config_id\" : \"string\" , \"function_module\" : \"string\" , \"function_name\" : \"string\" , \"id\" : \"string\" , \"input_ids\" : [ \"string\" ], \"output_ids\" : [ \"string\" ], \"parent_id\" : \"string\" } ] } Responses Status Meaning Description Schema 200 OK none Inline Response Schema Status Code 200 Name Type Required Restrictions Description \u00bb results [ TaskSchema ] false none none \u00bb\u00bb config_id string false none none \u00bb\u00bb function_module string false none none \u00bb\u00bb function_name string false none none \u00bb\u00bb id string false none none \u00bb\u00bb input_ids [string] false none none \u00bb\u00bb output_ids [string] false none none \u00bb\u00bb parent_id string false none none This operation does not require authentication post__api_v1_tasks \u00b6 Code samples POST /api/v1/tasks Create a task Create a new task Body parameter { \"config_id\" : \"string\" , \"function_module\" : \"string\" , \"function_name\" : \"string\" , \"id\" : \"string\" , \"input_ids\" : [ \"string\" ], \"output_ids\" : [ \"string\" ], \"parent_id\" : \"string\" } Parameters Name In Type Required Description body body TaskSchema false none Example responses 201 Response { \"msg\" : \"task created\" , \"task\" : { \"config_id\" : \"string\" , \"function_module\" : \"string\" , \"function_name\" : \"string\" , \"id\" : \"string\" , \"input_ids\" : [ \"string\" ], \"output_ids\" : [ \"string\" ], \"parent_id\" : \"string\" } } Responses Status Meaning Description Schema 201 Created none Inline Response Schema Status Code 201 Name Type Required Restrictions Description \u00bb msg string false none none \u00bb task TaskSchema false none none \u00bb\u00bb config_id string false none none \u00bb\u00bb function_module string false none none \u00bb\u00bb function_name string false none none \u00bb\u00bb id string false none none \u00bb\u00bb input_ids [string] false none none \u00bb\u00bb output_ids [string] false none none \u00bb\u00bb parent_id string false none none This operation does not require authentication post__api_v1_tasks_submit_{task_id} \u00b6 Code samples POST /api/v1/tasks/submit/{task_id} Execute a task Execute a task Parameters Name In Type Required Description task_id path string true none Example responses 204 Response { \"msg\" : \"task created\" , \"task\" : { \"config_id\" : \"string\" , \"function_module\" : \"string\" , \"function_name\" : \"string\" , \"id\" : \"string\" , \"input_ids\" : [ \"string\" ], \"output_ids\" : [ \"string\" ], \"parent_id\" : \"string\" } } Responses Status Meaning Description Schema 204 No Content none Inline Response Schema Status Code 204 Name Type Required Restrictions Description \u00bb msg string false none none \u00bb task TaskSchema false none none \u00bb\u00bb config_id string false none none \u00bb\u00bb function_module string false none none \u00bb\u00bb function_name string false none none \u00bb\u00bb id string false none none \u00bb\u00bb input_ids [string] false none none \u00bb\u00bb output_ids [string] false none none \u00bb\u00bb parent_id string false none none This operation does not require authentication get__api_v1_pipelines_{pipeline_id} \u00b6 Code samples GET /api/v1/pipelines/{pipeline_id} Get a pipeline Get a single pipeline by ID Parameters Name In Type Required Description pipeline_id path string true none Example responses 200 Response { \"pipeline\" : { \"config_id\" : \"string\" , \"parent_id\" : \"string\" , \"properties\" : {}, \"tasks\" : [ \"string\" ] } } Responses Status Meaning Description Schema 200 OK none Inline 404 Not Found pipeline does not exist None Response Schema Status Code 200 Name Type Required Restrictions Description \u00bb pipeline PipelineSchema false none none \u00bb\u00bb config_id string false none none \u00bb\u00bb parent_id string false none none \u00bb\u00bb properties object false none none \u00bb\u00bb tasks [string] false none none This operation does not require authentication delete__api_v1_pipelines_{pipeline_id} \u00b6 Code samples DELETE /api/v1/pipelines/{pipeline_id} Delete a pipeline Delete a single pipeline by ID Parameters Name In Type Required Description pipeline_id path integer true none Example responses 200 Response { \"msg\" : \"pipeline deleted\" } Responses Status Meaning Description Schema 200 OK none Inline 404 Not Found pipeline does not exist None Response Schema Status Code 200 Name Type Required Restrictions Description \u00bb msg string false none none This operation does not require authentication get__api_v1_pipelines \u00b6 Code samples GET /api/v1/pipelines Get a list of pipelines Get a list of paginated pipelines Example responses 200 Response { \"results\" : [ { \"config_id\" : \"string\" , \"parent_id\" : \"string\" , \"properties\" : {}, \"tasks\" : [ \"string\" ] } ] } Responses Status Meaning Description Schema 200 OK none Inline Response Schema Status Code 200 Name Type Required Restrictions Description \u00bb results [ PipelineSchema ] false none none \u00bb\u00bb config_id string false none none \u00bb\u00bb parent_id string false none none \u00bb\u00bb properties object false none none \u00bb\u00bb tasks [string] false none none This operation does not require authentication post__api_v1_pipelines \u00b6 Code samples POST /api/v1/pipelines Create a pipeline Create a new pipeline Body parameter { \"config_id\" : \"string\" , \"parent_id\" : \"string\" , \"properties\" : {}, \"tasks\" : [ \"string\" ] } Parameters Name In Type Required Description body body PipelineSchema false none Example responses 201 Response { \"msg\" : \"pipeline created\" , \"pipeline\" : { \"config_id\" : \"string\" , \"parent_id\" : \"string\" , \"properties\" : {}, \"tasks\" : [ \"string\" ] } } Responses Status Meaning Description Schema 201 Created none Inline Response Schema Status Code 201 Name Type Required Restrictions Description \u00bb msg string false none none \u00bb pipeline PipelineSchema false none none \u00bb\u00bb config_id string false none none \u00bb\u00bb parent_id string false none none \u00bb\u00bb properties object false none none \u00bb\u00bb tasks [string] false none none This operation does not require authentication post__api_v1_pipelines_submit_{pipeline_id} \u00b6 Code samples POST /api/v1/pipelines/submit/{pipeline_id} Execute a pipeline Execute a pipeline Parameters Name In Type Required Description pipeline_id path string true none Example responses 204 Response { \"msg\" : \"pipeline created\" , \"pipeline\" : { \"config_id\" : \"string\" , \"parent_id\" : \"string\" , \"properties\" : {}, \"tasks\" : [ \"string\" ] } } Responses Status Meaning Description Schema 204 No Content none Inline Response Schema Status Code 204 Name Type Required Restrictions Description \u00bb msg string false none none \u00bb pipeline PipelineSchema false none none \u00bb\u00bb config_id string false none none \u00bb\u00bb parent_id string false none none \u00bb\u00bb properties object false none none \u00bb\u00bb tasks [string] false none none This operation does not require authentication get__api_v1_scenarios_{scenario_id} \u00b6 Code samples GET /api/v1/scenarios/{scenario_id} Get a scenario Get a single scenario by ID Parameters Name In Type Required Description scenario_id path string true none Example responses 200 Response { \"scenario\" : { \"official_scenario\" : true , \"pipelines\" : [ \"string\" ], \"properties\" : {}, \"tags\" : [ \"string\" ] } } Responses Status Meaning Description Schema 200 OK none Inline 404 Not Found scenario does not exist None Response Schema Status Code 200 Name Type Required Restrictions Description \u00bb scenario ScenarioSchema false none none \u00bb\u00bb official_scenario boolean false none none \u00bb\u00bb pipelines [string] false none none \u00bb\u00bb properties object false none none \u00bb\u00bb tags [string] false none none This operation does not require authentication delete__api_v1_scenarios_{scenario_id} \u00b6 Code samples DELETE /api/v1/scenarios/{scenario_id} Delete a scenario Delete a single scenario by ID Parameters Name In Type Required Description scenario_id path integer true none Example responses 200 Response { \"msg\" : \"scenario deleted\" } Responses Status Meaning Description Schema 200 OK none Inline 404 Not Found scenario does not exist None Response Schema Status Code 200 Name Type Required Restrictions Description \u00bb msg string false none none This operation does not require authentication get__api_v1_scenarios \u00b6 Code samples GET /api/v1/scenarios Get a list of scenarios Get a list of paginated scenarios Example responses 200 Response { \"results\" : [ { \"official_scenario\" : true , \"pipelines\" : [ \"string\" ], \"properties\" : {}, \"tags\" : [ \"string\" ] } ] } Responses Status Meaning Description Schema 200 OK none Inline Response Schema Status Code 200 Name Type Required Restrictions Description \u00bb results [ ScenarioSchema ] false none none \u00bb\u00bb official_scenario boolean false none none \u00bb\u00bb pipelines [string] false none none \u00bb\u00bb properties object false none none \u00bb\u00bb tags [string] false none none This operation does not require authentication post__api_v1_scenarios \u00b6 Code samples POST /api/v1/scenarios Create a scenario Create a new scenario Body parameter { \"official_scenario\" : true , \"pipelines\" : [ \"string\" ], \"properties\" : {}, \"tags\" : [ \"string\" ] } Parameters Name In Type Required Description body body ScenarioSchema false none Example responses 201 Response { \"msg\" : \"scenario created\" , \"scenario\" : { \"official_scenario\" : true , \"pipelines\" : [ \"string\" ], \"properties\" : {}, \"tags\" : [ \"string\" ] } } Responses Status Meaning Description Schema 201 Created none Inline Response Schema Status Code 201 Name Type Required Restrictions Description \u00bb msg string false none none \u00bb scenario ScenarioSchema false none none \u00bb\u00bb official_scenario boolean false none none \u00bb\u00bb pipelines [string] false none none \u00bb\u00bb properties object false none none \u00bb\u00bb tags [string] false none none This operation does not require authentication post__api_v1_scenarios_submit_{scenario_id} \u00b6 Code samples POST /api/v1/scenarios/submit/{scenario_id} Execute a scenario Execute a scenario Parameters Name In Type Required Description scenario_id path string true none Example responses 204 Response { \"msg\" : \"scenario created\" , \"scenario\" : { \"official_scenario\" : true , \"pipelines\" : [ \"string\" ], \"properties\" : {}, \"tags\" : [ \"string\" ] } } Responses Status Meaning Description Schema 204 No Content none Inline Response Schema Status Code 204 Name Type Required Restrictions Description \u00bb msg string false none none \u00bb scenario ScenarioSchema false none none \u00bb\u00bb official_scenario boolean false none none \u00bb\u00bb pipelines [string] false none none \u00bb\u00bb properties object false none none \u00bb\u00bb tags [string] false none none This operation does not require authentication get__api_v1_cycles_{cycle_id} \u00b6 Code samples GET /api/v1/cycles/{cycle_id} Get a cycle Get a single cycle by ID Parameters Name In Type Required Description cycle_id path string true none Example responses 200 Response { \"cycle\" : { \"creation_date\" : \"string\" , \"end_date\" : \"string\" , \"frequency\" : \"string\" , \"id\" : \"string\" , \"name\" : \"string\" , \"properties\" : {}, \"start_date\" : \"string\" } } Responses Status Meaning Description Schema 200 OK none Inline 404 Not Found cycle does not exist None Response Schema Status Code 200 Name Type Required Restrictions Description \u00bb cycle CycleResponse false none none \u00bb\u00bb creation_date string false none none \u00bb\u00bb end_date string false none none \u00bb\u00bb frequency string false none none \u00bb\u00bb id string false none none \u00bb\u00bb name string false none none \u00bb\u00bb properties object false none none \u00bb\u00bb start_date string false none none This operation does not require authentication delete__api_v1_cycles_{cycle_id} \u00b6 Code samples DELETE /api/v1/cycles/{cycle_id} Delete a cycle Delete a single cycle by ID Parameters Name In Type Required Description cycle_id path integer true none Example responses 200 Response { \"msg\" : \"cycle deleted\" } Responses Status Meaning Description Schema 200 OK none Inline 404 Not Found cycle does not exist None Response Schema Status Code 200 Name Type Required Restrictions Description \u00bb msg string false none none This operation does not require authentication get__api_v1_cycles \u00b6 Code samples GET /api/v1/cycles Get a list of cycles Get a list of paginated cycles Example responses 200 Response { \"results\" : [ { \"creation_date\" : \"string\" , \"end_date\" : \"string\" , \"frequency\" : \"string\" , \"name\" : \"string\" , \"properties\" : {}, \"start_date\" : \"string\" } ] } Responses Status Meaning Description Schema 200 OK none Inline Response Schema Status Code 200 Name Type Required Restrictions Description \u00bb results [ CycleSchema ] false none none \u00bb\u00bb creation_date string false none none \u00bb\u00bb end_date string false none none \u00bb\u00bb frequency string false none none \u00bb\u00bb name string false none none \u00bb\u00bb properties object false none none \u00bb\u00bb start_date string false none none This operation does not require authentication post__api_v1_cycles \u00b6 Code samples POST /api/v1/cycles Create a cycle Create a new cycle Body parameter { \"creation_date\" : \"string\" , \"end_date\" : \"string\" , \"frequency\" : \"string\" , \"name\" : \"string\" , \"properties\" : {}, \"start_date\" : \"string\" } Parameters Name In Type Required Description body body CycleSchema false none Example responses 201 Response { \"cycle\" : { \"creation_date\" : \"string\" , \"end_date\" : \"string\" , \"frequency\" : \"string\" , \"name\" : \"string\" , \"properties\" : {}, \"start_date\" : \"string\" }, \"msg\" : \"cycle created\" } Responses Status Meaning Description Schema 201 Created none Inline Response Schema Status Code 201 Name Type Required Restrictions Description \u00bb cycle CycleSchema false none none \u00bb\u00bb creation_date string false none none \u00bb\u00bb end_date string false none none \u00bb\u00bb frequency string false none none \u00bb\u00bb name string false none none \u00bb\u00bb properties object false none none \u00bb\u00bb start_date string false none none \u00bb msg string false none none This operation does not require authentication get__api_v1_jobs_{job_id} \u00b6 Code samples GET /api/v1/jobs/{job_id} Get a job Get a single job by ID Parameters Name In Type Required Description job_id path string true none Example responses 200 Response { \"job\" : { \"callables\" : { \"module\" : \"string\" , \"name\" : \"string\" }, \"task_name\" : \"string\" } } Responses Status Meaning Description Schema 200 OK none Inline 404 Not Found job does not exist None Response Schema Status Code 200 Name Type Required Restrictions Description \u00bb job JobSchema false none none \u00bb\u00bb callables Callable false none none \u00bb\u00bb\u00bb module string false none none \u00bb\u00bb\u00bb name string false none none \u00bb\u00bb task_name string false none none This operation does not require authentication delete__api_v1_jobs_{job_id} \u00b6 Code samples DELETE /api/v1/jobs/{job_id} Delete a job Delete a single job by ID Parameters Name In Type Required Description job_id path integer true none Example responses 200 Response { \"msg\" : \"job deleted\" } Responses Status Meaning Description Schema 200 OK none Inline 404 Not Found job does not exist None Response Schema Status Code 200 Name Type Required Restrictions Description \u00bb msg string false none none This operation does not require authentication get__api_v1_jobs \u00b6 Code samples GET /api/v1/jobs Get a list of jobs Get a list of paginated jobs Example responses 200 Response { \"results\" : [ { \"callables\" : { \"module\" : \"string\" , \"name\" : \"string\" }, \"task_name\" : \"string\" } ] } Responses Status Meaning Description Schema 200 OK none Inline Response Schema Status Code 200 Name Type Required Restrictions Description \u00bb results [ JobSchema ] false none none \u00bb\u00bb callables Callable false none none \u00bb\u00bb\u00bb module string false none none \u00bb\u00bb\u00bb name string false none none \u00bb\u00bb task_name string false none none This operation does not require authentication post__api_v1_jobs \u00b6 Code samples POST /api/v1/jobs Create a job Create a new job Body parameter { \"callables\" : { \"module\" : \"string\" , \"name\" : \"string\" }, \"task_name\" : \"string\" } Parameters Name In Type Required Description body body JobSchema false none Example responses 201 Response { \"job\" : { \"callables\" : { \"module\" : \"string\" , \"name\" : \"string\" }, \"task_name\" : \"string\" }, \"msg\" : \"job created\" } Responses Status Meaning Description Schema 201 Created none Inline Response Schema Status Code 201 Name Type Required Restrictions Description \u00bb job JobSchema false none none \u00bb\u00bb callables Callable false none none \u00bb\u00bb\u00bb module string false none none \u00bb\u00bb\u00bb name string false none none \u00bb\u00bb task_name string false none none \u00bb msg string false none none This operation does not require authentication Schemas \u00b6 Callable { \"module\" : \"string\" , \"name\" : \"string\" } Properties \u00b6 Name Type Required Restrictions Description module string false none none name string false none none CycleResponse { \"creation_date\" : \"string\" , \"end_date\" : \"string\" , \"frequency\" : \"string\" , \"id\" : \"string\" , \"name\" : \"string\" , \"properties\" : {}, \"start_date\" : \"string\" } Properties \u00b6 Name Type Required Restrictions Description creation_date string false none none end_date string false none none frequency string false none none id string false none none name string false none none properties object false none none start_date string false none none CycleSchema { \"creation_date\" : \"string\" , \"end_date\" : \"string\" , \"frequency\" : \"string\" , \"name\" : \"string\" , \"properties\" : {}, \"start_date\" : \"string\" } Properties \u00b6 Name Type Required Restrictions Description creation_date string false none none end_date string false none none frequency string false none none name string false none none properties object false none none start_date string false none none DataNodeConfig { \"name\" : \"string\" , \"scope\" : 0 , \"storage_type\" : \"string\" } Properties \u00b6 Name Type Required Restrictions Description name string false none none scope integer false none none storage_type string false none none DataNodeSchema { \"config_id\" : \"string\" , \"edition_in_progress\" : true , \"id\" : \"string\" , \"job_ids\" : [ \"string\" ], \"last_edition_date\" : \"string\" , \"name\" : \"string\" , \"parent_id\" : \"string\" , \"properties\" : {}, \"scope\" : \"string\" , \"storage_type\" : \"string\" , \"validity_days\" : 0 , \"validity_seconds\" : 0 } Properties \u00b6 Name Type Required Restrictions Description config_id string false none none edition_in_progress boolean false none none id string false none none job_ids [string] false none none last_edition_date string false none none name string false none none parent_id string false none none properties object false none none scope string false none none storage_type string false none none validity_days number false none none validity_seconds number false none none JobSchema { \"callables\" : { \"module\" : \"string\" , \"name\" : \"string\" }, \"task_name\" : \"string\" } Properties \u00b6 Name Type Required Restrictions Description callables Callable false none none task_name string false none none PaginatedResult { \"next\" : \"string\" , \"pages\" : 0 , \"prev\" : \"string\" , \"total\" : 0 } Properties \u00b6 Name Type Required Restrictions Description next string false none none pages integer false none none prev string false none none total integer false none none PipelineSchema { \"config_id\" : \"string\" , \"parent_id\" : \"string\" , \"properties\" : {}, \"tasks\" : [ \"string\" ] } Properties \u00b6 Name Type Required Restrictions Description config_id string false none none parent_id string false none none properties object false none none tasks [string] false none none ScenarioSchema { \"official_scenario\" : true , \"pipelines\" : [ \"string\" ], \"properties\" : {}, \"tags\" : [ \"string\" ] } Properties \u00b6 Name Type Required Restrictions Description official_scenario boolean false none none pipelines [string] false none none properties object false none none tags [string] false none none TaskSchema { \"config_id\" : \"string\" , \"function_module\" : \"string\" , \"function_name\" : \"string\" , \"id\" : \"string\" , \"input_ids\" : [ \"string\" ], \"output_ids\" : [ \"string\" ], \"parent_id\" : \"string\" } Properties \u00b6 Name Type Required Restrictions Description config_id string false none none function_module string false none none function_name string false none none id string false none none input_ids [string] false none none output_ids [string] false none none parent_id string false none none","title":"Endpoints example"},{"location":"manuals/rest/endpoints/#get__api_v1_datanodes_datanode_id","text":"Code samples GET /api/v1/datanodes/{datanode_id} Get a datanode Get a single datanode by ID","title":"get__api_v1_datanodes_{datanode_id}"},{"location":"manuals/rest/endpoints/#delete__api_v1_datanodes_datanode_id","text":"Code samples DELETE /api/v1/datanodes/{datanode_id} Delete a datanode Delete a single datanode by ID","title":"delete__api_v1_datanodes_{datanode_id}"},{"location":"manuals/rest/endpoints/#get__api_v1_datanodes","text":"Code samples GET /api/v1/datanodes Get a list of datanodes Get a list of paginated datanodes Example responses 200 Response { \"results\" : [ { \"config_id\" : \"string\" , \"edition_in_progress\" : true , \"id\" : \"string\" , \"job_ids\" : [ \"string\" ], \"last_edition_date\" : \"string\" , \"name\" : \"string\" , \"parent_id\" : \"string\" , \"properties\" : {}, \"scope\" : \"string\" , \"storage_type\" : \"string\" , \"validity_days\" : 0 , \"validity_seconds\" : 0 } ] }","title":"get__api_v1_datanodes"},{"location":"manuals/rest/endpoints/#post__api_v1_datanodes","text":"Code samples POST /api/v1/datanodes Create a datanode Create a new datanode Body parameter { \"name\" : \"string\" , \"scope\" : 0 , \"storage_type\" : \"string\" }","title":"post__api_v1_datanodes"},{"location":"manuals/rest/endpoints/#get__api_v1_tasks_task_id","text":"Code samples GET /api/v1/tasks/{task_id} Get a task Get a single task by ID","title":"get__api_v1_tasks_{task_id}"},{"location":"manuals/rest/endpoints/#delete__api_v1_tasks_task_id","text":"Code samples DELETE /api/v1/tasks/{task_id} Delete a task Delete a single task by ID","title":"delete__api_v1_tasks_{task_id}"},{"location":"manuals/rest/endpoints/#get__api_v1_tasks","text":"Code samples GET /api/v1/tasks Get a list of tasks Get a list of paginated tasks Example responses 200 Response { \"results\" : [ { \"config_id\" : \"string\" , \"function_module\" : \"string\" , \"function_name\" : \"string\" , \"id\" : \"string\" , \"input_ids\" : [ \"string\" ], \"output_ids\" : [ \"string\" ], \"parent_id\" : \"string\" } ] }","title":"get__api_v1_tasks"},{"location":"manuals/rest/endpoints/#post__api_v1_tasks","text":"Code samples POST /api/v1/tasks Create a task Create a new task Body parameter { \"config_id\" : \"string\" , \"function_module\" : \"string\" , \"function_name\" : \"string\" , \"id\" : \"string\" , \"input_ids\" : [ \"string\" ], \"output_ids\" : [ \"string\" ], \"parent_id\" : \"string\" }","title":"post__api_v1_tasks"},{"location":"manuals/rest/endpoints/#post__api_v1_tasks_submit_task_id","text":"Code samples POST /api/v1/tasks/submit/{task_id} Execute a task Execute a task","title":"post__api_v1_tasks_submit_{task_id}"},{"location":"manuals/rest/endpoints/#get__api_v1_pipelines_pipeline_id","text":"Code samples GET /api/v1/pipelines/{pipeline_id} Get a pipeline Get a single pipeline by ID","title":"get__api_v1_pipelines_{pipeline_id}"},{"location":"manuals/rest/endpoints/#delete__api_v1_pipelines_pipeline_id","text":"Code samples DELETE /api/v1/pipelines/{pipeline_id} Delete a pipeline Delete a single pipeline by ID","title":"delete__api_v1_pipelines_{pipeline_id}"},{"location":"manuals/rest/endpoints/#get__api_v1_pipelines","text":"Code samples GET /api/v1/pipelines Get a list of pipelines Get a list of paginated pipelines Example responses 200 Response { \"results\" : [ { \"config_id\" : \"string\" , \"parent_id\" : \"string\" , \"properties\" : {}, \"tasks\" : [ \"string\" ] } ] }","title":"get__api_v1_pipelines"},{"location":"manuals/rest/endpoints/#post__api_v1_pipelines","text":"Code samples POST /api/v1/pipelines Create a pipeline Create a new pipeline Body parameter { \"config_id\" : \"string\" , \"parent_id\" : \"string\" , \"properties\" : {}, \"tasks\" : [ \"string\" ] }","title":"post__api_v1_pipelines"},{"location":"manuals/rest/endpoints/#post__api_v1_pipelines_submit_pipeline_id","text":"Code samples POST /api/v1/pipelines/submit/{pipeline_id} Execute a pipeline Execute a pipeline","title":"post__api_v1_pipelines_submit_{pipeline_id}"},{"location":"manuals/rest/endpoints/#get__api_v1_scenarios_scenario_id","text":"Code samples GET /api/v1/scenarios/{scenario_id} Get a scenario Get a single scenario by ID","title":"get__api_v1_scenarios_{scenario_id}"},{"location":"manuals/rest/endpoints/#delete__api_v1_scenarios_scenario_id","text":"Code samples DELETE /api/v1/scenarios/{scenario_id} Delete a scenario Delete a single scenario by ID","title":"delete__api_v1_scenarios_{scenario_id}"},{"location":"manuals/rest/endpoints/#get__api_v1_scenarios","text":"Code samples GET /api/v1/scenarios Get a list of scenarios Get a list of paginated scenarios Example responses 200 Response { \"results\" : [ { \"official_scenario\" : true , \"pipelines\" : [ \"string\" ], \"properties\" : {}, \"tags\" : [ \"string\" ] } ] }","title":"get__api_v1_scenarios"},{"location":"manuals/rest/endpoints/#post__api_v1_scenarios","text":"Code samples POST /api/v1/scenarios Create a scenario Create a new scenario Body parameter { \"official_scenario\" : true , \"pipelines\" : [ \"string\" ], \"properties\" : {}, \"tags\" : [ \"string\" ] }","title":"post__api_v1_scenarios"},{"location":"manuals/rest/endpoints/#post__api_v1_scenarios_submit_scenario_id","text":"Code samples POST /api/v1/scenarios/submit/{scenario_id} Execute a scenario Execute a scenario","title":"post__api_v1_scenarios_submit_{scenario_id}"},{"location":"manuals/rest/endpoints/#get__api_v1_cycles_cycle_id","text":"Code samples GET /api/v1/cycles/{cycle_id} Get a cycle Get a single cycle by ID","title":"get__api_v1_cycles_{cycle_id}"},{"location":"manuals/rest/endpoints/#delete__api_v1_cycles_cycle_id","text":"Code samples DELETE /api/v1/cycles/{cycle_id} Delete a cycle Delete a single cycle by ID","title":"delete__api_v1_cycles_{cycle_id}"},{"location":"manuals/rest/endpoints/#get__api_v1_cycles","text":"Code samples GET /api/v1/cycles Get a list of cycles Get a list of paginated cycles Example responses 200 Response { \"results\" : [ { \"creation_date\" : \"string\" , \"end_date\" : \"string\" , \"frequency\" : \"string\" , \"name\" : \"string\" , \"properties\" : {}, \"start_date\" : \"string\" } ] }","title":"get__api_v1_cycles"},{"location":"manuals/rest/endpoints/#post__api_v1_cycles","text":"Code samples POST /api/v1/cycles Create a cycle Create a new cycle Body parameter { \"creation_date\" : \"string\" , \"end_date\" : \"string\" , \"frequency\" : \"string\" , \"name\" : \"string\" , \"properties\" : {}, \"start_date\" : \"string\" }","title":"post__api_v1_cycles"},{"location":"manuals/rest/endpoints/#get__api_v1_jobs_job_id","text":"Code samples GET /api/v1/jobs/{job_id} Get a job Get a single job by ID","title":"get__api_v1_jobs_{job_id}"},{"location":"manuals/rest/endpoints/#delete__api_v1_jobs_job_id","text":"Code samples DELETE /api/v1/jobs/{job_id} Delete a job Delete a single job by ID","title":"delete__api_v1_jobs_{job_id}"},{"location":"manuals/rest/endpoints/#get__api_v1_jobs","text":"Code samples GET /api/v1/jobs Get a list of jobs Get a list of paginated jobs Example responses 200 Response { \"results\" : [ { \"callables\" : { \"module\" : \"string\" , \"name\" : \"string\" }, \"task_name\" : \"string\" } ] }","title":"get__api_v1_jobs"},{"location":"manuals/rest/endpoints/#post__api_v1_jobs","text":"Code samples POST /api/v1/jobs Create a job Create a new job Body parameter { \"callables\" : { \"module\" : \"string\" , \"name\" : \"string\" }, \"task_name\" : \"string\" }","title":"post__api_v1_jobs"},{"location":"manuals/rest/endpoints/#schemas","text":"","title":"Schemas"},{"location":"manuals/rest/endpoints/#properties","text":"Name Type Required Restrictions Description module string false none none name string false none none","title":"Properties"},{"location":"manuals/rest/endpoints/#properties_1","text":"Name Type Required Restrictions Description creation_date string false none none end_date string false none none frequency string false none none id string false none none name string false none none properties object false none none start_date string false none none","title":"Properties"},{"location":"manuals/rest/endpoints/#properties_2","text":"Name Type Required Restrictions Description creation_date string false none none end_date string false none none frequency string false none none name string false none none properties object false none none start_date string false none none","title":"Properties"},{"location":"manuals/rest/endpoints/#properties_3","text":"Name Type Required Restrictions Description name string false none none scope integer false none none storage_type string false none none","title":"Properties"},{"location":"manuals/rest/endpoints/#properties_4","text":"Name Type Required Restrictions Description config_id string false none none edition_in_progress boolean false none none id string false none none job_ids [string] false none none last_edition_date string false none none name string false none none parent_id string false none none properties object false none none scope string false none none storage_type string false none none validity_days number false none none validity_seconds number false none none","title":"Properties"},{"location":"manuals/rest/endpoints/#properties_5","text":"Name Type Required Restrictions Description callables Callable false none none task_name string false none none","title":"Properties"},{"location":"manuals/rest/endpoints/#properties_6","text":"Name Type Required Restrictions Description next string false none none pages integer false none none prev string false none none total integer false none none","title":"Properties"},{"location":"manuals/rest/endpoints/#properties_7","text":"Name Type Required Restrictions Description config_id string false none none parent_id string false none none properties object false none none tasks [string] false none none","title":"Properties"},{"location":"manuals/rest/endpoints/#properties_8","text":"Name Type Required Restrictions Description official_scenario boolean false none none pipelines [string] false none none properties object false none none tags [string] false none none","title":"Properties"},{"location":"manuals/rest/endpoints/#properties_9","text":"Name Type Required Restrictions Description config_id string false none none function_module string false none none function_name string false none none id string false none none input_ids [string] false none none output_ids [string] false none none parent_id string false none none","title":"Properties"}]}